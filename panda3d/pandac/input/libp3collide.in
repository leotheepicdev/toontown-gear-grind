1609778506
3 3
12 libp3collide 4 dlaq 12 panda3d.core 
263
276 20 get_collision_origin 0 6 539 36 CollisionSolid::get_collision_origin 0 1 1 0
69
virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0;

277 12 set_tangible 0 4 539 28 CollisionSolid::set_tangible 0 1 2 295
/**
 * Sets the current state of the 'tangible' flag.  Set this true to make the
 * solid tangible, so that a CollisionHandlerPusher will not allow another
 * object to intersect it, or false to make it intangible, so that a
 * CollisionHandlerPusher will ignore it except to throw an event.
 */
56
inline void CollisionSolid::set_tangible(bool tangible);

278 11 is_tangible 0 4 539 27 CollisionSolid::is_tangible 0 1 3 266
/**
 * Returns whether the solid is considered 'tangible' or not.  An intangible
 * solid has no effect in a CollisionHandlerPusher (except to throw an event);
 * it's useful for defining 'trigger' planes and spheres, that cause an effect
 * when passed through.
 */
52
inline bool CollisionSolid::is_tangible(void) const;

279 20 set_effective_normal 0 4 539 36 CollisionSolid::set_effective_normal 0 1 4 388
/**
 * Records a false normal for this CollisionSolid that will be reported by the
 * collision system with all collisions into it, instead of its actual normal.
 * This is useful as a workaround for the problem of an avatar wanting to
 * stand on a sloping ground; by storing a false normal, the ground appears to
 * be perfectly level, and the avatar does not tend to slide down it.
 */
83
inline void CollisionSolid::set_effective_normal(LVector3 const &effective_normal);

280 22 clear_effective_normal 0 4 539 38 CollisionSolid::clear_effective_normal 0 1 5 71
/**
 * Removes the normal previously set by set_effective_normal().
 */
57
inline void CollisionSolid::clear_effective_normal(void);

281 20 has_effective_normal 0 4 539 36 CollisionSolid::has_effective_normal 0 1 6 98
/**
 * Returns true if a special normal was set by set_effective_normal(), false
 * otherwise.
 */
61
inline bool CollisionSolid::has_effective_normal(void) const;

282 20 get_effective_normal 0 4 539 36 CollisionSolid::get_effective_normal 0 1 7 145
/**
 * Returns the normal that was set by set_effective_normal().  It is an error
 * to call this unless has_effective_normal() returns true.
 */
72
inline LVector3 const &CollisionSolid::get_effective_normal(void) const;

283 28 set_respect_effective_normal 0 4 539 44 CollisionSolid::set_respect_effective_normal 0 1 8 296
/**
 * This is only meaningful for CollisionSolids that will be added to a
 * traverser as colliders.  It is normally true, but if set false, it means
 * that this particular solid does not care about the "effective" normal of
 * other solids it meets, but rather always uses the true normal.
 */
88
inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal);

284 28 get_respect_effective_normal 0 4 539 44 CollisionSolid::get_respect_effective_normal 0 1 9 46
/**
 * See set_respect_effective_normal().
 */
69
inline bool CollisionSolid::get_respect_effective_normal(void) const;

285 10 get_bounds 0 4 539 26 CollisionSolid::get_bounds 0 1 10 47
/**
 * Returns the solid's bounding volume.
 */
72
ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const;

286 10 set_bounds 0 4 539 26 CollisionSolid::set_bounds 0 1 11 47
/**
 * Returns the solid's bounding volume.
 */
71
void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume);

287 6 output 0 6 539 22 CollisionSolid::output 0 1 12 10
/**
 *
 */
61
virtual void CollisionSolid::output(std::ostream &out) const;

288 5 write 0 6 539 21 CollisionSolid::write 0 1 13 10
/**
 *
 */
82
virtual void CollisionSolid::write(std::ostream &out, int indent_level = 0) const;

289 14 get_class_type 0 4 539 30 CollisionSolid::get_class_type 0 1 14 0
55
static TypeHandle CollisionSolid::get_class_type(void);

290 12 CollisionBox 0 4 545 26 CollisionBox::CollisionBox 0 2 15 16 256
/**
 * Create the Box by giving a Center and distances of each of the sides of
 * box from the Center.
 */

/**
 * Create the Box by Specifying the Diagonal Points
 */

/**
 * Creates an invalid Box.  Only used when reading from a bam file.
 */

/**
 *
 */
195
inline explicit CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline explicit CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max);

291 14 get_num_points 0 4 545 28 CollisionBox::get_num_points 0 1 17 68
/**
 * Returns 8: the number of vertices of a rectangular solid.
 */
52
inline int CollisionBox::get_num_points(void) const;

292 14 get_point_aabb 0 4 545 28 CollisionBox::get_point_aabb 0 1 18 67
/**
 * Returns the nth vertex of the Axis Aligned Bounding Box.
 */
57
inline LPoint3 CollisionBox::get_point_aabb(int n) const;

293 9 get_point 0 4 545 23 CollisionBox::get_point 0 1 19 45
/**
 * Returns the nth vertex of the OBB.
 */
52
inline LPoint3 CollisionBox::get_point(int n) const;

294 14 get_num_planes 0 4 545 28 CollisionBox::get_num_planes 0 1 20 65
/**
 * Returns 6: the number of faces of a rectangular solid.
 */
52
inline int CollisionBox::get_num_planes(void) const;

295 9 set_plane 0 4 545 23 CollisionBox::set_plane 0 1 21 57
/**
 * Creates the nth face of the rectangular solid.
 */
51
inline LPlane CollisionBox::set_plane(int n) const;

296 9 get_plane 0 4 545 23 CollisionBox::get_plane 0 1 22 57
/**
 * Returns the nth face of the rectangular solid.
 */
51
inline LPlane CollisionBox::get_plane(int n) const;

297 10 set_center 0 4 545 24 CollisionBox::set_center 0 2 23 24 22
/**
 *
 */

/**
 *
 */
143
inline void CollisionBox::set_center(LPoint3 const &center);
inline void CollisionBox::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

298 10 get_center 0 4 545 24 CollisionBox::get_center 0 1 25 10
/**
 *
 */
59
inline LPoint3 const &CollisionBox::get_center(void) const;

299 7 get_min 0 4 545 21 CollisionBox::get_min 0 1 26 10
/**
 *
 */
56
inline LPoint3 const &CollisionBox::get_min(void) const;

300 7 get_max 0 4 545 21 CollisionBox::get_max 0 1 27 10
/**
 *
 */
56
inline LPoint3 const &CollisionBox::get_max(void) const;

301 14 get_dimensions 0 4 545 28 CollisionBox::get_dimensions 0 1 28 10
/**
 *
 */
57
inline LVector3 CollisionBox::get_dimensions(void) const;

302 14 get_class_type 0 4 545 28 CollisionBox::get_class_type 0 1 29 0
53
static TypeHandle CollisionBox::get_class_type(void);

303 13 ~CollisionBox 0 4 545 27 CollisionBox::~CollisionBox 0 0 0
34
CollisionBox::~CollisionBox(void);

304 16 CollisionCapsule 0 4 549 34 CollisionCapsule::CollisionCapsule 0 2 30 31 115
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid capsule.  Only used when reading from a bam file.
 */

/**
 *
 */
276
inline explicit CollisionCapsule::CollisionCapsule(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius);
inline explicit CollisionCapsule::CollisionCapsule(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius);

305 11 set_point_a 0 4 549 29 CollisionCapsule::set_point_a 0 2 32 33 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionCapsule::set_point_a(LPoint3 const &a);
inline void CollisionCapsule::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

306 11 get_point_a 0 4 549 29 CollisionCapsule::get_point_a 0 1 34 10
/**
 *
 */
64
inline LPoint3 const &CollisionCapsule::get_point_a(void) const;

307 11 set_point_b 0 4 549 29 CollisionCapsule::set_point_b 0 2 35 36 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionCapsule::set_point_b(LPoint3 const &b);
inline void CollisionCapsule::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

308 11 get_point_b 0 4 549 29 CollisionCapsule::get_point_b 0 1 37 10
/**
 *
 */
64
inline LPoint3 const &CollisionCapsule::get_point_b(void) const;

309 10 set_radius 0 4 549 28 CollisionCapsule::set_radius 0 1 38 10
/**
 *
 */
61
inline void CollisionCapsule::set_radius(PN_stdfloat radius);

310 10 get_radius 0 4 549 28 CollisionCapsule::get_radius 0 1 39 10
/**
 *
 */
60
inline PN_stdfloat CollisionCapsule::get_radius(void) const;

311 14 get_class_type 0 4 549 32 CollisionCapsule::get_class_type 0 1 40 0
57
static TypeHandle CollisionCapsule::get_class_type(void);

312 17 ~CollisionCapsule 0 4 549 35 CollisionCapsule::~CollisionCapsule 0 0 0
42
CollisionCapsule::~CollisionCapsule(void);

313 14 get_class_type 0 4 552 32 CollisionHandler::get_class_type 0 1 42 0
57
static TypeHandle CollisionHandler::get_class_type(void);

314 16 CollisionHandler 0 4 552 34 CollisionHandler::CollisionHandler 0 1 41 10
/**
 *
 */
78
inline CollisionHandler::CollisionHandler(CollisionHandler const &) = default;

315 17 ~CollisionHandler 0 4 552 35 CollisionHandler::~CollisionHandler 0 0 0
42
CollisionHandler::~CollisionHandler(void);

316 13 CollisionNode 0 4 554 28 CollisionNode::CollisionNode 0 1 43 22
/**
 *
 */

/**
 *
 */
63
explicit CollisionNode::CollisionNode(std::string const &name);

317 16 set_collide_mask 0 4 554 31 CollisionNode::set_collide_mask 0 1 44 98
/**
 * Simultaneously sets both the "from" and "into" CollideMask values to the
 * same thing.
 */
62
inline void CollisionNode::set_collide_mask(CollideMask mask);

318 21 set_from_collide_mask 0 4 554 36 CollisionNode::set_from_collide_mask 0 1 45 222
/**
 * Sets the "from" CollideMask.  In order for a collision to be detected from
 * this object into another object, the intersection of this object's "from"
 * mask and the other object's "into" mask must be nonzero.
 */
60
void CollisionNode::set_from_collide_mask(CollideMask mask);

319 21 set_into_collide_mask 0 4 554 36 CollisionNode::set_into_collide_mask 0 1 46 222
/**
 * Sets the "into" CollideMask.  In order for a collision to be detected from
 * another object into this object, the intersection of the other object's
 * "from" mask and this object's "into" mask must be nonzero.
 */
67
inline void CollisionNode::set_into_collide_mask(CollideMask mask);

320 21 get_from_collide_mask 0 4 554 36 CollisionNode::get_from_collide_mask 0 1 47 233
/**
 * Returns the current "from" CollideMask.  In order for a collision to be
 * detected from this object into another object, the intersection of this
 * object's "from" mask and the other object's "into" mask must be nonzero.
 */
68
inline CollideMask CollisionNode::get_from_collide_mask(void) const;

321 21 get_into_collide_mask 0 4 554 36 CollisionNode::get_into_collide_mask 0 1 48 233
/**
 * Returns the current "into" CollideMask.  In order for a collision to be
 * detected from another object into this object, the intersection of the
 * other object's "from" mask and this object's "into" mask must be nonzero.
 */
68
inline CollideMask CollisionNode::get_into_collide_mask(void) const;

322 12 clear_solids 0 4 554 27 CollisionNode::clear_solids 0 1 49 44
/**
 * Removes all solids from the node.
 */
46
inline void CollisionNode::clear_solids(void);

323 14 get_num_solids 0 4 554 29 CollisionNode::get_num_solids 0 1 50 10
/**
 *
 */
61
inline std::size_t CollisionNode::get_num_solids(void) const;

324 9 get_solid 0 4 554 24 CollisionNode::get_solid 0 1 51 10
/**
 *
 */
86
inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(std::size_t n) const;

325 12 modify_solid 0 4 554 27 CollisionNode::modify_solid 0 1 52 10
/**
 *
 */
78
inline PointerTo< CollisionSolid > CollisionNode::modify_solid(std::size_t n);

326 9 set_solid 0 4 554 24 CollisionNode::set_solid 0 1 53 55
/**
 * Replaces the solid with the indicated index.
 */
75
inline void CollisionNode::set_solid(std::size_t n, CollisionSolid *solid);

327 12 insert_solid 0 4 554 27 CollisionNode::insert_solid 0 1 54 77
/**
 * Inserts the indicated solid to the node at the indicated position.
 */
84
inline void CollisionNode::insert_solid(std::size_t n, CollisionSolid const *solid);

328 12 remove_solid 0 4 554 27 CollisionNode::remove_solid 0 1 55 110
/**
 * Removes the solid with the indicated index.  This will shift all subsequent
 * indices down by one.
 */
55
inline void CollisionNode::remove_solid(std::size_t n);

329 9 add_solid 0 4 554 24 CollisionNode::add_solid 0 1 56 121
/**
 * Adds the indicated solid to the node.  Returns the index of the new solid
 * within the node's list of solids.
 */
73
inline std::size_t CollisionNode::add_solid(CollisionSolid const *solid);

330 17 get_collider_sort 0 4 554 32 CollisionNode::get_collider_sort 0 1 57 114
/**
 * Returns the collider_sort value that has been set for this particular node.
 * See set_collider_sort().
 */
56
inline int CollisionNode::get_collider_sort(void) const;

331 17 set_collider_sort 0 4 554 32 CollisionNode::set_collider_sort 0 1 58 594
/**
 * Sets a particular collider_sort value on this node.  This controls the
 * order in which colliders (that is, "from nodes") are grouped together for
 * the collision traversal.
 *
 * If there are 32 or fewer colliders added to any particular
 * CollisionTraverser, then this value has no meaning.  It is only useful if
 * there are many colliders, which may force the CollisionTraverser to make
 * multiple passes through the data; in that case, it may be a useful
 * optimization to group colliders that have similar bounding volumes together
 * (by giving them similar sort values).
 */
55
inline void CollisionNode::set_collider_sort(int sort);

332 24 get_default_collide_mask 0 4 554 39 CollisionNode::get_default_collide_mask 0 1 59 80
/**
 * Returns the default into_collide_mask assigned to new CollisionNodes.
 */
72
static inline CollideMask CollisionNode::get_default_collide_mask(void);

333 14 get_class_type 0 4 554 29 CollisionNode::get_class_type 0 1 60 0
54
static TypeHandle CollisionNode::get_class_type(void);

334 18 CollisionTraverser 0 4 561 38 CollisionTraverser::CollisionTraverser 0 2 61 62 10
/**
 *
 */
168
explicit CollisionTraverser::CollisionTraverser(std::string const &name = "ctrav");
inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default;

335 19 ~CollisionTraverser 0 4 561 39 CollisionTraverser::~CollisionTraverser 0 0 10
/**
 *
 */
46
CollisionTraverser::~CollisionTraverser(void);

336 26 set_respect_prev_transform 0 4 561 46 CollisionTraverser::set_respect_prev_transform 0 1 63 370
/**
 * Sets the flag that indicates whether the prev_transform stored on a node
 * (as updated via set_fluid_pos(), etc.) is respected to calculate
 * collisions.  If this is true, certain types of collision tests will be
 * enhanced by the information about objects in motion.  If this is false,
 * objects are always considered to be static.  The default is false.
 */
70
inline void CollisionTraverser::set_respect_prev_transform(bool flag);

337 26 get_respect_prev_transform 0 4 561 46 CollisionTraverser::get_respect_prev_transform 0 1 64 162
/**
 * Returns the flag that indicates whether the prev_transform stored on a node
 * is respected to calculate collisions.  See set_respect_prev_transform().
 */
71
inline bool CollisionTraverser::get_respect_prev_transform(void) const;

338 12 add_collider 0 4 561 32 CollisionTraverser::add_collider 0 1 65 437
/**
 * Adds a new CollisionNode, representing an object that will be tested for
 * collisions into other objects, along with the handler that will serve each
 * detected collision.  Each CollisionNode may be served by only one handler
 * at a time, but a given handler may serve many CollisionNodes.
 *
 * The handler that serves a particular node may be changed from time to time
 * by calling add_collider() again on the same node.
 */
91
void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler);

339 15 remove_collider 0 4 561 35 CollisionTraverser::remove_collider 0 1 66 263
/**
 * Removes the collider (and its associated handler) from the set of
 * CollisionNodes that will be tested each frame for collisions into other
 * objects.  Returns true if the definition was found and removed, false if it
 * wasn't present to begin with.
 */
67
bool CollisionTraverser::remove_collider(NodePath const &collider);

340 12 has_collider 0 4 561 32 CollisionTraverser::has_collider 0 1 67 145
/**
 * Returns true if the indicated node is current in the set of nodes that will
 * be tested each frame for collisions into other objects.
 */
70
bool CollisionTraverser::has_collider(NodePath const &collider) const;

341 17 get_num_colliders 0 4 561 37 CollisionTraverser::get_num_colliders 0 1 68 108
/**
 * Returns the number of CollisionNodes that have been added to the traverser
 * via add_collider().
 */
54
int CollisionTraverser::get_num_colliders(void) const;

342 12 get_collider 0 4 561 32 CollisionTraverser::get_collider 0 1 69 100
/**
 * Returns the nth CollisionNode that has been added to the traverser via
 * add_collider().
 */
55
NodePath CollisionTraverser::get_collider(int n) const;

343 11 get_handler 0 4 561 31 CollisionTraverser::get_handler 0 1 70 169
/**
 * Returns the handler that is currently assigned to serve the indicated
 * collision node, or NULL if the node is not on the traverser's set of active
 * nodes.
 */
82
CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const;

344 15 clear_colliders 0 4 561 35 CollisionTraverser::clear_colliders 0 1 71 90
/**
 * Completely empties the set of collision nodes and their associated
 * handlers.
 */
47
void CollisionTraverser::clear_colliders(void);

345 8 traverse 0 4 561 28 CollisionTraverser::traverse 0 1 72 247
/**
 * Perform the traversal. Begins at the indicated root and detects all
 * collisions with any of its collider objects against nodes at or below the
 * indicated root, calling the appropriate CollisionHandler for each detected
 * collision.
 */
56
void CollisionTraverser::traverse(NodePath const &root);

346 12 set_recorder 0 4 561 32 CollisionTraverser::set_recorder 0 1 73 777
/**
 * Uses the indicated CollisionRecorder object to start recording the
 * intersection tests made by each subsequent call to traverse() on this
 * object.  A particular CollisionRecorder object can only record one
 * traverser at a time; if this object has already been assigned to another
 * traverser, that assignment is broken.
 *
 * This is intended to be used in a debugging mode to try to determine what
 * work is being performed by the collision traversal.  Usually, attaching a
 * recorder will impose significant runtime overhead.
 *
 * This does not transfer ownership of the CollisionRecorder pointer;
 * maintenance of that remains the caller's responsibility.  If the
 * CollisionRecorder is destructed, it will cleanly remove itself from the
 * traverser.
 */
67
void CollisionTraverser::set_recorder(CollisionRecorder *recorder);

347 12 has_recorder 0 4 561 32 CollisionTraverser::has_recorder 0 1 74 120
/**
 * Returns true if the CollisionTraverser has a CollisionRecorder object
 * currently assigned, false otherwise.
 */
57
inline bool CollisionTraverser::has_recorder(void) const;

348 12 get_recorder 0 4 561 32 CollisionTraverser::get_recorder 0 1 75 99
/**
 * Returns the CollisionRecorder currently assigned, or NULL if no recorder is
 * assigned.
 */
71
inline CollisionRecorder *CollisionTraverser::get_recorder(void) const;

349 14 clear_recorder 0 4 561 34 CollisionTraverser::clear_recorder 0 1 76 107
/**
 * Removes the CollisionRecorder from the traverser and restores normal low-
 * overhead operation.
 */
53
inline void CollisionTraverser::clear_recorder(void);

350 6 output 0 4 565 25 CollisionRecorder::output 0 1 84 10
/**
 *
 */
56
void CollisionRecorder::output(std::ostream &out) const;

351 14 get_class_type 0 4 565 33 CollisionRecorder::get_class_type 0 1 85 0
58
static TypeHandle CollisionRecorder::get_class_type(void);

352 15 show_collisions 0 4 561 35 CollisionTraverser::show_collisions 0 1 77 300
/**
 * This is a high-level function to create a CollisionVisualizer object to
 * render the collision tests performed by this traverser.  The supplied root
 * should be any node in the scene graph; typically, the top node (e.g.
 * render).  The CollisionVisualizer will be attached to this node.
 */
69
PandaNode *CollisionTraverser::show_collisions(NodePath const &root);

353 15 hide_collisions 0 4 561 35 CollisionTraverser::hide_collisions 0 1 78 69
/**
 * Undoes the effect of a previous call to show_collisions().
 */
47
void CollisionTraverser::hide_collisions(void);

354 6 output 0 4 561 26 CollisionTraverser::output 0 1 79 10
/**
 *
 */
57
void CollisionTraverser::output(std::ostream &out) const;

355 5 write 0 4 561 25 CollisionTraverser::write 0 1 80 10
/**
 *
 */
74
void CollisionTraverser::write(std::ostream &out, int indent_level) const;

356 12 __getstate__ 0 4 561 32 CollisionTraverser::__getstate__ 0 1 81 0
55
PyObject *CollisionTraverser::__getstate__(void) const;

357 12 __setstate__ 0 4 561 32 CollisionTraverser::__setstate__ 0 1 82 0
55
void CollisionTraverser::__setstate__(PyObject *state);

358 14 get_class_type 0 4 561 34 CollisionTraverser::get_class_type 0 1 83 0
59
static TypeHandle CollisionTraverser::get_class_type(void);

359 8 get_from 0 4 567 24 CollisionEntry::get_from 0 1 86 104
/**
 * Returns the CollisionSolid pointer for the particular solid that triggered
 * this collision.
 */
66
inline CollisionSolid const *CollisionEntry::get_from(void) const;

360 8 has_into 0 4 567 24 CollisionEntry::has_into 0 1 87 288
/**
 * Returns true if the "into" solid is, in fact, a CollisionSolid, and its
 * pointer is known (in which case get_into() may be called to retrieve it).
 * If this returns false, the collision was detected into a GeomNode, and
 * there is no CollisionSolid pointer to be retrieved.
 */
49
inline bool CollisionEntry::has_into(void) const;

361 8 get_into 0 4 567 24 CollisionEntry::get_into 0 1 88 243
/**
 * Returns the CollisionSolid pointer for the particular solid was collided
 * into.  This pointer might be NULL if the collision was into a piece of
 * visible geometry, instead of a normal CollisionSolid collision; see
 * has_into().
 */
66
inline CollisionSolid const *CollisionEntry::get_into(void) const;

362 13 get_from_node 0 4 567 29 CollisionEntry::get_from_node 0 1 89 182
/**
 * Returns the node that contains the CollisionSolid that triggered this
 * collision.  This will be a node that has been added to a CollisionTraverser
 * via add_collider().
 */
64
inline CollisionNode *CollisionEntry::get_from_node(void) const;

363 13 get_into_node 0 4 567 29 CollisionEntry::get_into_node 0 1 90 254
/**
 * Returns the node that contains the CollisionSolid that was collided into.
 * This returns a PandaNode pointer instead of something more specific,
 * because it might be either a CollisionNode or a GeomNode.
 *
 * Also see get_into_node_path().
 */
60
inline PandaNode *CollisionEntry::get_into_node(void) const;

364 18 get_from_node_path 0 4 567 34 CollisionEntry::get_from_node_path 0 1 91 224
/**
 * Returns the NodePath that represents the CollisionNode that contains the
 * CollisionSolid that triggered this collision.  This will be a NodePath that
 * has been added to a CollisionTraverser via add_collider().
 */
63
inline NodePath CollisionEntry::get_from_node_path(void) const;

365 18 get_into_node_path 0 4 567 34 CollisionEntry::get_into_node_path 0 1 92 338
/**
 * Returns the NodePath that represents the specific CollisionNode or GeomNode
 * instance that was collided into.  This is the same node returned by
 * get_into_node(), represented as a NodePath; however, it may be more useful
 * because the NodePath can resolve the particular instance of the node, if
 * there is more than one.
 */
63
inline NodePath CollisionEntry::get_into_node_path(void) const;

366 5 set_t 0 4 567 21 CollisionEntry::set_t 0 1 93 82
/**
 * Sets a time value for this collision relative to other CollisionEntries
 */
49
inline void CollisionEntry::set_t(PN_stdfloat t);

367 5 get_t 0 4 567 21 CollisionEntry::get_t 0 1 94 83
/**
 * returns time value for this collision relative to other CollisionEntries
 */
53
inline PN_stdfloat CollisionEntry::get_t(void) const;

368 8 collided 0 4 567 24 CollisionEntry::collided 0 1 95 188
/**
 * returns true if this represents an actual collision as opposed to a
 * potential collision, needed for iterative collision resolution where path
 * of collider changes mid-frame
 */
49
inline bool CollisionEntry::collided(void) const;

369 14 reset_collided 0 4 567 30 CollisionEntry::reset_collided 0 1 96 45
/**
 * prepare for another collision test
 */
49
inline void CollisionEntry::reset_collided(void);

370 26 get_respect_prev_transform 0 4 567 42 CollisionEntry::get_respect_prev_transform 0 1 97 203
/**
 * Returns true if the collision was detected by a CollisionTraverser whose
 * respect_prev_transform flag was set true, meaning we should consider motion
 * significant in evaluating collisions.
 */
67
inline bool CollisionEntry::get_respect_prev_transform(void) const;

371 17 set_surface_point 0 4 567 33 CollisionEntry::set_surface_point 0 1 98 178
/**
 * Stores the point, on the surface of the "into" object, at which a collision
 * is detected.
 *
 * This point is specified in the coordinate space of the "into" object.
 */
68
inline void CollisionEntry::set_surface_point(LPoint3 const &point);

372 18 set_surface_normal 0 4 567 34 CollisionEntry::set_surface_normal 0 1 99 171
/**
 * Stores the surface normal of the "into" object at the point of the
 * intersection.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */
71
inline void CollisionEntry::set_surface_normal(LVector3 const &normal);

373 18 set_interior_point 0 4 567 34 CollisionEntry::set_interior_point 0 1 100 352
/**
 * Stores the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).
 *
 * This point is specified in the coordinate space of the "into" object.
 */
69
inline void CollisionEntry::set_interior_point(LPoint3 const &point);

374 17 has_surface_point 0 4 567 33 CollisionEntry::has_surface_point 0 1 101 174
/**
 * Returns true if the surface point has been specified, false otherwise.  See
 * get_surface_point().  Some types of collisions may not compute the surface
 * point.
 */
58
inline bool CollisionEntry::has_surface_point(void) const;

375 18 has_surface_normal 0 4 567 34 CollisionEntry::has_surface_normal 0 1 102 176
/**
 * Returns true if the surface normal has been specified, false otherwise.
 * See get_surface_normal().  Some types of collisions may not compute the
 * surface normal.
 */
59
inline bool CollisionEntry::has_surface_normal(void) const;

376 18 has_interior_point 0 4 567 34 CollisionEntry::has_interior_point 0 1 103 176
/**
 * Returns true if the interior point has been specified, false otherwise.
 * See get_interior_point().  Some types of collisions may not compute the
 * interior point.
 */
59
inline bool CollisionEntry::has_interior_point(void) const;

377 15 set_contact_pos 0 4 567 31 CollisionEntry::set_contact_pos 0 1 104 190
/**
 * Stores the position of the "from" object at the instant at which the
 * collision is first detected.
 *
 * This position is specified in the coordinate space of the "into" object.
 */
64
inline void CollisionEntry::set_contact_pos(LPoint3 const &pos);

378 18 set_contact_normal 0 4 567 34 CollisionEntry::set_contact_normal 0 1 105 154
/**
 * Stores the surface normal of the "into" object at the contact pos.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */
71
inline void CollisionEntry::set_contact_normal(LVector3 const &normal);

379 15 has_contact_pos 0 4 567 31 CollisionEntry::has_contact_pos 0 1 106 172
/**
 * Returns true if the contact position has been specified, false otherwise.
 * See get_contact_pos().  Some types of collisions may not compute the
 * contact pos.
 */
56
inline bool CollisionEntry::has_contact_pos(void) const;

380 18 has_contact_normal 0 4 567 34 CollisionEntry::has_contact_normal 0 1 107 176
/**
 * Returns true if the contact normal has been specified, false otherwise.
 * See get_contact_normal().  Some types of collisions may not compute the
 * contact normal.
 */
59
inline bool CollisionEntry::has_contact_normal(void) const;

381 17 get_surface_point 0 4 567 33 CollisionEntry::get_surface_point 0 1 108 330
/**
 * Returns the point, on the surface of the "into" object, at which a
 * collision is detected.  This can be thought of as the first point of
 * intersection.  However the contact point is the actual first point of
 * intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */
71
LPoint3 CollisionEntry::get_surface_point(NodePath const &space) const;

382 18 get_surface_normal 0 4 567 34 CollisionEntry::get_surface_normal 0 1 109 200
/**
 * Returns the surface normal of the "into" object at the point at which a
 * collision is detected.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */
73
LVector3 CollisionEntry::get_surface_normal(NodePath const &space) const;

383 18 get_interior_point 0 4 567 34 CollisionEntry::get_interior_point 0 1 110 431
/**
 * Returns the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).  It can be thought of as the
 * deepest point of intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */
72
LPoint3 CollisionEntry::get_interior_point(NodePath const &space) const;

384 7 get_all 0 4 567 23 CollisionEntry::get_all 0 1 111 244
/**
 * Simultaneously transforms the surface point, surface normal, and interior
 * point of the collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */
133
bool CollisionEntry::get_all(NodePath const &space, LPoint3 &surface_point, LVector3 &surface_normal, LPoint3 &interior_point) const;

385 15 get_contact_pos 0 4 567 31 CollisionEntry::get_contact_pos 0 1 112 200
/**
 * Returns the position of the "from" object at the instant that a collision
 * is first detected.
 *
 * The position will be converted into whichever coordinate space the caller
 * specifies.
 */
69
LPoint3 CollisionEntry::get_contact_pos(NodePath const &space) const;

386 18 get_contact_normal 0 4 567 34 CollisionEntry::get_contact_normal 0 1 113 175
/**
 * Returns the surface normal of the "into" object at the contact position.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */
73
LVector3 CollisionEntry::get_contact_normal(NodePath const &space) const;

387 20 get_all_contact_info 0 4 567 36 CollisionEntry::get_all_contact_info 0 1 114 230
/**
 * Simultaneously transforms the contact position and contact normal of the
 * collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */
119
bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3 &contact_pos, LVector3 &contact_normal) const;

388 6 output 0 4 567 22 CollisionEntry::output 0 1 115 10
/**
 *
 */
53
void CollisionEntry::output(std::ostream &out) const;

389 5 write 0 4 567 21 CollisionEntry::write 0 1 116 10
/**
 *
 */
74
void CollisionEntry::write(std::ostream &out, int indent_level = 0) const;

390 14 get_class_type 0 4 567 30 CollisionEntry::get_class_type 0 1 117 0
55
static TypeHandle CollisionEntry::get_class_type(void);

391 15 ~CollisionEntry 0 4 567 31 CollisionEntry::~CollisionEntry 0 0 0
38
CollisionEntry::~CollisionEntry(void);

392 14 CollisionPlane 0 4 573 30 CollisionPlane::CollisionPlane 0 2 118 119 168
/**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */

/**
 *
 */

/**
 *
 */
126
inline CollisionPlane::CollisionPlane(LPlane const &plane);
inline CollisionPlane::CollisionPlane(CollisionPlane const &copy);

393 10 get_normal 0 4 573 26 CollisionPlane::get_normal 0 1 120 10
/**
 *
 */
55
inline LVector3 CollisionPlane::get_normal(void) const;

394 13 dist_to_plane 0 4 573 29 CollisionPlane::dist_to_plane 0 1 121 10
/**
 *
 */
77
inline PN_stdfloat CollisionPlane::dist_to_plane(LPoint3 const &point) const;

395 9 set_plane 0 4 573 25 CollisionPlane::set_plane 0 1 122 10
/**
 *
 */
59
inline void CollisionPlane::set_plane(LPlane const &plane);

396 9 get_plane 0 4 573 25 CollisionPlane::get_plane 0 1 123 10
/**
 *
 */
59
inline LPlane const &CollisionPlane::get_plane(void) const;

397 4 flip 0 4 573 20 CollisionPlane::flip 0 1 124 57
/**
 * Convenience method to flip the plane in-place.
 */
39
inline void CollisionPlane::flip(void);

398 14 get_class_type 0 4 573 30 CollisionPlane::get_class_type 0 1 125 0
55
static TypeHandle CollisionPlane::get_class_type(void);

399 15 ~CollisionPlane 0 4 573 31 CollisionPlane::~CollisionPlane 0 0 0
38
CollisionPlane::~CollisionPlane(void);

400 18 CollisionFloorMesh 0 4 577 38 CollisionFloorMesh::CollisionFloorMesh 0 1 126 156
/**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */

/**
 *
 */
52
inline CollisionFloorMesh::CollisionFloorMesh(void);

401 10 add_vertex 0 4 577 30 CollisionFloorMesh::add_vertex 0 1 127 47
/**
 * store away a vertex to index against
 */
64
inline void CollisionFloorMesh::add_vertex(LPoint3 const &vert);

402 12 add_triangle 0 4 577 32 CollisionFloorMesh::add_triangle 0 1 128 42
/**
 * store a triangle for processing
 */
101
void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC);

403 16 get_num_vertices 0 4 577 36 CollisionFloorMesh::get_num_vertices 0 1 129 0
69
inline unsigned int CollisionFloorMesh::get_num_vertices(void) const;

404 10 get_vertex 0 4 577 30 CollisionFloorMesh::get_vertex 0 1 130 0
79
inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const;

405 17 get_num_triangles 0 4 577 37 CollisionFloorMesh::get_num_triangles 0 1 131 0
70
inline unsigned int CollisionFloorMesh::get_num_triangles(void) const;

406 12 get_triangle 0 4 577 32 CollisionFloorMesh::get_triangle 0 1 132 0
75
inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const;

407 14 get_class_type 0 4 577 34 CollisionFloorMesh::get_class_type 0 1 133 0
59
static TypeHandle CollisionFloorMesh::get_class_type(void);

408 19 ~CollisionFloorMesh 0 4 577 39 CollisionFloorMesh::~CollisionFloorMesh 0 0 0
46
CollisionFloorMesh::~CollisionFloorMesh(void);

409 16 CollisionPolygon 0 4 579 34 CollisionPolygon::CollisionPolygon 0 2 134 135 127
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid polygon.  Only used when reading from a bam file.
 */

/**
 *
 */
225
inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c);
inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d);

410 14 get_num_points 0 4 579 32 CollisionPolygon::get_num_points 0 1 136 66
/**
 * Returns the number of vertices of the CollisionPolygon.
 */
64
inline std::size_t CollisionPolygon::get_num_points(void) const;

411 9 get_point 0 4 579 27 CollisionPolygon::get_point 0 1 137 82
/**
 * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.
 */
64
inline LPoint3 CollisionPolygon::get_point(std::size_t n) const;

412 13 verify_points 0 4 579 31 CollisionPolygon::verify_points 0 3 138 139 140 676
/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */

/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */

/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 *
 * This does not check that the polygon defined is convex; that check is made
 * later, once we have projected the points to 2-d space where the decision is
 * easier.
 */
285
static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d);
static bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c);
static bool CollisionPolygon::verify_points(PyObject *points);

413 8 is_valid 0 4 579 26 CollisionPolygon::is_valid 0 1 141 122
/**
 * Returns true if the CollisionPolygon is valid (that is, it has at least
 * three vertices), or false otherwise.
 */
44
bool CollisionPolygon::is_valid(void) const;

414 10 is_concave 0 4 579 28 CollisionPolygon::is_concave 0 1 142 106
/**
 * Returns true if the CollisionPolygon appears to be concave, or false if it
 * is safely convex.
 */
46
bool CollisionPolygon::is_concave(void) const;

415 12 setup_points 0 4 579 30 CollisionPolygon::setup_points 0 1 143 10
/**
 *
 */
54
void CollisionPolygon::setup_points(PyObject *points);

416 14 get_class_type 0 4 579 32 CollisionPolygon::get_class_type 0 1 144 0
57
static TypeHandle CollisionPolygon::get_class_type(void);

417 17 ~CollisionPolygon 0 4 579 35 CollisionPolygon::~CollisionPolygon 0 0 0
42
CollisionPolygon::~CollisionPolygon(void);

418 21 CollisionHandlerEvent 0 4 580 44 CollisionHandlerEvent::CollisionHandlerEvent 0 2 145 146 168
/**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */
145
CollisionHandlerEvent::CollisionHandlerEvent(void);
inline CollisionHandlerEvent::CollisionHandlerEvent(CollisionHandlerEvent const &) = default;

419 17 clear_in_patterns 0 4 580 40 CollisionHandlerEvent::clear_in_patterns 0 1 147 80
/**
 * Removes all of the previously-added in patterns.  See add_in_pattern.
 */
59
inline void CollisionHandlerEvent::clear_in_patterns(void);

420 14 add_in_pattern 0 4 580 37 CollisionHandlerEvent::add_in_pattern 0 1 148 1586
/**
 * Adds a pattern string to the list of events that will be generated in
 * response to a collision.  The pattern string describes how the event name
 * will be composed.  It is a string that may contain any of the following:
 *
 * %fn  - the name of the "from" object's node %in  - the name of the "into"
 * object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
 * 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
 * into a CollisionNode, 'g' if it is a geom.
 *
 * %(tag)fh - generate event only if "from" node has the indicated net tag.
 * %(tag)fx - generate event only if "from" node does not have the indicated
 * net tag.  %(tag)ih - generate event only if "into" node has the indicated
 * net tag.  %(tag)ix - generate event only if "into" node does not have the
 * indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
 * node.  %(tag)it - the indicated net tag value of the "into" node.
 *
 * Parentheses in the above are literal and should be included in the actual
 * pattern.
 *
 * The event name will be based on the in_pattern string specified here, with
 * all occurrences of the above strings replaced with the corresponding
 * values.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
81
inline void CollisionHandlerEvent::add_in_pattern(std::string const &in_pattern);

421 14 set_in_pattern 0 4 580 37 CollisionHandlerEvent::set_in_pattern 0 1 149 189
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_in_pattern() instead.
 */
81
inline void CollisionHandlerEvent::set_in_pattern(std::string const &in_pattern);

422 19 get_num_in_patterns 0 4 580 42 CollisionHandlerEvent::get_num_in_patterns 0 1 150 73
/**
 * Returns the number of in pattern strings that have been added.
 */
66
inline int CollisionHandlerEvent::get_num_in_patterns(void) const;

423 14 get_in_pattern 0 4 580 37 CollisionHandlerEvent::get_in_pattern 0 1 151 145
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_in_pattern().
 */
70
inline std::string CollisionHandlerEvent::get_in_pattern(int n) const;

424 20 clear_again_patterns 0 4 580 43 CollisionHandlerEvent::clear_again_patterns 0 1 152 83
/**
 * Removes all of the previously-added in patterns.  See add_again_pattern.
 */
62
inline void CollisionHandlerEvent::clear_again_patterns(void);

425 17 add_again_pattern 0 4 580 40 CollisionHandlerEvent::add_again_pattern 0 1 153 649
/**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *still* detected.  This
 * event is thrown each consecutive time a collision between two particular
 * nodes is detected, starting with the second time.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
87
inline void CollisionHandlerEvent::add_again_pattern(std::string const &again_pattern);

426 17 set_again_pattern 0 4 580 40 CollisionHandlerEvent::set_again_pattern 0 1 154 192
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_again_pattern() instead.
 */
87
inline void CollisionHandlerEvent::set_again_pattern(std::string const &again_pattern);

427 22 get_num_again_patterns 0 4 580 45 CollisionHandlerEvent::get_num_again_patterns 0 1 155 73
/**
 * Returns the number of in pattern strings that have been added.
 */
69
inline int CollisionHandlerEvent::get_num_again_patterns(void) const;

428 17 get_again_pattern 0 4 580 40 CollisionHandlerEvent::get_again_pattern 0 1 156 148
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_again_pattern().
 */
73
inline std::string CollisionHandlerEvent::get_again_pattern(int n) const;

429 18 clear_out_patterns 0 4 580 41 CollisionHandlerEvent::clear_out_patterns 0 1 157 81
/**
 * Removes all of the previously-added in patterns.  See add_out_pattern.
 */
60
inline void CollisionHandlerEvent::clear_out_patterns(void);

430 15 add_out_pattern 0 4 580 38 CollisionHandlerEvent::add_out_pattern 0 1 158 518
/**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *no longer* detected.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
83
inline void CollisionHandlerEvent::add_out_pattern(std::string const &out_pattern);

431 15 set_out_pattern 0 4 580 38 CollisionHandlerEvent::set_out_pattern 0 1 159 190
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_out_pattern() instead.
 */
83
inline void CollisionHandlerEvent::set_out_pattern(std::string const &out_pattern);

432 20 get_num_out_patterns 0 4 580 43 CollisionHandlerEvent::get_num_out_patterns 0 1 160 73
/**
 * Returns the number of in pattern strings that have been added.
 */
67
inline int CollisionHandlerEvent::get_num_out_patterns(void) const;

433 15 get_out_pattern 0 4 580 38 CollisionHandlerEvent::get_out_pattern 0 1 161 146
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_out_pattern().
 */
71
inline std::string CollisionHandlerEvent::get_out_pattern(int n) const;

434 5 clear 0 4 580 28 CollisionHandlerEvent::clear 0 1 162 541
/**
 * Empties the list of elements that all colliders are known to be colliding
 * with.  No "out" events will be thrown; if the same collision is detected
 * next frame, a new "in" event will be thrown for each collision.
 *
 * This can be called each frame to defeat the persistent "in" event
 * mechanism, which prevents the same "in" event from being thrown repeatedly.
 * However, also see add_again_pattern(), which can be used to set the event
 * that is thrown when a collision is detected for two or more consecutive
 * frames.
 */
40
void CollisionHandlerEvent::clear(void);

435 5 flush 0 4 580 28 CollisionHandlerEvent::flush 0 1 163 58
/**
 * Same as clear() except "out" events are thrown.
 */
40
void CollisionHandlerEvent::flush(void);

436 10 __reduce__ 0 4 580 33 CollisionHandlerEvent::__reduce__ 0 1 164 46
// These help implement Python pickle support.
66
PyObject *CollisionHandlerEvent::__reduce__(PyObject *self) const;

437 12 __setstate__ 0 4 580 35 CollisionHandlerEvent::__setstate__ 0 1 165 0
76
void CollisionHandlerEvent::__setstate__(PyObject *self, vector_uchar data);

438 14 write_datagram 0 6 580 37 CollisionHandlerEvent::write_datagram 0 1 166 63
/**
 * Serializes this object, to implement pickle support.
 */
80
virtual void CollisionHandlerEvent::write_datagram(Datagram &destination) const;

439 13 read_datagram 0 6 580 36 CollisionHandlerEvent::read_datagram 0 1 167 104
/**
 * Restores the object state from the given datagram, previously obtained using
 * __getstate__.
 */
76
virtual void CollisionHandlerEvent::read_datagram(DatagramIterator &source);

440 14 get_class_type 0 4 580 37 CollisionHandlerEvent::get_class_type 0 1 168 0
62
static TypeHandle CollisionHandlerEvent::get_class_type(void);

441 22 ~CollisionHandlerEvent 0 4 580 45 CollisionHandlerEvent::~CollisionHandlerEvent 0 0 0
52
CollisionHandlerEvent::~CollisionHandlerEvent(void);

442 12 add_collider 0 4 583 38 CollisionHandlerPhysical::add_collider 0 2 169 170 556
/**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 */

/**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 *
 * The indicated DriveInterface will also be updated with the target's new
 * transform each frame.  This method should be used when the target is
 * directly controlled by a DriveInterface.
 */
222
void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target);
void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface);

443 15 remove_collider 0 4 583 41 CollisionHandlerPhysical::remove_collider 0 1 171 92
/**
 * Removes the collider from the list of colliders that this handler knows
 * about.
 */
73
bool CollisionHandlerPhysical::remove_collider(NodePath const &collider);

444 12 has_collider 0 4 583 38 CollisionHandlerPhysical::has_collider 0 1 172 94
/**
 * Returns true if the handler knows about the indicated collider, false
 * otherwise.
 */
76
bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const;

445 15 clear_colliders 0 4 583 41 CollisionHandlerPhysical::clear_colliders 0 1 173 77
/**
 * Completely empties the list of colliders this handler knows about.
 */
53
void CollisionHandlerPhysical::clear_colliders(void);

446 10 set_center 0 4 583 36 CollisionHandlerPhysical::set_center 0 1 174 269
/**
 * Specifies an arbitrary NodePath that the handler is always considered to be
 * facing.  It does not detect collisions with surfaces that appear to be
 * facing away from this NodePath.  This works best when the collision
 * surfaces in question are polygons.
 */
73
inline void CollisionHandlerPhysical::set_center(NodePath const &center);

447 12 clear_center 0 4 583 38 CollisionHandlerPhysical::clear_center 0 1 175 64
/**
 * Clears the center NodePath specified with set_center.
 */
57
inline void CollisionHandlerPhysical::clear_center(void);

448 10 get_center 0 4 583 36 CollisionHandlerPhysical::get_center 0 1 176 114
/**
 * Returns the NodePath specified with set_center, or the empty NodePath if
 * nothing has been specified.
 */
72
inline NodePath const &CollisionHandlerPhysical::get_center(void) const;

449 10 has_center 0 4 583 36 CollisionHandlerPhysical::has_center 0 1 177 95
/**
 * Returns true if a NodePath has been specified with set_center(), false
 * otherwise.
 */
61
inline bool CollisionHandlerPhysical::has_center(void) const;

450 11 has_contact 0 4 583 37 CollisionHandlerPhysical::has_contact 0 1 178 255
/**
 * Did the handler make any contacts with anything on the last collision pass?
 * Depending on how your world is setup, this can be used to tell if the
 * handler is out of the world (i.e.  out of bounds). That is the original use
 * of this call.
 */
62
inline bool CollisionHandlerPhysical::has_contact(void) const;

451 10 __reduce__ 0 4 583 36 CollisionHandlerPhysical::__reduce__ 0 1 179 0
69
PyObject *CollisionHandlerPhysical::__reduce__(PyObject *self) const;

452 12 __setstate__ 0 4 583 38 CollisionHandlerPhysical::__setstate__ 0 1 180 0
100
void CollisionHandlerPhysical::__setstate__(PyObject *self, vector_uchar data, PyObject *nodepaths);

453 14 get_class_type 0 4 583 40 CollisionHandlerPhysical::get_class_type 0 1 181 0
65
static TypeHandle CollisionHandlerPhysical::get_class_type(void);

454 21 CollisionHandlerFloor 0 4 585 44 CollisionHandlerFloor::CollisionHandlerFloor 0 1 182 10
/**
 *
 */
51
CollisionHandlerFloor::CollisionHandlerFloor(void);

455 10 set_offset 0 4 585 33 CollisionHandlerFloor::set_offset 0 1 183 166
/**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
66
inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset);

456 10 get_offset 0 4 585 33 CollisionHandlerFloor::get_offset 0 1 184 169
/**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
65
inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const;

457 9 set_reach 0 4 585 32 CollisionHandlerFloor::set_reach 0 1 185 82
/**
 * Sets the reach to add to (or subtract from) the highest collision point
 */
64
inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach);

458 9 get_reach 0 4 585 32 CollisionHandlerFloor::get_reach 0 1 186 85
/**
 * Returns the reach to add to (or subtract from) the highest collision point
 */
64
inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const;

459 16 set_max_velocity 0 4 585 39 CollisionHandlerFloor::set_max_velocity 0 1 187 199
/**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */
73
inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel);

460 16 get_max_velocity 0 4 585 39 CollisionHandlerFloor::get_max_velocity 0 1 188 160
/**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */
71
inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const;

461 14 get_class_type 0 4 585 37 CollisionHandlerFloor::get_class_type 0 1 189 0
62
static TypeHandle CollisionHandlerFloor::get_class_type(void);

462 22 CollisionHandlerPusher 0 4 586 46 CollisionHandlerPusher::CollisionHandlerPusher 0 1 190 10
/**
 *
 */
53
CollisionHandlerPusher::CollisionHandlerPusher(void);

463 14 set_horizontal 0 4 586 38 CollisionHandlerPusher::set_horizontal 0 1 191 10
/**
 *
 */
62
inline void CollisionHandlerPusher::set_horizontal(bool flag);

464 14 get_horizontal 0 4 586 38 CollisionHandlerPusher::get_horizontal 0 1 192 10
/**
 *
 */
63
inline bool CollisionHandlerPusher::get_horizontal(void) const;

465 14 get_class_type 0 4 586 38 CollisionHandlerPusher::get_class_type 0 1 193 0
63
static TypeHandle CollisionHandlerPusher::get_class_type(void);

466 27 CollisionHandlerFluidPusher 0 4 587 56 CollisionHandlerFluidPusher::CollisionHandlerFluidPusher 0 1 194 10
/**
 *
 */
63
CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void);

467 14 get_class_type 0 4 587 43 CollisionHandlerFluidPusher::get_class_type 0 1 195 0
68
static TypeHandle CollisionHandlerFluidPusher::get_class_type(void);

468 28 ~CollisionHandlerFluidPusher 0 4 587 57 CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher 0 0 0
64
CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher(void);

469 23 CollisionHandlerGravity 0 4 588 48 CollisionHandlerGravity::CollisionHandlerGravity 0 1 196 10
/**
 *
 */
55
CollisionHandlerGravity::CollisionHandlerGravity(void);

470 10 set_offset 0 4 588 35 CollisionHandlerGravity::set_offset 0 1 197 166
/**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
68
inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset);

471 10 get_offset 0 4 588 35 CollisionHandlerGravity::get_offset 0 1 198 169
/**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
67
inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const;

472 9 set_reach 0 4 588 34 CollisionHandlerGravity::set_reach 0 1 199 82
/**
 * Sets the reach to add to (or subtract from) the highest collision point
 */
66
inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach);

473 9 get_reach 0 4 588 34 CollisionHandlerGravity::get_reach 0 1 200 85
/**
 * Returns the reach to add to (or subtract from) the highest collision point
 */
66
inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const;

474 19 get_airborne_height 0 4 588 44 CollisionHandlerGravity::get_airborne_height 0 1 201 238
/**
 * Return the height of the object from the ground.
 *
 * The object might not necessarily be at rest.  Use is_on_ground() if you
 * want to know whether the object is on the ground and at rest.
 *
 * See Also: is_in_outer_space()
 */
76
inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const;

475 12 is_on_ground 0 4 588 37 CollisionHandlerGravity::is_on_ground 0 1 202 33
/**
 * Is the object at rest?
 */
62
inline bool CollisionHandlerGravity::is_on_ground(void) const;

476 19 get_impact_velocity 0 4 588 44 CollisionHandlerGravity::get_impact_velocity 0 1 203 282
/**
 * How hard did the object hit the ground.  This value is set on impact with
 * the ground.  You may want to watch (poll) on is_on_groun() and when that is
 * true, call get_impact_velocity(). Normally I avoid polling, but we are
 * calling is_on_ground() frequently anyway.
 */
76
inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const;

477 18 get_contact_normal 0 4 588 43 CollisionHandlerGravity::get_contact_normal 0 1 204 10
/**
 *
 */
79
inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const;

478 12 add_velocity 0 4 588 37 CollisionHandlerGravity::add_velocity 0 1 205 184
/**
 * Adds the sepcified amount to the current velocity.  This is mostly here
 * allow this common operation to be faster for scripting, but it's also more
 * concise even in cpp.
 */
72
inline void CollisionHandlerGravity::add_velocity(PN_stdfloat velocity);

479 12 set_velocity 0 4 588 37 CollisionHandlerGravity::set_velocity 0 1 206 46
/**
 * Sets the current vertical velocity.
 */
72
inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity);

480 12 get_velocity 0 4 588 37 CollisionHandlerGravity::get_velocity 0 1 207 354
/**
 * Gets the current vertical velocity.
 *
 * Generally, negative values mean the object is in free fall; while postive
 * values mean the object has vertical thrust.
 *
 * A zero value does not necessarily mean the object on the ground, it may
 * also be weightless and/or at the apex of its jump.
 *
 * See Also: is_on_ground() and get_gravity()
 */
69
inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const;

481 11 set_gravity 0 4 588 36 CollisionHandlerGravity::set_gravity 0 1 208 56
/**
 * Sets the linear gravity force (always plumb).
 */
70
inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity);

482 11 get_gravity 0 4 588 36 CollisionHandlerGravity::get_gravity 0 1 209 56
/**
 * Gets the linear gravity force (always plumb).
 */
68
inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const;

483 16 set_max_velocity 0 4 588 41 CollisionHandlerGravity::set_max_velocity 0 1 210 199
/**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */
75
inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel);

484 16 get_max_velocity 0 4 588 41 CollisionHandlerGravity::get_max_velocity 0 1 211 160
/**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */
73
inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const;

485 15 set_legacy_mode 0 4 588 40 CollisionHandlerGravity::set_legacy_mode 0 1 212 229
/**
 * Enables old behavior required by Toontown (Sellbot Factory lava room is
 * good test case, lava and conveyor belt specifically). Behavior is to throw
 * enter/exit events only for floor that the toon is in contact with
 */
71
inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode);

486 15 get_legacy_mode 0 4 588 40 CollisionHandlerGravity::get_legacy_mode 0 1 213 49
/**
 * returns true if legacy mode is enabled
 */
65
inline bool CollisionHandlerGravity::get_legacy_mode(void) const;

487 14 get_class_type 0 4 588 39 CollisionHandlerGravity::get_class_type 0 1 214 0
64
static TypeHandle CollisionHandlerGravity::get_class_type(void);

488 28 CollisionHandlerHighestEvent 0 4 590 58 CollisionHandlerHighestEvent::CollisionHandlerHighestEvent 0 2 215 216 168
/**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */
180
CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void);
inline CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(CollisionHandlerHighestEvent const &) = default;

489 14 get_class_type 0 4 590 44 CollisionHandlerHighestEvent::get_class_type 0 1 217 0
69
static TypeHandle CollisionHandlerHighestEvent::get_class_type(void);

490 29 ~CollisionHandlerHighestEvent 0 4 590 59 CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent 0 0 0
66
CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent(void);

491 21 CollisionHandlerQueue 0 4 591 44 CollisionHandlerQueue::CollisionHandlerQueue 0 2 218 219 10
/**
 *
 */
145
CollisionHandlerQueue::CollisionHandlerQueue(void);
inline CollisionHandlerQueue::CollisionHandlerQueue(CollisionHandlerQueue const &) = default;

492 12 sort_entries 0 4 591 35 CollisionHandlerQueue::sort_entries 0 1 220 257
/**
 * Sorts all the detected collisions front-to-back by
 * from_intersection_point() so that those intersection points closest to the
 * collider's origin (e.g., the center of the CollisionSphere, or the point_a
 * of a CollisionSegment) appear first.
 */
47
void CollisionHandlerQueue::sort_entries(void);

493 13 clear_entries 0 4 591 36 CollisionHandlerQueue::clear_entries 0 1 221 50
/**
 * Removes all the entries from the queue.
 */
48
void CollisionHandlerQueue::clear_entries(void);

494 15 get_num_entries 0 4 591 38 CollisionHandlerQueue::get_num_entries 0 1 222 69
/**
 * Returns the number of CollisionEntries detected last pass.
 */
55
int CollisionHandlerQueue::get_num_entries(void) const;

495 9 get_entry 0 4 591 32 CollisionHandlerQueue::get_entry 0 1 223 61
/**
 * Returns the nth CollisionEntry detected last pass.
 */
62
CollisionEntry *CollisionHandlerQueue::get_entry(int n) const;

496 6 output 0 4 591 29 CollisionHandlerQueue::output 0 1 224 10
/**
 *
 */
60
void CollisionHandlerQueue::output(std::ostream &out) const;

497 5 write 0 4 591 28 CollisionHandlerQueue::write 0 1 225 10
/**
 *
 */
81
void CollisionHandlerQueue::write(std::ostream &out, int indent_level = 0) const;

498 10 __reduce__ 0 4 591 33 CollisionHandlerQueue::__reduce__ 0 1 226 0
66
PyObject *CollisionHandlerQueue::__reduce__(PyObject *self) const;

499 14 get_class_type 0 4 591 37 CollisionHandlerQueue::get_class_type 0 1 227 0
62
static TypeHandle CollisionHandlerQueue::get_class_type(void);

500 22 ~CollisionHandlerQueue 0 4 591 45 CollisionHandlerQueue::~CollisionHandlerQueue 0 0 0
52
CollisionHandlerQueue::~CollisionHandlerQueue(void);

501 15 CollisionSphere 0 4 593 32 CollisionSphere::CollisionSphere 0 2 228 229 114
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid sphere.  Only used when reading from a bam file.
 */

/**
 *
 */
210
inline explicit CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius);
inline explicit CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);

502 10 set_center 0 4 593 27 CollisionSphere::set_center 0 2 230 231 22
/**
 *
 */

/**
 *
 */
149
inline void CollisionSphere::set_center(LPoint3 const &center);
inline void CollisionSphere::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

503 10 get_center 0 4 593 27 CollisionSphere::get_center 0 1 232 10
/**
 *
 */
62
inline LPoint3 const &CollisionSphere::get_center(void) const;

504 10 set_radius 0 4 593 27 CollisionSphere::set_radius 0 1 233 10
/**
 *
 */
60
inline void CollisionSphere::set_radius(PN_stdfloat radius);

505 10 get_radius 0 4 593 27 CollisionSphere::get_radius 0 1 234 10
/**
 *
 */
59
inline PN_stdfloat CollisionSphere::get_radius(void) const;

506 14 get_class_type 0 4 593 31 CollisionSphere::get_class_type 0 1 235 0
56
static TypeHandle CollisionSphere::get_class_type(void);

507 16 ~CollisionSphere 0 4 593 33 CollisionSphere::~CollisionSphere 0 0 0
40
CollisionSphere::~CollisionSphere(void);

508 18 CollisionInvSphere 0 4 594 38 CollisionInvSphere::CollisionInvSphere 0 2 236 237 114
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid sphere.  Only used when reading from a bam file.
 */

/**
 *
 */
222
inline explicit CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius);
inline explicit CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);

509 14 get_class_type 0 4 594 34 CollisionInvSphere::get_class_type 0 1 238 0
59
static TypeHandle CollisionInvSphere::get_class_type(void);

510 19 ~CollisionInvSphere 0 4 594 39 CollisionInvSphere::~CollisionInvSphere 0 0 0
46
CollisionInvSphere::~CollisionInvSphere(void);

511 12 CollisionRay 0 4 595 26 CollisionRay::CollisionRay 0 3 239 240 241 219
/**
 * Creates an invalid ray.  This isn't terribly useful; it's expected that the
 * user will subsequently adjust the ray via set_origin()/set_direction() or
 * set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
274
inline CollisionRay::CollisionRay(void);
inline explicit CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction);
inline explicit CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);

512 10 set_origin 0 4 595 24 CollisionRay::set_origin 0 2 242 243 22
/**
 *
 */

/**
 *
 */
143
inline void CollisionRay::set_origin(LPoint3 const &origin);
inline void CollisionRay::set_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

513 10 get_origin 0 4 595 24 CollisionRay::get_origin 0 1 244 10
/**
 *
 */
59
inline LPoint3 const &CollisionRay::get_origin(void) const;

514 13 set_direction 0 4 595 27 CollisionRay::set_direction 0 2 245 246 22
/**
 *
 */

/**
 *
 */
153
inline void CollisionRay::set_direction(LVector3 const &direction);
inline void CollisionRay::set_direction(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

515 13 get_direction 0 4 595 27 CollisionRay::get_direction 0 1 247 10
/**
 *
 */
63
inline LVector3 const &CollisionRay::get_direction(void) const;

516 13 set_from_lens 0 4 595 27 CollisionRay::set_from_lens 0 2 248 249 591
/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 */

/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */
164
bool CollisionRay::set_from_lens(LensNode *camera, LPoint2 const &point);
inline bool CollisionRay::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);

517 14 get_class_type 0 4 595 28 CollisionRay::get_class_type 0 1 250 0
53
static TypeHandle CollisionRay::get_class_type(void);

518 13 ~CollisionRay 0 4 595 27 CollisionRay::~CollisionRay 0 0 0
34
CollisionRay::~CollisionRay(void);

519 13 CollisionLine 0 4 596 28 CollisionLine::CollisionLine 0 3 251 252 253 221
/**
 * Creates an invalid line.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the line via set_origin()/set_direction()
 * or set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
280
inline CollisionLine::CollisionLine(void);
inline explicit CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction);
inline explicit CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);

520 14 get_class_type 0 4 596 29 CollisionLine::get_class_type 0 1 254 0
54
static TypeHandle CollisionLine::get_class_type(void);

521 14 ~CollisionLine 0 4 596 29 CollisionLine::~CollisionLine 0 0 0
36
CollisionLine::~CollisionLine(void);

522 17 CollisionParabola 0 4 597 36 CollisionParabola::CollisionParabola 0 2 255 256 163
/**
 * Creates an invalid parabola.
 */

/**
 * Creates a parabola with the endpoints between t1 and t2 in the parametric
 * space of the parabola.
 */

/**
 *
 */
163
inline CollisionParabola::CollisionParabola(void);
inline explicit CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2);

523 12 set_parabola 0 4 597 31 CollisionParabola::set_parabola 0 1 257 57
/**
 * Replaces the parabola specified by this solid.
 */
71
inline void CollisionParabola::set_parabola(LParabola const &parabola);

524 12 get_parabola 0 4 597 31 CollisionParabola::get_parabola 0 1 258 56
/**
 * Returns the parabola specified by this solid.
 */
68
inline LParabola const &CollisionParabola::get_parabola(void) const;

525 6 set_t1 0 4 597 25 CollisionParabola::set_t1 0 1 259 54
/**
 * Changes the starting point on the parabola.
 */
54
inline void CollisionParabola::set_t1(PN_stdfloat t1);

526 6 get_t1 0 4 597 25 CollisionParabola::get_t1 0 1 260 54
/**
 * Returns the starting point on the parabola.
 */
57
inline PN_stdfloat CollisionParabola::get_t1(void) const;

527 6 set_t2 0 4 597 25 CollisionParabola::set_t2 0 1 261 52
/**
 * Changes the ending point on the parabola.
 */
54
inline void CollisionParabola::set_t2(PN_stdfloat t2);

528 6 get_t2 0 4 597 25 CollisionParabola::get_t2 0 1 262 52
/**
 * Returns the ending point on the parabola.
 */
57
inline PN_stdfloat CollisionParabola::get_t2(void) const;

529 14 get_class_type 0 4 597 33 CollisionParabola::get_class_type 0 1 263 0
58
static TypeHandle CollisionParabola::get_class_type(void);

530 18 ~CollisionParabola 0 4 597 37 CollisionParabola::~CollisionParabola 0 0 0
44
CollisionParabola::~CollisionParabola(void);

531 16 CollisionSegment 0 4 601 34 CollisionSegment::CollisionSegment 0 3 264 265 266 227
/**
 * Creates an invalid segment.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the segment via
 * set_origin()/set_direction() or set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
285
inline CollisionSegment::CollisionSegment(void);
inline explicit CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db);
inline explicit CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz);

532 11 set_point_a 0 4 601 29 CollisionSegment::set_point_a 0 2 267 268 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionSegment::set_point_a(LPoint3 const &a);
inline void CollisionSegment::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

533 11 get_point_a 0 4 601 29 CollisionSegment::get_point_a 0 1 269 10
/**
 *
 */
64
inline LPoint3 const &CollisionSegment::get_point_a(void) const;

534 11 set_point_b 0 4 601 29 CollisionSegment::set_point_b 0 2 270 271 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionSegment::set_point_b(LPoint3 const &b);
inline void CollisionSegment::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

535 11 get_point_b 0 4 601 29 CollisionSegment::get_point_b 0 1 272 10
/**
 *
 */
64
inline LPoint3 const &CollisionSegment::get_point_b(void) const;

536 13 set_from_lens 0 4 601 31 CollisionSegment::set_from_lens 0 2 273 274 609
/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 */

/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */
172
bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2 const &point);
inline bool CollisionSegment::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);

537 14 get_class_type 0 4 601 32 CollisionSegment::get_class_type 0 1 275 0
57
static TypeHandle CollisionSegment::get_class_type(void);

538 17 ~CollisionSegment 0 4 601 35 CollisionSegment::~CollisionSegment 0 0 0
42
CollisionSegment::~CollisionSegment(void);

275
1 0 0 7 3 603 0 0 0 1 4 this 3 569  
2 0 0 4 7 605 0 0 295 /**
 * Sets the current state of the 'tangible' flag.  Set this true to make the
 * solid tangible, so that a CollisionHandlerPusher will not allow another
 * object to intersect it, or false to make it intangible, so that a
 * CollisionHandlerPusher will ignore it except to throw an event.
 */ 2 4 this 3 604  8 tangible 1 543  
3 0 0 6 8 543 0 0 266 /**
 * Returns whether the solid is considered 'tangible' or not.  An intangible
 * solid has no effect in a CollisionHandlerPusher (except to throw an event);
 * it's useful for defining 'trigger' planes and spheres, that cause an effect
 * when passed through.
 */ 1 4 this 3 569  
4 0 0 4 11 605 0 0 388 /**
 * Records a false normal for this CollisionSolid that will be reported by the
 * collision system with all collisions into it, instead of its actual normal.
 * This is useful as a workaround for the problem of an avatar wanting to
 * stand on a sloping ground; by storing a false normal, the ground appears to
 * be perfectly level, and the avatar does not tend to slide down it.
 */ 2 4 this 3 604  16 effective_normal 1 606  
5 0 0 4 12 605 0 0 71 /**
 * Removes the normal previously set by set_effective_normal().
 */ 1 4 this 3 604  
6 0 0 6 13 543 0 0 98 /**
 * Returns true if a special normal was set by set_effective_normal(), false
 * otherwise.
 */ 1 4 this 3 569  
7 0 0 6 14 606 0 0 145 /**
 * Returns the normal that was set by set_effective_normal().  It is an error
 * to call this unless has_effective_normal() returns true.
 */ 1 4 this 3 569  
8 0 0 4 15 605 0 0 296 /**
 * This is only meaningful for CollisionSolids that will be added to a
 * traverser as colliders.  It is normally true, but if set false, it means
 * that this particular solid does not care about the "effective" normal of
 * other solids it meets, but rather always uses the true normal.
 */ 2 4 this 3 604  24 respect_effective_normal 1 543  
9 0 0 6 16 543 0 0 46 /**
 * See set_respect_effective_normal().
 */ 1 4 this 3 569  
10 0 0 7 18 609 0 0 47 /**
 * Returns the solid's bounding volume.
 */ 1 4 this 3 569  
11 0 0 4 19 605 0 0 47 /**
 * Returns the solid's bounding volume.
 */ 2 4 this 3 604  15 bounding_volume 1 609  
12 0 0 4 22 605 0 0 10 /**
 *
 */ 2 4 this 3 569  3 out 1 610  
13 0 0 4 23 605 0 0 10 /**
 *
 */ 3 4 this 3 569  3 out 1 610  12 indent_level 1 560  
14 0 0 7 24 613 0 0 0 0 
15 0 0 7 26 615 303 0 59 /**
 * Create the Box by Specifying the Diagonal Points
 */ 2 3 min 1 614  3 max 1 614  
16 0 0 7 26 615 303 0 106 /**
 * Create the Box by giving a Center and distances of each of the sides of
 * box from the Center.
 */ 4 6 center 1 614  1 x 1 550  1 y 1 550  1 z 1 550  
17 0 0 6 27 560 0 0 68 /**
 * Returns 8: the number of vertices of a rectangular solid.
 */ 1 4 this 3 616  
18 0 0 7 28 603 0 0 67 /**
 * Returns the nth vertex of the Axis Aligned Bounding Box.
 */ 2 4 this 3 616  1 n 1 560  
19 0 0 7 29 603 0 0 45 /**
 * Returns the nth vertex of the OBB.
 */ 2 4 this 3 616  1 n 1 560  
20 0 0 6 30 560 0 0 65 /**
 * Returns 6: the number of faces of a rectangular solid.
 */ 1 4 this 3 616  
21 0 0 7 31 618 0 0 57 /**
 * Creates the nth face of the rectangular solid.
 */ 2 4 this 3 616  1 n 1 560  
22 0 0 7 32 618 0 0 57 /**
 * Returns the nth face of the rectangular solid.
 */ 2 4 this 3 616  1 n 1 560  
23 0 0 4 33 605 0 0 10 /**
 *
 */ 2 4 this 3 615  6 center 1 614  
24 0 0 4 33 605 0 0 10 /**
 *
 */ 4 4 this 3 615  1 x 1 550  1 y 1 550  1 z 1 550  
25 0 0 6 34 614 0 0 10 /**
 *
 */ 1 4 this 3 616  
26 0 0 6 35 614 0 0 10 /**
 *
 */ 1 4 this 3 616  
27 0 0 6 36 614 0 0 10 /**
 *
 */ 1 4 this 3 616  
28 0 0 7 37 619 0 0 10 /**
 *
 */ 1 4 this 3 616  
29 0 0 7 45 613 0 0 0 0 
30 0 0 7 48 620 312 0 10 /**
 *
 */ 3 1 a 1 614  2 db 1 614  6 radius 1 550  
31 0 0 7 48 620 312 0 10 /**
 *
 */ 7 2 ax 1 550  2 ay 1 550  2 az 1 550  2 bx 1 550  2 by 1 550  2 bz 1 550  6 radius 1 550  
32 0 0 4 49 605 0 0 10 /**
 *
 */ 2 4 this 3 620  1 a 1 614  
33 0 0 4 49 605 0 0 10 /**
 *
 */ 4 4 this 3 620  1 x 1 550  1 y 1 550  1 z 1 550  
34 0 0 6 50 614 0 0 10 /**
 *
 */ 1 4 this 3 621  
35 0 0 4 51 605 0 0 10 /**
 *
 */ 2 4 this 3 620  1 b 1 614  
36 0 0 4 51 605 0 0 10 /**
 *
 */ 4 4 this 3 620  1 x 1 550  1 y 1 550  1 z 1 550  
37 0 0 6 52 614 0 0 10 /**
 *
 */ 1 4 this 3 621  
38 0 0 4 53 605 0 0 10 /**
 *
 */ 2 4 this 3 620  6 radius 1 550  
39 0 0 6 54 550 0 0 10 /**
 *
 */ 1 4 this 3 621  
40 0 0 7 60 613 0 0 0 0 
41 0 0 7 65 625 315 0 0 1 6 param0 0 623  
42 0 0 7 64 613 0 0 0 0 
43 0 0 7 69 571 0 0 10 /**
 *
 */ 1 4 name 1 626  
44 0 0 4 70 605 0 0 98 /**
 * Simultaneously sets both the "from" and "into" CollideMask values to the
 * same thing.
 */ 2 4 this 3 571  4 mask 1 627  
45 0 0 4 71 605 0 0 222 /**
 * Sets the "from" CollideMask.  In order for a collision to be detected from
 * this object into another object, the intersection of this object's "from"
 * mask and the other object's "into" mask must be nonzero.
 */ 2 4 this 3 571  4 mask 1 627  
46 0 0 4 72 605 0 0 222 /**
 * Sets the "into" CollideMask.  In order for a collision to be detected from
 * another object into this object, the intersection of the other object's
 * "from" mask and this object's "into" mask must be nonzero.
 */ 2 4 this 3 571  4 mask 1 627  
47 0 0 7 73 627 0 0 233 /**
 * Returns the current "from" CollideMask.  In order for a collision to be
 * detected from this object into another object, the intersection of this
 * object's "from" mask and the other object's "into" mask must be nonzero.
 */ 1 4 this 3 628  
48 0 0 7 74 627 0 0 233 /**
 * Returns the current "into" CollideMask.  In order for a collision to be
 * detected from another object into this object, the intersection of the
 * other object's "from" mask and this object's "into" mask must be nonzero.
 */ 1 4 this 3 628  
49 0 0 4 80 605 0 0 44 /**
 * Removes all solids from the node.
 */ 1 4 this 3 571  
50 0 0 6 81 630 0 0 10 /**
 *
 */ 1 4 this 3 628  
51 0 0 7 82 569 0 0 10 /**
 *
 */ 2 4 this 3 628  1 n 1 630  
52 0 0 7 84 604 0 0 10 /**
 *
 */ 2 4 this 3 571  1 n 1 630  
53 0 0 4 85 605 0 0 55 /**
 * Replaces the solid with the indicated index.
 */ 3 4 this 3 571  1 n 1 630  5 solid 1 604  
54 0 0 4 86 605 0 0 77 /**
 * Inserts the indicated solid to the node at the indicated position.
 */ 3 4 this 3 571  1 n 1 630  5 solid 1 569  
55 0 0 4 87 605 0 0 110 /**
 * Removes the solid with the indicated index.  This will shift all subsequent
 * indices down by one.
 */ 2 4 this 3 571  1 n 1 630  
56 0 0 6 88 630 0 0 121 /**
 * Adds the indicated solid to the node.  Returns the index of the new solid
 * within the node's list of solids.
 */ 2 4 this 3 571  5 solid 1 569  
57 0 0 6 91 560 0 0 114 /**
 * Returns the collider_sort value that has been set for this particular node.
 * See set_collider_sort().
 */ 1 4 this 3 628  
58 0 0 4 92 605 0 0 594 /**
 * Sets a particular collider_sort value on this node.  This controls the
 * order in which colliders (that is, "from nodes") are grouped together for
 * the collision traversal.
 *
 * If there are 32 or fewer colliders added to any particular
 * CollisionTraverser, then this value has no meaning.  It is only useful if
 * there are many colliders, which may force the CollisionTraverser to make
 * multiple passes through the data; in that case, it may be a useful
 * optimization to group colliders that have similar bounding volumes together
 * (by giving them similar sort values).
 */ 2 4 this 3 571  4 sort 1 560  
59 0 0 7 95 627 0 0 80 /**
 * Returns the default into_collide_mask assigned to new CollisionNodes.
 */ 0 
60 0 0 7 97 613 0 0 0 0 
61 0 0 7 100 634 335 0 0 1 6 param0 0 632  
62 0 0 7 100 634 335 0 10 /**
 *
 */ 1 4 name 1 626  
63 0 0 4 102 605 0 0 370 /**
 * Sets the flag that indicates whether the prev_transform stored on a node
 * (as updated via set_fluid_pos(), etc.) is respected to calculate
 * collisions.  If this is true, certain types of collision tests will be
 * enhanced by the information about objects in motion.  If this is false,
 * objects are always considered to be static.  The default is false.
 */ 2 4 this 3 634  4 flag 1 543  
64 0 0 6 103 543 0 0 162 /**
 * Returns the flag that indicates whether the prev_transform stored on a node
 * is respected to calculate collisions.  See set_respect_prev_transform().
 */ 1 4 this 3 632  
65 0 0 4 105 605 0 0 437 /**
 * Adds a new CollisionNode, representing an object that will be tested for
 * collisions into other objects, along with the handler that will serve each
 * detected collision.  Each CollisionNode may be served by only one handler
 * at a time, but a given handler may serve many CollisionNodes.
 *
 * The handler that serves a particular node may be changed from time to time
 * by calling add_collider() again on the same node.
 */ 3 4 this 3 634  8 collider 1 635  7 handler 1 625  
66 0 0 6 106 543 0 0 263 /**
 * Removes the collider (and its associated handler) from the set of
 * CollisionNodes that will be tested each frame for collisions into other
 * objects.  Returns true if the definition was found and removed, false if it
 * wasn't present to begin with.
 */ 2 4 this 3 634  8 collider 1 635  
67 0 0 6 107 543 0 0 145 /**
 * Returns true if the indicated node is current in the set of nodes that will
 * be tested each frame for collisions into other objects.
 */ 2 4 this 3 632  8 collider 1 635  
68 0 0 6 108 560 0 0 108 /**
 * Returns the number of CollisionNodes that have been added to the traverser
 * via add_collider().
 */ 1 4 this 3 632  
69 0 0 7 109 636 0 0 100 /**
 * Returns the nth CollisionNode that has been added to the traverser via
 * add_collider().
 */ 2 4 this 3 632  1 n 1 560  
70 0 0 7 111 625 315 0 169 /**
 * Returns the handler that is currently assigned to serve the indicated
 * collision node, or NULL if the node is not on the traverser's set of active
 * nodes.
 */ 2 4 this 3 632  8 collider 1 635  
71 0 0 4 112 605 0 0 90 /**
 * Completely empties the set of collision nodes and their associated
 * handlers.
 */ 1 4 this 3 634  
72 0 0 4 115 605 0 0 247 /**
 * Perform the traversal. Begins at the indicated root and detects all
 * collisions with any of its collider objects against nodes at or below the
 * indicated root, calling the appropriate CollisionHandler for each detected
 * collision.
 */ 2 4 this 3 634  4 root 1 635  
73 0 0 4 116 605 0 0 777 /**
 * Uses the indicated CollisionRecorder object to start recording the
 * intersection tests made by each subsequent call to traverse() on this
 * object.  A particular CollisionRecorder object can only record one
 * traverser at a time; if this object has already been assigned to another
 * traverser, that assignment is broken.
 *
 * This is intended to be used in a debugging mode to try to determine what
 * work is being performed by the collision traversal.  Usually, attaching a
 * recorder will impose significant runtime overhead.
 *
 * This does not transfer ownership of the CollisionRecorder pointer;
 * maintenance of that remains the caller's responsibility.  If the
 * CollisionRecorder is destructed, it will cleanly remove itself from the
 * traverser.
 */ 2 4 this 3 634  8 recorder 1 564  
74 0 0 6 117 543 0 0 120 /**
 * Returns true if the CollisionTraverser has a CollisionRecorder object
 * currently assigned, false otherwise.
 */ 1 4 this 3 632  
75 0 0 6 118 564 0 0 99 /**
 * Returns the CollisionRecorder currently assigned, or NULL if no recorder is
 * assigned.
 */ 1 4 this 3 632  
76 0 0 4 119 605 0 0 107 /**
 * Removes the CollisionRecorder from the traverser and restores normal low-
 * overhead operation.
 */ 1 4 this 3 634  
77 0 0 7 126 572 0 0 300 /**
 * This is a high-level function to create a CollisionVisualizer object to
 * render the collision tests performed by this traverser.  The supplied root
 * should be any node in the scene graph; typically, the top node (e.g.
 * render).  The CollisionVisualizer will be attached to this node.
 */ 2 4 this 3 634  4 root 1 635  
78 0 0 4 127 605 0 0 69 /**
 * Undoes the effect of a previous call to show_collisions().
 */ 1 4 this 3 634  
79 0 0 4 128 605 0 0 10 /**
 *
 */ 2 4 this 3 632  3 out 1 610  
80 0 0 4 129 605 0 0 10 /**
 *
 */ 3 4 this 3 632  3 out 1 610  12 indent_level 1 560  
81 0 0 6 130 637 0 0 0 1 4 this 3 632  
82 0 0 4 131 605 0 0 0 2 4 this 3 634  5 state 1 637  
83 0 0 7 132 613 0 0 0 0 
84 0 0 4 124 605 0 0 10 /**
 *
 */ 2 4 this 3 640  3 out 1 610  
85 0 0 7 125 613 0 0 0 0 
86 0 0 7 135 569 0 0 104 /**
 * Returns the CollisionSolid pointer for the particular solid that triggered
 * this collision.
 */ 1 4 this 3 642  
87 0 0 6 136 543 0 0 288 /**
 * Returns true if the "into" solid is, in fact, a CollisionSolid, and its
 * pointer is known (in which case get_into() may be called to retrieve it).
 * If this returns false, the collision was detected into a GeomNode, and
 * there is no CollisionSolid pointer to be retrieved.
 */ 1 4 this 3 642  
88 0 0 7 137 569 0 0 243 /**
 * Returns the CollisionSolid pointer for the particular solid was collided
 * into.  This pointer might be NULL if the collision was into a piece of
 * visible geometry, instead of a normal CollisionSolid collision; see
 * has_into().
 */ 1 4 this 3 642  
89 0 0 7 138 571 0 0 182 /**
 * Returns the node that contains the CollisionSolid that triggered this
 * collision.  This will be a node that has been added to a CollisionTraverser
 * via add_collider().
 */ 1 4 this 3 642  
90 0 0 7 139 572 0 0 254 /**
 * Returns the node that contains the CollisionSolid that was collided into.
 * This returns a PandaNode pointer instead of something more specific,
 * because it might be either a CollisionNode or a GeomNode.
 *
 * Also see get_into_node_path().
 */ 1 4 this 3 642  
91 0 0 7 140 636 0 0 224 /**
 * Returns the NodePath that represents the CollisionNode that contains the
 * CollisionSolid that triggered this collision.  This will be a NodePath that
 * has been added to a CollisionTraverser via add_collider().
 */ 1 4 this 3 642  
92 0 0 7 141 636 0 0 338 /**
 * Returns the NodePath that represents the specific CollisionNode or GeomNode
 * instance that was collided into.  This is the same node returned by
 * get_into_node(), represented as a NodePath; however, it may be more useful
 * because the NodePath can resolve the particular instance of the node, if
 * there is more than one.
 */ 1 4 this 3 642  
93 0 0 4 142 605 0 0 82 /**
 * Sets a time value for this collision relative to other CollisionEntries
 */ 2 4 this 3 592  1 t 1 550  
94 0 0 6 143 550 0 0 83 /**
 * returns time value for this collision relative to other CollisionEntries
 */ 1 4 this 3 642  
95 0 0 6 144 543 0 0 188 /**
 * returns true if this represents an actual collision as opposed to a
 * potential collision, needed for iterative collision resolution where path
 * of collider changes mid-frame
 */ 1 4 this 3 642  
96 0 0 4 145 605 0 0 45 /**
 * prepare for another collision test
 */ 1 4 this 3 592  
97 0 0 6 146 543 0 0 203 /**
 * Returns true if the collision was detected by a CollisionTraverser whose
 * respect_prev_transform flag was set true, meaning we should consider motion
 * significant in evaluating collisions.
 */ 1 4 this 3 642  
98 0 0 4 147 605 0 0 178 /**
 * Stores the point, on the surface of the "into" object, at which a collision
 * is detected.
 *
 * This point is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 592  5 point 1 614  
99 0 0 4 148 605 0 0 171 /**
 * Stores the surface normal of the "into" object at the point of the
 * intersection.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 592  6 normal 1 606  
100 0 0 4 149 605 0 0 352 /**
 * Stores the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).
 *
 * This point is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 592  5 point 1 614  
101 0 0 6 150 543 0 0 174 /**
 * Returns true if the surface point has been specified, false otherwise.  See
 * get_surface_point().  Some types of collisions may not compute the surface
 * point.
 */ 1 4 this 3 642  
102 0 0 6 151 543 0 0 176 /**
 * Returns true if the surface normal has been specified, false otherwise.
 * See get_surface_normal().  Some types of collisions may not compute the
 * surface normal.
 */ 1 4 this 3 642  
103 0 0 6 152 543 0 0 176 /**
 * Returns true if the interior point has been specified, false otherwise.
 * See get_interior_point().  Some types of collisions may not compute the
 * interior point.
 */ 1 4 this 3 642  
104 0 0 4 153 605 0 0 190 /**
 * Stores the position of the "from" object at the instant at which the
 * collision is first detected.
 *
 * This position is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 592  3 pos 1 614  
105 0 0 4 154 605 0 0 154 /**
 * Stores the surface normal of the "into" object at the contact pos.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 592  6 normal 1 606  
106 0 0 6 155 543 0 0 172 /**
 * Returns true if the contact position has been specified, false otherwise.
 * See get_contact_pos().  Some types of collisions may not compute the
 * contact pos.
 */ 1 4 this 3 642  
107 0 0 6 156 543 0 0 176 /**
 * Returns true if the contact normal has been specified, false otherwise.
 * See get_contact_normal().  Some types of collisions may not compute the
 * contact normal.
 */ 1 4 this 3 642  
108 0 0 7 157 603 0 0 330 /**
 * Returns the point, on the surface of the "into" object, at which a
 * collision is detected.  This can be thought of as the first point of
 * intersection.  However the contact point is the actual first point of
 * intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 642  5 space 1 635  
109 0 0 7 158 619 0 0 200 /**
 * Returns the surface normal of the "into" object at the point at which a
 * collision is detected.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 642  5 space 1 635  
110 0 0 7 159 603 0 0 431 /**
 * Returns the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).  It can be thought of as the
 * deepest point of intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 642  5 space 1 635  
111 0 0 6 160 543 0 0 244 /**
 * Simultaneously transforms the surface point, surface normal, and interior
 * point of the collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */ 5 4 this 3 642  5 space 1 635  13 surface_point 1 603  14 surface_normal 1 619  14 interior_point 1 603  
112 0 0 7 161 603 0 0 200 /**
 * Returns the position of the "from" object at the instant that a collision
 * is first detected.
 *
 * The position will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 642  5 space 1 635  
113 0 0 7 162 619 0 0 175 /**
 * Returns the surface normal of the "into" object at the contact position.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 642  5 space 1 635  
114 0 0 6 163 543 0 0 230 /**
 * Simultaneously transforms the contact position and contact normal of the
 * collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */ 4 4 this 3 642  5 space 1 635  11 contact_pos 1 603  14 contact_normal 1 619  
115 0 0 4 164 605 0 0 10 /**
 *
 */ 2 4 this 3 642  3 out 1 610  
116 0 0 4 165 605 0 0 10 /**
 *
 */ 3 4 this 3 642  3 out 1 610  12 indent_level 1 560  
117 0 0 7 178 613 0 0 0 0 
118 0 0 7 181 646 399 0 10 /**
 *
 */ 1 4 copy 1 644  
119 0 0 7 181 646 399 0 10 /**
 *
 */ 1 5 plane 1 647  
120 0 0 7 182 619 0 0 10 /**
 *
 */ 1 4 this 3 644  
121 0 0 6 183 550 0 0 10 /**
 *
 */ 2 4 this 3 644  5 point 1 614  
122 0 0 4 184 605 0 0 10 /**
 *
 */ 2 4 this 3 646  5 plane 1 647  
123 0 0 6 185 647 0 0 10 /**
 *
 */ 1 4 this 3 644  
124 0 0 4 186 605 0 0 57 /**
 * Convenience method to flip the plane in-place.
 */ 1 4 this 3 646  
125 0 0 7 192 613 0 0 0 0 
126 0 0 7 195 648 408 0 144 /**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */ 0 
127 0 0 4 196 605 0 0 47 /**
 * store away a vertex to index against
 */ 2 4 this 3 648  4 vert 1 614  
128 0 0 4 197 605 0 0 42 /**
 * store a triangle for processing
 */ 4 4 this 3 648  6 pointA 1 649  6 pointB 1 649  6 pointC 1 649  
129 0 0 6 198 649 0 0 0 1 4 this 3 650  
130 0 0 6 199 614 0 0 0 2 4 this 3 650  5 index 1 649  
131 0 0 6 201 649 0 0 0 1 4 this 3 650  
132 0 0 7 202 652 0 0 0 2 4 this 3 650  5 index 1 649  
133 0 0 7 207 613 0 0 0 0 
134 0 0 7 210 657 417 0 10 /**
 *
 */ 3 1 a 1 653  1 b 1 653  1 c 1 653  
135 0 0 7 210 657 417 0 10 /**
 *
 */ 4 1 a 1 653  1 b 1 653  1 c 1 653  1 d 1 653  
136 0 0 6 211 630 0 0 66 /**
 * Returns the number of vertices of the CollisionPolygon.
 */ 1 4 this 3 658  
137 0 0 7 212 603 0 0 82 /**
 * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.
 */ 2 4 this 3 658  1 n 1 630  
138 0 0 6 214 543 0 0 167 /**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */ 3 1 a 1 614  1 b 1 614  1 c 1 614  
139 0 0 6 214 543 0 0 167 /**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */ 4 1 a 1 614  1 b 1 614  1 c 1 614  1 d 1 614  
140 0 0 6 214 543 0 0 0 1 6 points 1 637  
141 0 0 6 215 543 0 0 122 /**
 * Returns true if the CollisionPolygon is valid (that is, it has at least
 * three vertices), or false otherwise.
 */ 1 4 this 3 658  
142 0 0 6 216 543 0 0 106 /**
 * Returns true if the CollisionPolygon appears to be concave, or false if it
 * is safely convex.
 */ 1 4 this 3 658  
143 0 0 4 217 605 0 0 0 2 4 this 3 657  6 points 1 637  
144 0 0 7 221 613 0 0 0 0 
145 0 0 7 224 660 441 0 168 /**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */ 0 
146 0 0 7 224 660 441 0 0 1 6 param0 0 661  
147 0 0 4 225 605 0 0 80 /**
 * Removes all of the previously-added in patterns.  See add_in_pattern.
 */ 1 4 this 3 660  
148 0 0 4 226 605 0 0 1586 /**
 * Adds a pattern string to the list of events that will be generated in
 * response to a collision.  The pattern string describes how the event name
 * will be composed.  It is a string that may contain any of the following:
 *
 * %fn  - the name of the "from" object's node %in  - the name of the "into"
 * object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
 * 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
 * into a CollisionNode, 'g' if it is a geom.
 *
 * %(tag)fh - generate event only if "from" node has the indicated net tag.
 * %(tag)fx - generate event only if "from" node does not have the indicated
 * net tag.  %(tag)ih - generate event only if "into" node has the indicated
 * net tag.  %(tag)ix - generate event only if "into" node does not have the
 * indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
 * node.  %(tag)it - the indicated net tag value of the "into" node.
 *
 * Parentheses in the above are literal and should be included in the actual
 * pattern.
 *
 * The event name will be based on the in_pattern string specified here, with
 * all occurrences of the above strings replaced with the corresponding
 * values.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 660  10 in_pattern 1 626  
149 0 0 4 227 605 0 0 189 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_in_pattern() instead.
 */ 2 4 this 3 660  10 in_pattern 1 626  
150 0 0 6 228 560 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 661  
151 0 0 6 229 626 0 0 145 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_in_pattern().
 */ 2 4 this 3 661  1 n 1 560  
152 0 0 4 231 605 0 0 83 /**
 * Removes all of the previously-added in patterns.  See add_again_pattern.
 */ 1 4 this 3 660  
153 0 0 4 232 605 0 0 649 /**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *still* detected.  This
 * event is thrown each consecutive time a collision between two particular
 * nodes is detected, starting with the second time.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 660  13 again_pattern 1 626  
154 0 0 4 233 605 0 0 192 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_again_pattern() instead.
 */ 2 4 this 3 660  13 again_pattern 1 626  
155 0 0 6 234 560 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 661  
156 0 0 6 235 626 0 0 148 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_again_pattern().
 */ 2 4 this 3 661  1 n 1 560  
157 0 0 4 237 605 0 0 81 /**
 * Removes all of the previously-added in patterns.  See add_out_pattern.
 */ 1 4 this 3 660  
158 0 0 4 238 605 0 0 518 /**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *no longer* detected.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 660  11 out_pattern 1 626  
159 0 0 4 239 605 0 0 190 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_out_pattern() instead.
 */ 2 4 this 3 660  11 out_pattern 1 626  
160 0 0 6 240 560 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 661  
161 0 0 6 241 626 0 0 146 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_out_pattern().
 */ 2 4 this 3 661  1 n 1 560  
162 0 0 4 248 605 0 0 541 /**
 * Empties the list of elements that all colliders are known to be colliding
 * with.  No "out" events will be thrown; if the same collision is detected
 * next frame, a new "in" event will be thrown for each collision.
 *
 * This can be called each frame to defeat the persistent "in" event
 * mechanism, which prevents the same "in" event from being thrown repeatedly.
 * However, also see add_again_pattern(), which can be used to set the event
 * that is thrown when a collision is detected for two or more consecutive
 * frames.
 */ 1 4 this 3 660  
163 0 0 4 249 605 0 0 58 /**
 * Same as clear() except "out" events are thrown.
 */ 1 4 this 3 660  
164 0 0 6 250 637 0 0 46 // These help implement Python pickle support. 1 4 this 3 661  
165 0 0 4 251 605 0 0 0 2 4 this 3 660  4 data 1 663  
166 0 0 4 252 605 0 0 63 /**
 * Serializes this object, to implement pickle support.
 */ 2 4 this 3 661  11 destination 1 665  
167 0 0 4 253 605 0 0 104 /**
 * Restores the object state from the given datagram, previously obtained using
 * __getstate__.
 */ 2 4 this 3 660  6 source 1 667  
168 0 0 7 254 613 0 0 0 0 
169 0 0 4 257 605 0 0 180 /**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 */ 3 4 this 3 669  8 collider 1 635  6 target 1 635  
170 0 0 4 257 605 0 0 374 /**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 *
 * The indicated DriveInterface will also be updated with the target's new
 * transform each frame.  This method should be used when the target is
 * directly controlled by a DriveInterface.
 */ 4 4 this 3 669  8 collider 1 635  6 target 1 635  15 drive_interface 1 670  
171 0 0 6 258 543 0 0 92 /**
 * Removes the collider from the list of colliders that this handler knows
 * about.
 */ 2 4 this 3 669  8 collider 1 635  
172 0 0 6 259 543 0 0 94 /**
 * Returns true if the handler knows about the indicated collider, false
 * otherwise.
 */ 2 4 this 3 672  8 collider 1 635  
173 0 0 4 260 605 0 0 77 /**
 * Completely empties the list of colliders this handler knows about.
 */ 1 4 this 3 669  
174 0 0 4 261 605 0 0 269 /**
 * Specifies an arbitrary NodePath that the handler is always considered to be
 * facing.  It does not detect collisions with surfaces that appear to be
 * facing away from this NodePath.  This works best when the collision
 * surfaces in question are polygons.
 */ 2 4 this 3 669  6 center 1 635  
175 0 0 4 262 605 0 0 64 /**
 * Clears the center NodePath specified with set_center.
 */ 1 4 this 3 669  
176 0 0 6 263 635 0 0 114 /**
 * Returns the NodePath specified with set_center, or the empty NodePath if
 * nothing has been specified.
 */ 1 4 this 3 672  
177 0 0 6 264 543 0 0 95 /**
 * Returns true if a NodePath has been specified with set_center(), false
 * otherwise.
 */ 1 4 this 3 672  
178 0 0 6 265 543 0 0 255 /**
 * Did the handler make any contacts with anything on the last collision pass?
 * Depending on how your world is setup, this can be used to tell if the
 * handler is out of the world (i.e.  out of bounds). That is the original use
 * of this call.
 */ 1 4 this 3 672  
179 0 0 6 268 637 0 0 0 1 4 this 3 672  
180 0 0 4 269 605 0 0 0 3 4 this 3 669  4 data 1 663  9 nodepaths 1 637  
181 0 0 7 270 613 0 0 0 0 
182 0 0 7 272 674 441 0 10 /**
 *
 */ 0 
183 0 0 4 273 605 0 0 166 /**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 2 4 this 3 674  6 offset 1 550  
184 0 0 6 274 550 0 0 169 /**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 1 4 this 3 675  
185 0 0 4 275 605 0 0 82 /**
 * Sets the reach to add to (or subtract from) the highest collision point
 */ 2 4 this 3 674  5 reach 1 550  
186 0 0 6 276 550 0 0 85 /**
 * Returns the reach to add to (or subtract from) the highest collision point
 */ 1 4 this 3 675  
187 0 0 4 277 605 0 0 199 /**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */ 2 4 this 3 674  7 max_vel 1 550  
188 0 0 6 278 550 0 0 160 /**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */ 1 4 this 3 675  
189 0 0 7 282 613 0 0 0 0 
190 0 0 7 284 677 441 0 10 /**
 *
 */ 0 
191 0 0 4 285 605 0 0 10 /**
 *
 */ 2 4 this 3 677  4 flag 1 543  
192 0 0 6 286 543 0 0 10 /**
 *
 */ 1 4 this 3 678  
193 0 0 7 288 613 0 0 0 0 
194 0 0 7 290 680 468 0 10 /**
 *
 */ 0 
195 0 0 7 291 613 0 0 0 0 
196 0 0 7 294 681 441 0 10 /**
 *
 */ 0 
197 0 0 4 295 605 0 0 166 /**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 2 4 this 3 681  6 offset 1 550  
198 0 0 6 296 550 0 0 169 /**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 1 4 this 3 682  
199 0 0 4 297 605 0 0 82 /**
 * Sets the reach to add to (or subtract from) the highest collision point
 */ 2 4 this 3 681  5 reach 1 550  
200 0 0 6 298 550 0 0 85 /**
 * Returns the reach to add to (or subtract from) the highest collision point
 */ 1 4 this 3 682  
201 0 0 6 299 550 0 0 238 /**
 * Return the height of the object from the ground.
 *
 * The object might not necessarily be at rest.  Use is_on_ground() if you
 * want to know whether the object is on the ground and at rest.
 *
 * See Also: is_in_outer_space()
 */ 1 4 this 3 682  
202 0 0 6 300 543 0 0 33 /**
 * Is the object at rest?
 */ 1 4 this 3 682  
203 0 0 6 301 550 0 0 282 /**
 * How hard did the object hit the ground.  This value is set on impact with
 * the ground.  You may want to watch (poll) on is_on_groun() and when that is
 * true, call get_impact_velocity(). Normally I avoid polling, but we are
 * calling is_on_ground() frequently anyway.
 */ 1 4 this 3 682  
204 0 0 6 302 606 0 0 10 /**
 *
 */ 1 4 this 3 682  
205 0 0 4 303 605 0 0 184 /**
 * Adds the sepcified amount to the current velocity.  This is mostly here
 * allow this common operation to be faster for scripting, but it's also more
 * concise even in cpp.
 */ 2 4 this 3 681  8 velocity 1 550  
206 0 0 4 304 605 0 0 46 /**
 * Sets the current vertical velocity.
 */ 2 4 this 3 681  8 velocity 1 550  
207 0 0 6 305 550 0 0 354 /**
 * Gets the current vertical velocity.
 *
 * Generally, negative values mean the object is in free fall; while postive
 * values mean the object has vertical thrust.
 *
 * A zero value does not necessarily mean the object on the ground, it may
 * also be weightless and/or at the apex of its jump.
 *
 * See Also: is_on_ground() and get_gravity()
 */ 1 4 this 3 682  
208 0 0 4 306 605 0 0 56 /**
 * Sets the linear gravity force (always plumb).
 */ 2 4 this 3 681  7 gravity 1 550  
209 0 0 6 307 550 0 0 56 /**
 * Gets the linear gravity force (always plumb).
 */ 1 4 this 3 682  
210 0 0 4 308 605 0 0 199 /**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */ 2 4 this 3 681  7 max_vel 1 550  
211 0 0 6 309 550 0 0 160 /**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */ 1 4 this 3 682  
212 0 0 4 310 605 0 0 229 /**
 * Enables old behavior required by Toontown (Sellbot Factory lava room is
 * good test case, lava and conveyor belt specifically). Behavior is to throw
 * enter/exit events only for floor that the toon is in contact with
 */ 2 4 this 3 681  11 legacy_mode 1 543  
213 0 0 6 311 543 0 0 49 /**
 * returns true if legacy mode is enabled
 */ 1 4 this 3 682  
214 0 0 7 322 613 0 0 0 0 
215 0 0 7 324 684 490 0 168 /**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */ 0 
216 0 0 7 324 684 490 0 0 1 6 param0 0 685  
217 0 0 7 325 613 0 0 0 0 
218 0 0 7 328 687 500 0 10 /**
 *
 */ 0 
219 0 0 7 328 687 500 0 0 1 6 param0 0 688  
220 0 0 4 329 605 0 0 257 /**
 * Sorts all the detected collisions front-to-back by
 * from_intersection_point() so that those intersection points closest to the
 * collider's origin (e.g., the center of the CollisionSphere, or the point_a
 * of a CollisionSegment) appear first.
 */ 1 4 this 3 687  
221 0 0 4 330 605 0 0 50 /**
 * Removes all the entries from the queue.
 */ 1 4 this 3 687  
222 0 0 6 331 560 0 0 69 /**
 * Returns the number of CollisionEntries detected last pass.
 */ 1 4 this 3 688  
223 0 0 7 332 592 391 0 61 /**
 * Returns the nth CollisionEntry detected last pass.
 */ 2 4 this 3 688  1 n 1 560  
224 0 0 4 336 605 0 0 10 /**
 *
 */ 2 4 this 3 688  3 out 1 610  
225 0 0 4 337 605 0 0 10 /**
 *
 */ 3 4 this 3 688  3 out 1 610  12 indent_level 1 560  
226 0 0 6 338 637 0 0 0 1 4 this 3 688  
227 0 0 7 339 613 0 0 0 0 
228 0 0 7 342 690 507 0 10 /**
 *
 */ 2 6 center 1 614  6 radius 1 550  
229 0 0 7 342 690 507 0 10 /**
 *
 */ 4 2 cx 1 550  2 cy 1 550  2 cz 1 550  6 radius 1 550  
230 0 0 4 343 605 0 0 10 /**
 *
 */ 2 4 this 3 690  6 center 1 614  
231 0 0 4 343 605 0 0 10 /**
 *
 */ 4 4 this 3 690  1 x 1 550  1 y 1 550  1 z 1 550  
232 0 0 6 344 614 0 0 10 /**
 *
 */ 1 4 this 3 691  
233 0 0 4 345 605 0 0 10 /**
 *
 */ 2 4 this 3 690  6 radius 1 550  
234 0 0 6 346 550 0 0 10 /**
 *
 */ 1 4 this 3 691  
235 0 0 7 349 613 0 0 0 0 
236 0 0 7 352 693 510 0 10 /**
 *
 */ 2 6 center 1 614  6 radius 1 550  
237 0 0 7 352 693 510 0 10 /**
 *
 */ 4 2 cx 1 550  2 cy 1 550  2 cz 1 550  6 radius 1 550  
238 0 0 7 353 613 0 0 0 0 
239 0 0 7 356 694 518 0 183 /**
 * Creates an invalid ray.  This isn't terribly useful; it's expected that the
 * user will subsequently adjust the ray via set_origin()/set_direction() or
 * set_from_lens().
 */ 0 
240 0 0 7 356 694 518 0 10 /**
 *
 */ 2 6 origin 1 614  9 direction 1 606  
241 0 0 7 356 694 518 0 10 /**
 *
 */ 6 2 ox 1 550  2 oy 1 550  2 oz 1 550  2 dx 1 550  2 dy 1 550  2 dz 1 550  
242 0 0 4 357 605 0 0 10 /**
 *
 */ 2 4 this 3 694  6 origin 1 614  
243 0 0 4 357 605 0 0 10 /**
 *
 */ 4 4 this 3 694  1 x 1 550  1 y 1 550  1 z 1 550  
244 0 0 6 358 614 0 0 10 /**
 *
 */ 1 4 this 3 695  
245 0 0 4 360 605 0 0 10 /**
 *
 */ 2 4 this 3 694  9 direction 1 606  
246 0 0 4 360 605 0 0 10 /**
 *
 */ 4 4 this 3 694  1 x 1 550  1 y 1 550  1 z 1 550  
247 0 0 6 361 606 0 0 10 /**
 *
 */ 1 4 this 3 695  
248 0 0 6 363 543 0 0 327 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */ 3 4 this 3 694  6 camera 1 697  5 point 1 699  
249 0 0 6 363 543 0 0 262 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 */ 4 4 this 3 694  6 camera 1 697  2 px 1 550  2 py 1 550  
250 0 0 7 364 613 0 0 0 0 
251 0 0 7 367 703 521 0 185 /**
 * Creates an invalid line.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the line via set_origin()/set_direction()
 * or set_from_lens().
 */ 0 
252 0 0 7 367 703 521 0 10 /**
 *
 */ 2 6 origin 1 614  9 direction 1 606  
253 0 0 7 367 703 521 0 10 /**
 *
 */ 6 2 ox 1 550  2 oy 1 550  2 oz 1 550  2 dx 1 550  2 dy 1 550  2 dz 1 550  
254 0 0 7 368 613 0 0 0 0 
255 0 0 7 371 704 530 0 39 /**
 * Creates an invalid parabola.
 */ 0 
256 0 0 7 371 704 530 0 110 /**
 * Creates a parabola with the endpoints between t1 and t2 in the parametric
 * space of the parabola.
 */ 3 8 parabola 1 705  2 t1 1 550  2 t2 1 550  
257 0 0 4 372 605 0 0 57 /**
 * Replaces the parabola specified by this solid.
 */ 2 4 this 3 704  8 parabola 1 705  
258 0 0 6 373 705 0 0 56 /**
 * Returns the parabola specified by this solid.
 */ 1 4 this 3 706  
259 0 0 4 374 605 0 0 54 /**
 * Changes the starting point on the parabola.
 */ 2 4 this 3 704  2 t1 1 550  
260 0 0 6 375 550 0 0 54 /**
 * Returns the starting point on the parabola.
 */ 1 4 this 3 706  
261 0 0 4 376 605 0 0 52 /**
 * Changes the ending point on the parabola.
 */ 2 4 this 3 704  2 t2 1 550  
262 0 0 6 377 550 0 0 52 /**
 * Returns the ending point on the parabola.
 */ 1 4 this 3 706  
263 0 0 7 384 613 0 0 0 0 
264 0 0 7 387 708 538 0 191 /**
 * Creates an invalid segment.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the segment via
 * set_origin()/set_direction() or set_from_lens().
 */ 0 
265 0 0 7 387 708 538 0 10 /**
 *
 */ 2 1 a 1 614  2 db 1 614  
266 0 0 7 387 708 538 0 10 /**
 *
 */ 6 2 ax 1 550  2 ay 1 550  2 az 1 550  2 bx 1 550  2 by 1 550  2 bz 1 550  
267 0 0 4 388 605 0 0 10 /**
 *
 */ 2 4 this 3 708  1 a 1 614  
268 0 0 4 388 605 0 0 10 /**
 *
 */ 4 4 this 3 708  1 x 1 550  1 y 1 550  1 z 1 550  
269 0 0 6 389 614 0 0 10 /**
 *
 */ 1 4 this 3 709  
270 0 0 4 390 605 0 0 10 /**
 *
 */ 2 4 this 3 708  1 b 1 614  
271 0 0 4 390 605 0 0 10 /**
 *
 */ 4 4 this 3 708  1 x 1 550  1 y 1 550  1 z 1 550  
272 0 0 6 391 614 0 0 10 /**
 *
 */ 1 4 this 3 709  
273 0 0 6 392 543 0 0 336 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */ 3 4 this 3 708  6 camera 1 697  5 point 1 699  
274 0 0 6 392 543 0 0 271 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 */ 4 4 this 3 708  6 camera 1 697  2 px 1 550  2 py 1 550  
275 0 0 7 395 613 0 0 0 0 
172
539 14 CollisionSolid 0 75777 14 CollisionSolid 14 CollisionSolid 0 0 0 0 0 4 711 712 713 714 14 276 277 278 279 280 281 282 283 284 285 286 287 288 289 0 0 1 0 540 0 0 0 0 457
/**
 * The abstract base class for all things that can collide with other things
 * in the world, and all the things they can collide with (except geometry).
 *
 * This class and its derivatives really work very similarly to the way
 * BoundingVolume and all of its derivatives work.  There's a different
 * subclass for each basic shape of solid, and double-dispatch function calls
 * handle the subset of the N*N intersection tests that we care about.
 */

540 17 CopyOnWriteObject 0 2048 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 169
/**
 * This base class provides basic reference counting, but also can be used
 * with a CopyOnWritePointer to provide get_read_pointer() and
 * get_write_pointer().
 */

541 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 542 0 0 0 0 0 0 0 0 0 0

542 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

543 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

544 32 ConstPointerTo< BoundingVolume > 0 2048 32 ConstPointerTo< BoundingVolume > 32 ConstPointerTo< BoundingVolume > 0 0 0 0 0 0 0 0 0 0 0 0 0

545 12 CollisionBox 0 141313 12 CollisionBox 12 CollisionBox 0 0 0 1 290 303 4 715 716 717 718 12 291 292 293 294 295 296 297 298 299 300 301 302 0 0 1 0 539 0 0 0 0 47
/**
 * A cuboid collision volume or object.
 */

546 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 541 0 0 0 0 0 0 0 0 0 0

547 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 548 0 0 0 0 0 0 0 0 0 0

548 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

549 16 CollisionCapsule 0 141313 16 CollisionCapsule 16 CollisionCapsule 0 0 0 1 304 312 3 719 720 721 7 305 306 307 308 309 310 311 0 0 1 0 539 0 0 0 0 201
/**
 * This implements a solid consisting of a cylinder with hemispherical endcaps,
 * also known as a capsule or a spherocylinder.
 *
 * This shape was previously erroneously called CollisionTube.
 */

550 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 551 0 0 0 0 0 0 0 0 0 0

551 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

552 16 CollisionHandler 0 141313 16 CollisionHandler 16 CollisionHandler 0 0 0 1 314 315 0 1 313 0 0 1 0 553 0 0 0 0 262
/**
 * The abstract interface to a number of classes that decide what to do when a
 * collision is detected.  One of these must be assigned to the
 * CollisionTraverser that is processing collisions in order to specify how to
 * dispatch detected collisions.
 */

553 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

554 13 CollisionNode 0 75777 13 CollisionNode 13 CollisionNode 0 0 0 1 316 0 5 722 723 724 725 726 17 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 1 772 0 1 0 555 0 0 0 0 261
/**
 * A node in the scene graph that can hold any number of CollisionSolids.
 * This may either represent a bit of static geometry in the scene that things
 * will collide with, or an animated object twirling around in the world and
 * running into things.
 */

555 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

556 11 CollideMask 0 2105344 11 CollideMask 11 CollideMask 0 0 557 0 0 0 0 0 0 0 0 0 0

557 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 558 0 0 0 0 0 0 0 0 0 0

558 23 BitMask< uint32_t, 32 > 0 2048 23 BitMask< uint32_t, 32 > 23 BitMask< uint32_t, 32 > 0 0 0 0 0 0 0 0 0 0 0 0 0

559 32 ConstPointerTo< CollisionSolid > 0 2048 32 ConstPointerTo< CollisionSolid > 32 ConstPointerTo< CollisionSolid > 0 0 0 0 0 0 0 0 0 0 0 0 0

560 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

561 18 CollisionTraverser 0 26625 18 CollisionTraverser 18 CollisionTraverser 0 0 0 1 334 335 3 727 728 729 21 336 337 338 339 340 341 342 343 344 345 346 347 348 349 352 353 354 355 356 357 358 1 773 0 1 0 562 0 0 0 0 467
/**
 * This class manages the traversal through the scene graph to detect
 * collisions.  It holds ownership of a number of collider objects, each of
 * which is a CollisionNode and an associated CollisionHandler.
 *
 * When traverse() is called, it begins at the indicated root and detects all
 * collisions with any of its collider objects against nodes at or below the
 * indicated root, calling the appropriate CollisionHandler for each detected
 * collision.
 */

562 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

563 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762
/**
 * NodePath is the fundamental system for disambiguating instances, and also
 * provides a higher-level interface for manipulating the scene graph.
 *
 * A NodePath is a list of connected nodes from the root of the graph to any
 * sub-node.  Each NodePath therefore uniquely describes one instance of a
 * node.
 *
 * NodePaths themselves are lightweight objects that may easily be copied and
 * passed by value.  Their data is stored as a series of NodePathComponents
 * that are stored on the nodes.  Holding a NodePath will keep a reference
 * count to all the nodes in the path.  However, if any node in the path is
 * removed or reparented (perhaps through a different NodePath), the NodePath
 * will automatically be updated to reflect the changes.
 */

564 19 CollisionRecorder * 0 8576 19 CollisionRecorder * 19 CollisionRecorder * 0 0 565 0 0 0 0 0 0 0 0 0 0

565 17 CollisionRecorder 0 75777 17 CollisionRecorder 17 CollisionRecorder 0 0 0 0 0 0 2 350 351 0 0 1 0 566 0 0 0 0 206
/**
 * This class is used to help debug the work the collisions system is doing.
 * It is a virtual base class that just provides an interface for recording
 * collisions tested and detected each frame.
 */

566 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file):
 * @code
 * public:
 *   static TypeHandle get_class_type() {
 *     return _type_handle;
 *   }
 *   static void init_type() {
 *     <<<BaseClassOne>>>::init_type();
 *     <<<BaseClassTwo>>>::init_type();
 *     <<<BaseClassN>>>::init_type();
 *     register_type(_type_handle, "<<<ThisClassStringName>>>",
 *                   <<<BaseClassOne>>>::get_class_type(),
 *                   <<<BaseClassTwo>>>::get_class_type(),
 *                   <<<BaseClassN>>>::get_class_type());
 *   }
 *   virtual TypeHandle get_type() const {
 *     return get_class_type();
 *   }
 *   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private:
 *   static TypeHandle _type_handle;
 * @endcode
 *
 * @par In the class .cxx file:
 * @code
 * TypeHandle <<<ThisClassStringName>>>::_type_handle;
 * @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file:
 * @code
 * ConfigureFn(config_<<<PackageName>>>) {
 *   <<<ClassOne>>>::init_type();
 *   <<<ClassTwo>>>::init_type();
 *   <<<ClassN>>>::init_type();
 * }
 * @endcode
 */

567 14 CollisionEntry 0 141313 14 CollisionEntry 14 CollisionEntry 0 0 0 0 391 8 730 731 732 733 734 735 736 737 32 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 0 0 1 0 568 0 0 0 0 437
/**
 * Defines a single collision event.  One of these is created for each
 * collision detected by a CollisionTraverser, to be dealt with by the
 * CollisionHandler.
 *
 * A CollisionEntry provides slots for a number of data values (such as
 * intersection point and normal) that might or might not be known for each
 * collision.  It is up to the handler to determine what information is known
 * and to do the right thing with it.
 */

568 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

569 22 CollisionSolid const * 0 8576 22 CollisionSolid const * 22 CollisionSolid const * 0 0 570 0 0 0 0 0 0 0 0 0 0

570 20 CollisionSolid const 0 8832 20 CollisionSolid const 20 CollisionSolid const 0 0 539 0 0 0 0 0 0 0 0 0 0

571 15 CollisionNode * 0 8576 15 CollisionNode * 15 CollisionNode * 0 0 554 0 0 0 0 0 0 0 0 0 0

572 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 555 0 0 0 0 0 0 0 0 0 0

573 14 CollisionPlane 0 141313 14 CollisionPlane 14 CollisionPlane 0 0 0 1 392 399 2 738 739 6 393 394 395 396 397 398 0 0 1 0 539 0 0 0 0 10
/**
 *
 */

574 12 LPlane const 0 8832 12 LPlane const 12 LPlane const 0 0 575 0 0 0 0 0 0 0 0 0 0

575 6 LPlane 0 2105344 6 LPlane 6 LPlane 0 0 576 0 0 0 0 0 0 0 0 0 0

576 7 LPlanef 0 2048 7 LPlanef 7 LPlanef 0 0 0 0 0 0 0 0 0 0 0 0 120
/**
 * An abstract mathematical description of a plane.  A plane is defined by the
 * equation Ax + By + Cz + D = 0.
 */

577 18 CollisionFloorMesh 0 141313 18 CollisionFloorMesh 18 CollisionFloorMesh 0 0 0 1 400 408 2 740 741 7 401 402 403 404 405 406 407 2 774 775 0 1 0 539 0 0 0 0 124
/**
 * This object represents a solid made entirely of triangles, which will only
 * be tested again z axis aligned rays
 */

578 8 LPoint3i 0 2048 8 LPoint3i 8 LPoint3i 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

579 16 CollisionPolygon 0 141313 16 CollisionPolygon 16 CollisionPolygon 0 0 0 1 409 417 3 742 743 744 7 410 411 412 413 414 415 416 1 776 0 1 0 573 0 0 0 0 10
/**
 *
 */

580 21 CollisionHandlerEvent 0 141313 21 CollisionHandlerEvent 21 CollisionHandlerEvent 0 0 0 1 418 441 3 745 746 747 22 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 3 777 778 779 0 1 0 552 0 0 0 0 296
/**
 * A specialized kind of CollisionHandler that throws an event for each
 * collision detected.  The event thrown may be based on the name of the
 * moving object or the struck object, or both.  The first parameter of the
 * event will be a pointer to the CollisionEntry that triggered it.
 */

581 6 string 0 2105344 11 std::string 11 std::string 0 0 582 0 0 0 0 0 0 0 0 0 0

582 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

583 24 CollisionHandlerPhysical 0 75777 24 CollisionHandlerPhysical 24 CollisionHandlerPhysical 0 0 0 0 441 1 748 12 442 443 444 445 446 447 448 449 450 451 452 453 0 0 1 0 580 0 0 0 0 209
/**
 * The abstract base class for a number of CollisionHandlers that have some
 * physical effect on their moving bodies: they need to update the nodes'
 * positions based on the effects of the collision.
 */

584 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 563 0 0 0 0 0 0 0 0 0 0

585 21 CollisionHandlerFloor 0 75777 21 CollisionHandlerFloor 21 CollisionHandlerFloor 0 0 0 1 454 441 3 749 750 751 7 455 456 457 458 459 460 461 0 0 1 0 583 0 0 0 0 294
/**
 * A specialized kind of CollisionHandler that sets the Z height of the
 * collider to a fixed linear offset from the highest detected collision point
 * each frame.  It's intended to implement walking around on a floor of
 * varying height by casting a ray down from the avatar's head.
 */

586 22 CollisionHandlerPusher 0 75777 22 CollisionHandlerPusher 22 CollisionHandlerPusher 0 0 0 1 462 441 1 752 3 463 464 465 0 0 1 0 583 0 0 0 0 197
/**
 * A specialized kind of CollisionHandler that simply pushes back on things
 * that attempt to move into solid walls.  This is the simplest kind of "real-
 * world" collisions you can have.
 */

587 27 CollisionHandlerFluidPusher 0 141313 27 CollisionHandlerFluidPusher 27 CollisionHandlerFluidPusher 0 0 0 1 466 468 0 1 467 0 0 1 0 586 0 0 0 0 139
/**
 * A CollisionHandlerPusher that makes use of timing and spatial information
 * from fluid collisions to improve collision response
 */

588 23 CollisionHandlerGravity 0 75777 23 CollisionHandlerGravity 23 CollisionHandlerGravity 0 0 0 1 469 441 9 753 754 755 756 757 758 759 760 761 18 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 0 0 1 0 583 0 0 0 0 294
/**
 * A specialized kind of CollisionHandler that sets the Z height of the
 * collider to a fixed linear offset from the highest detected collision point
 * each frame.  It's intended to implement walking around on a floor of
 * varying height by casting a ray down from the avatar's head.
 */

589 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 547 0 0 0 0 0 0 0 0 0 0

590 28 CollisionHandlerHighestEvent 0 141313 28 CollisionHandlerHighestEvent 28 CollisionHandlerHighestEvent 0 0 0 1 488 490 0 1 489 0 0 1 0 580 0 0 0 0 296
/**
 * A specialized kind of CollisionHandler that throws an event for each
 * collision detected.  The event thrown may be based on the name of the
 * moving object or the struck object, or both.  The first parameter of the
 * event will be a pointer to the CollisionEntry that triggered it.
 */

591 21 CollisionHandlerQueue 0 141313 21 CollisionHandlerQueue 21 CollisionHandlerQueue 0 0 0 1 491 500 1 762 8 492 493 494 495 496 497 498 499 1 780 0 1 0 552 0 0 0 0 313
/**
 * A special kind of CollisionHandler that does nothing except remember the
 * CollisionEntries detected the last pass.  This set of CollisionEntries may
 * then be queried by the calling function.  It's primarily useful when a
 * simple intersection test is being made, e.g.  for picking from the window.
 */

592 16 CollisionEntry * 0 8576 16 CollisionEntry * 16 CollisionEntry * 0 0 567 0 0 0 0 0 0 0 0 0 0

593 15 CollisionSphere 0 141313 15 CollisionSphere 15 CollisionSphere 0 0 0 1 501 507 2 763 764 5 502 503 504 505 506 0 0 1 0 539 0 0 0 0 50
/**
 * A spherical collision volume or object.
 */

594 18 CollisionInvSphere 0 141313 18 CollisionInvSphere 18 CollisionInvSphere 0 0 0 1 508 510 0 1 509 0 0 1 0 593 0 0 0 0 272
/**
 * An inverted sphere: this is a sphere whose collision surface is the inside
 * surface of the sphere.  Everything outside the sphere is solid matter;
 * everything inside is empty space.  Useful for constraining objects to
 * remain within a spherical perimeter.
 */

595 12 CollisionRay 0 141313 12 CollisionRay 12 CollisionRay 0 0 0 1 511 518 2 765 766 6 512 513 514 515 516 517 0 0 1 0 539 0 0 0 0 220
/**
 * An infinite ray, with a specific origin and direction.  It begins at its
 * origin and continues in one direction to infinity, and it has no radius.
 * Useful for picking from a window, or for gravity effects.
 */

596 13 CollisionLine 0 141313 13 CollisionLine 13 CollisionLine 0 0 0 1 519 521 0 1 520 0 0 1 0 595 0 0 0 0 131
/**
 * An infinite line, similar to a CollisionRay, except that it extends in both
 * directions.  It is, however, directional.
 */

597 17 CollisionParabola 0 141313 17 CollisionParabola 17 CollisionParabola 0 0 0 1 522 530 3 767 768 769 7 523 524 525 526 527 528 529 0 0 1 0 539 0 0 0 0 308
/**
 * This defines a parabolic arc, or subset of an arc, similar to the path of a
 * projectile or falling object.  It is finite, having a specific beginning
 * and end, but it is infinitely thin.
 *
 * Think of it as a wire bending from point t1 to point t2 along the path of a
 * pre-defined parabola.
 */

598 15 LParabola const 0 8832 15 LParabola const 15 LParabola const 0 0 599 0 0 0 0 0 0 0 0 0 0

599 9 LParabola 0 2105344 9 LParabola 9 LParabola 0 0 600 0 0 0 0 0 0 0 0 0 0

600 10 LParabolaf 0 2048 10 LParabolaf 10 LParabolaf 0 0 0 0 0 0 0 0 0 0 0 0 200
/**
 * An abstract mathematical description of a parabola, particularly useful for
 * describing arcs of projectiles.
 *
 * The parabolic equation, given parametrically here, is P = At^2 + Bt + C.
 */

601 16 CollisionSegment 0 141313 16 CollisionSegment 16 CollisionSegment 0 0 0 1 531 538 2 770 771 6 532 533 534 535 536 537 0 0 1 0 539 0 0 0 0 371
/**
 * A finite line segment, with two specific endpoints but no thickness.  It's
 * similar to a CollisionRay, except it does not continue to infinity.
 *
 * It does have an ordering, from point A to point B. If more than a single
 * point of the segment is intersecting a solid, the reported intersection
 * point is generally the closest on the segment to point A.
 */

602 13 CollisionTube 0 2105345 13 CollisionTube 13 CollisionTube 0 0 549 0 0 0 0 0 0 0 0 0 0

603 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 541 0 0 0 0 0 0 0 0 0 0

604 16 CollisionSolid * 0 8576 16 CollisionSolid * 16 CollisionSolid * 0 0 539 0 0 0 0 0 0 0 0 0 0

605 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

606 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 589 0 0 0 0 0 0 0 0 0 0

607 20 BoundingVolume const 0 8832 20 BoundingVolume const 20 BoundingVolume const 0 0 608 0 0 0 0 0 0 0 0 0 0

608 14 BoundingVolume 0 2048 14 BoundingVolume 14 BoundingVolume 0 0 0 0 0 0 0 0 0 0 0 0 330
/**
 * This is an abstract class for any volume in any sense which can be said to
 * define the locality of reference of a node in a graph, along with all of
 * its descendants.  It is not necessarily a geometric volume (although see
 * GeometricBoundingVolume); this is simply an abstract interface for bounds
 * of any sort.
 */

609 22 BoundingVolume const * 0 8576 22 BoundingVolume const * 22 BoundingVolume const * 0 0 607 0 0 0 0 0 0 0 0 0 0

610 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 611 0 0 0 0 0 0 0 0 0 0

611 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

612 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

613 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 612 0 0 0 0 0 0 0 0 0 0

614 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 546 0 0 0 0 0 0 0 0 0 0

615 14 CollisionBox * 0 8576 14 CollisionBox * 14 CollisionBox * 0 0 545 0 0 0 0 0 0 0 0 0 0

616 20 CollisionBox const * 0 8576 20 CollisionBox const * 20 CollisionBox const * 0 0 617 0 0 0 0 0 0 0 0 0 0

617 18 CollisionBox const 0 8832 18 CollisionBox const 18 CollisionBox const 0 0 545 0 0 0 0 0 0 0 0 0 0

618 8 LPlane * 0 8576 8 LPlane * 8 LPlane * 0 0 575 0 0 0 0 0 0 0 0 0 0

619 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 547 0 0 0 0 0 0 0 0 0 0

620 18 CollisionCapsule * 0 8576 18 CollisionCapsule * 18 CollisionCapsule * 0 0 549 0 0 0 0 0 0 0 0 0 0

621 24 CollisionCapsule const * 0 8576 24 CollisionCapsule const * 24 CollisionCapsule const * 0 0 622 0 0 0 0 0 0 0 0 0 0

622 22 CollisionCapsule const 0 8832 22 CollisionCapsule const 22 CollisionCapsule const 0 0 549 0 0 0 0 0 0 0 0 0 0

623 24 CollisionHandler const * 0 8576 24 CollisionHandler const * 24 CollisionHandler const * 0 0 624 0 0 0 0 0 0 0 0 0 0

624 22 CollisionHandler const 0 8832 22 CollisionHandler const 22 CollisionHandler const 0 0 552 0 0 0 0 0 0 0 0 0 0

625 18 CollisionHandler * 0 8576 18 CollisionHandler * 18 CollisionHandler * 0 0 552 0 0 0 0 0 0 0 0 0 0

626 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

627 13 CollideMask * 0 8576 13 CollideMask * 13 CollideMask * 0 0 556 0 0 0 0 0 0 0 0 0 0

628 21 CollisionNode const * 0 8576 21 CollisionNode const * 21 CollisionNode const * 0 0 629 0 0 0 0 0 0 0 0 0 0

629 19 CollisionNode const 0 8832 19 CollisionNode const 19 CollisionNode const 0 0 554 0 0 0 0 0 0 0 0 0 0

630 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 631 0 0 0 0 0 0 0 0 0 0

631 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

632 26 CollisionTraverser const * 0 8576 26 CollisionTraverser const * 26 CollisionTraverser const * 0 0 633 0 0 0 0 0 0 0 0 0 0

633 24 CollisionTraverser const 0 8832 24 CollisionTraverser const 24 CollisionTraverser const 0 0 561 0 0 0 0 0 0 0 0 0 0

634 20 CollisionTraverser * 0 8576 20 CollisionTraverser * 20 CollisionTraverser * 0 0 561 0 0 0 0 0 0 0 0 0 0

635 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 584 0 0 0 0 0 0 0 0 0 0

636 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 563 0 0 0 0 0 0 0 0 0 0

637 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 638 0 0 0 0 0 0 0 0 0 0

638 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 639 0 0 0 0 0 0 0 0 0 0

639 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

640 25 CollisionRecorder const * 0 8576 25 CollisionRecorder const * 25 CollisionRecorder const * 0 0 641 0 0 0 0 0 0 0 0 0 0

641 23 CollisionRecorder const 0 8832 23 CollisionRecorder const 23 CollisionRecorder const 0 0 565 0 0 0 0 0 0 0 0 0 0

642 22 CollisionEntry const * 0 8576 22 CollisionEntry const * 22 CollisionEntry const * 0 0 643 0 0 0 0 0 0 0 0 0 0

643 20 CollisionEntry const 0 8832 20 CollisionEntry const 20 CollisionEntry const 0 0 567 0 0 0 0 0 0 0 0 0 0

644 22 CollisionPlane const * 0 8576 22 CollisionPlane const * 22 CollisionPlane const * 0 0 645 0 0 0 0 0 0 0 0 0 0

645 20 CollisionPlane const 0 8832 20 CollisionPlane const 20 CollisionPlane const 0 0 573 0 0 0 0 0 0 0 0 0 0

646 16 CollisionPlane * 0 8576 16 CollisionPlane * 16 CollisionPlane * 0 0 573 0 0 0 0 0 0 0 0 0 0

647 14 LPlane const * 0 8576 14 LPlane const * 14 LPlane const * 0 0 574 0 0 0 0 0 0 0 0 0 0

648 20 CollisionFloorMesh * 0 8576 20 CollisionFloorMesh * 20 CollisionFloorMesh * 0 0 577 0 0 0 0 0 0 0 0 0 0

649 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

650 26 CollisionFloorMesh const * 0 8576 26 CollisionFloorMesh const * 26 CollisionFloorMesh const * 0 0 651 0 0 0 0 0 0 0 0 0 0

651 24 CollisionFloorMesh const 0 8832 24 CollisionFloorMesh const 24 CollisionFloorMesh const 0 0 577 0 0 0 0 0 0 0 0 0 0

652 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 578 0 0 0 0 0 0 0 0 0 0

653 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 654 0 0 0 0 0 0 0 0 0 0

654 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 655 0 0 0 0 0 0 0 0 0 0

655 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 656 0 0 0 0 0 0 0 0 0 0

656 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

657 18 CollisionPolygon * 0 8576 18 CollisionPolygon * 18 CollisionPolygon * 0 0 579 0 0 0 0 0 0 0 0 0 0

658 24 CollisionPolygon const * 0 8576 24 CollisionPolygon const * 24 CollisionPolygon const * 0 0 659 0 0 0 0 0 0 0 0 0 0

659 22 CollisionPolygon const 0 8832 22 CollisionPolygon const 22 CollisionPolygon const 0 0 579 0 0 0 0 0 0 0 0 0 0

660 23 CollisionHandlerEvent * 0 8576 23 CollisionHandlerEvent * 23 CollisionHandlerEvent * 0 0 580 0 0 0 0 0 0 0 0 0 0

661 29 CollisionHandlerEvent const * 0 8576 29 CollisionHandlerEvent const * 29 CollisionHandlerEvent const * 0 0 662 0 0 0 0 0 0 0 0 0 0

662 27 CollisionHandlerEvent const 0 8832 27 CollisionHandlerEvent const 27 CollisionHandlerEvent const 0 0 580 0 0 0 0 0 0 0 0 0 0

663 12 vector_uchar 0 2105344 12 vector_uchar 12 vector_uchar 0 0 664 0 0 0 0 0 0 0 0 0 0

664 24 pvector< unsigned char > 0 2048 24 pvector< unsigned char > 24 pvector< unsigned char > 0 0 0 0 0 0 0 0 0 0 0 0 0

665 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 666 0 0 0 0 0 0 0 0 0 0

666 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

667 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 668 0 0 0 0 0 0 0 0 0 0

668 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

669 26 CollisionHandlerPhysical * 0 8576 26 CollisionHandlerPhysical * 26 CollisionHandlerPhysical * 0 0 583 0 0 0 0 0 0 0 0 0 0

670 16 DriveInterface * 0 8576 16 DriveInterface * 16 DriveInterface * 0 0 671 0 0 0 0 0 0 0 0 0 0

671 14 DriveInterface 0 2048 14 DriveInterface 14 DriveInterface 0 0 0 0 0 0 0 0 0 0 0 0 191
/**
 * This is a TFormer, similar to Trackball, that moves around a transform
 * matrix in response to mouse input.  The basic motion is on a horizontal
 * plane, as if driving a vehicle.
 */

672 32 CollisionHandlerPhysical const * 0 8576 32 CollisionHandlerPhysical const * 32 CollisionHandlerPhysical const * 0 0 673 0 0 0 0 0 0 0 0 0 0

673 30 CollisionHandlerPhysical const 0 8832 30 CollisionHandlerPhysical const 30 CollisionHandlerPhysical const 0 0 583 0 0 0 0 0 0 0 0 0 0

674 23 CollisionHandlerFloor * 0 8576 23 CollisionHandlerFloor * 23 CollisionHandlerFloor * 0 0 585 0 0 0 0 0 0 0 0 0 0

675 29 CollisionHandlerFloor const * 0 8576 29 CollisionHandlerFloor const * 29 CollisionHandlerFloor const * 0 0 676 0 0 0 0 0 0 0 0 0 0

676 27 CollisionHandlerFloor const 0 8832 27 CollisionHandlerFloor const 27 CollisionHandlerFloor const 0 0 585 0 0 0 0 0 0 0 0 0 0

677 24 CollisionHandlerPusher * 0 8576 24 CollisionHandlerPusher * 24 CollisionHandlerPusher * 0 0 586 0 0 0 0 0 0 0 0 0 0

678 30 CollisionHandlerPusher const * 0 8576 30 CollisionHandlerPusher const * 30 CollisionHandlerPusher const * 0 0 679 0 0 0 0 0 0 0 0 0 0

679 28 CollisionHandlerPusher const 0 8832 28 CollisionHandlerPusher const 28 CollisionHandlerPusher const 0 0 586 0 0 0 0 0 0 0 0 0 0

680 29 CollisionHandlerFluidPusher * 0 8576 29 CollisionHandlerFluidPusher * 29 CollisionHandlerFluidPusher * 0 0 587 0 0 0 0 0 0 0 0 0 0

681 25 CollisionHandlerGravity * 0 8576 25 CollisionHandlerGravity * 25 CollisionHandlerGravity * 0 0 588 0 0 0 0 0 0 0 0 0 0

682 31 CollisionHandlerGravity const * 0 8576 31 CollisionHandlerGravity const * 31 CollisionHandlerGravity const * 0 0 683 0 0 0 0 0 0 0 0 0 0

683 29 CollisionHandlerGravity const 0 8832 29 CollisionHandlerGravity const 29 CollisionHandlerGravity const 0 0 588 0 0 0 0 0 0 0 0 0 0

684 30 CollisionHandlerHighestEvent * 0 8576 30 CollisionHandlerHighestEvent * 30 CollisionHandlerHighestEvent * 0 0 590 0 0 0 0 0 0 0 0 0 0

685 36 CollisionHandlerHighestEvent const * 0 8576 36 CollisionHandlerHighestEvent const * 36 CollisionHandlerHighestEvent const * 0 0 686 0 0 0 0 0 0 0 0 0 0

686 34 CollisionHandlerHighestEvent const 0 8832 34 CollisionHandlerHighestEvent const 34 CollisionHandlerHighestEvent const 0 0 590 0 0 0 0 0 0 0 0 0 0

687 23 CollisionHandlerQueue * 0 8576 23 CollisionHandlerQueue * 23 CollisionHandlerQueue * 0 0 591 0 0 0 0 0 0 0 0 0 0

688 29 CollisionHandlerQueue const * 0 8576 29 CollisionHandlerQueue const * 29 CollisionHandlerQueue const * 0 0 689 0 0 0 0 0 0 0 0 0 0

689 27 CollisionHandlerQueue const 0 8832 27 CollisionHandlerQueue const 27 CollisionHandlerQueue const 0 0 591 0 0 0 0 0 0 0 0 0 0

690 17 CollisionSphere * 0 8576 17 CollisionSphere * 17 CollisionSphere * 0 0 593 0 0 0 0 0 0 0 0 0 0

691 23 CollisionSphere const * 0 8576 23 CollisionSphere const * 23 CollisionSphere const * 0 0 692 0 0 0 0 0 0 0 0 0 0

692 21 CollisionSphere const 0 8832 21 CollisionSphere const 21 CollisionSphere const 0 0 593 0 0 0 0 0 0 0 0 0 0

693 20 CollisionInvSphere * 0 8576 20 CollisionInvSphere * 20 CollisionInvSphere * 0 0 594 0 0 0 0 0 0 0 0 0 0

694 14 CollisionRay * 0 8576 14 CollisionRay * 14 CollisionRay * 0 0 595 0 0 0 0 0 0 0 0 0 0

695 20 CollisionRay const * 0 8576 20 CollisionRay const * 20 CollisionRay const * 0 0 696 0 0 0 0 0 0 0 0 0 0

696 18 CollisionRay const 0 8832 18 CollisionRay const 18 CollisionRay const 0 0 595 0 0 0 0 0 0 0 0 0 0

697 10 LensNode * 0 8576 10 LensNode * 10 LensNode * 0 0 698 0 0 0 0 0 0 0 0 0 0

698 8 LensNode 0 2048 8 LensNode 8 LensNode 0 0 0 0 0 0 0 0 0 0 0 0 181
/**
 * A node that contains a Lens.  The most important example of this kind of
 * node is a Camera, but other kinds of nodes also contain a lens (for
 * instance, a Spotlight).
 */

699 15 LPoint2 const * 0 8576 15 LPoint2 const * 15 LPoint2 const * 0 0 700 0 0 0 0 0 0 0 0 0 0

700 13 LPoint2 const 0 8832 13 LPoint2 const 13 LPoint2 const 0 0 701 0 0 0 0 0 0 0 0 0 0

701 7 LPoint2 0 2105344 7 LPoint2 7 LPoint2 0 0 702 0 0 0 0 0 0 0 0 0 0

702 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

703 15 CollisionLine * 0 8576 15 CollisionLine * 15 CollisionLine * 0 0 596 0 0 0 0 0 0 0 0 0 0

704 19 CollisionParabola * 0 8576 19 CollisionParabola * 19 CollisionParabola * 0 0 597 0 0 0 0 0 0 0 0 0 0

705 17 LParabola const * 0 8576 17 LParabola const * 17 LParabola const * 0 0 598 0 0 0 0 0 0 0 0 0 0

706 25 CollisionParabola const * 0 8576 25 CollisionParabola const * 25 CollisionParabola const * 0 0 707 0 0 0 0 0 0 0 0 0 0

707 23 CollisionParabola const 0 8832 23 CollisionParabola const 23 CollisionParabola const 0 0 597 0 0 0 0 0 0 0 0 0 0

708 18 CollisionSegment * 0 8576 18 CollisionSegment * 18 CollisionSegment * 0 0 601 0 0 0 0 0 0 0 0 0 0

709 24 CollisionSegment const * 0 8576 24 CollisionSegment const * 24 CollisionSegment const * 0 0 710 0 0 0 0 0 0 0 0 0 0

710 22 CollisionSegment const 0 8832 22 CollisionSegment const 22 CollisionSegment const 0 0 601 0 0 0 0 0 0 0 0 0 0

0
61
711 16 collision_origin 0 2 541 276 0 0 0 0 0 0 0 32 CollisionSolid::collision_origin 0

712 8 tangible 0 6 543 278 277 0 0 0 0 0 0 24 CollisionSolid::tangible 0

713 24 respect_effective_normal 0 6 543 284 283 0 0 0 0 0 0 40 CollisionSolid::respect_effective_normal 0

714 6 bounds 0 6 544 285 286 0 0 0 0 0 0 22 CollisionSolid::bounds 0

715 6 center 0 2 546 298 0 0 0 0 0 0 0 20 CollisionBox::center 0

716 3 min 0 2 546 299 0 0 0 0 0 0 0 17 CollisionBox::min 0

717 3 max 0 2 546 300 0 0 0 0 0 0 0 17 CollisionBox::max 0

718 10 dimensions 0 2 547 301 0 0 0 0 0 0 0 24 CollisionBox::dimensions 0

719 7 point_a 0 6 546 306 305 0 0 0 0 0 0 25 CollisionCapsule::point_a 0

720 7 point_b 0 6 546 308 307 0 0 0 0 0 0 25 CollisionCapsule::point_b 0

721 6 radius 0 6 550 310 309 0 0 0 0 0 0 24 CollisionCapsule::radius 0

722 17 from_collide_mask 0 6 556 320 318 0 0 0 0 0 0 32 CollisionNode::from_collide_mask 0

723 17 into_collide_mask 0 6 556 321 319 0 0 0 0 0 0 32 CollisionNode::into_collide_mask 0

724 6 solids 0 358 559 324 326 0 0 328 323 327 0 21 CollisionNode::solids 0

725 13 collider_sort 0 6 560 330 331 0 0 0 0 0 0 28 CollisionNode::collider_sort 0

726 20 default_collide_mask 0 2 556 332 0 0 0 0 0 0 0 35 CollisionNode::default_collide_mask 0

727 22 respect_prev_transform 0 6 543 337 336 0 0 0 0 0 0 42 CollisionTraverser::respect_prev_transform 0

728 9 colliders 0 66 563 342 0 0 0 0 341 0 0 29 CollisionTraverser::colliders 0

729 8 recorder 0 30 564 348 346 347 349 0 0 0 0 28 CollisionTraverser::recorder 0

730 10 from_solid 0 2 569 359 0 0 0 0 0 0 0 26 CollisionEntry::from_solid 0

731 10 into_solid 0 2 569 361 0 0 0 0 0 0 0 26 CollisionEntry::into_solid 0

732 9 from_node 0 2 571 362 0 0 0 0 0 0 0 25 CollisionEntry::from_node 0

733 9 into_node 0 2 572 363 0 0 0 0 0 0 0 25 CollisionEntry::into_node 0

734 14 from_node_path 0 2 563 364 0 0 0 0 0 0 0 30 CollisionEntry::from_node_path 0

735 14 into_node_path 0 2 563 365 0 0 0 0 0 0 0 30 CollisionEntry::into_node_path 0

736 1 t 0 6 550 367 366 0 0 0 0 0 0 17 CollisionEntry::t 0

737 22 respect_prev_transform 0 2 543 370 0 0 0 0 0 0 0 38 CollisionEntry::respect_prev_transform 0

738 6 normal 0 2 547 393 0 0 0 0 0 0 0 22 CollisionPlane::normal 0

739 5 plane 0 6 574 396 395 0 0 0 0 0 0 21 CollisionPlane::plane 0

740 8 vertices 0 66 546 404 0 0 0 0 403 0 0 28 CollisionFloorMesh::vertices 0

741 9 triangles 0 66 578 406 0 0 0 0 405 0 0 29 CollisionFloorMesh::triangles 0

742 6 points 0 66 541 411 0 0 0 0 410 0 0 24 CollisionPolygon::points 0

743 5 valid 0 2 543 413 0 0 0 0 0 0 0 23 CollisionPolygon::valid 0

744 7 concave 0 2 543 414 0 0 0 0 0 0 0 25 CollisionPolygon::concave 0

745 11 in_patterns 0 66 581 423 0 0 0 0 422 0 0 34 CollisionHandlerEvent::in_patterns 0

746 14 again_patterns 0 66 581 428 0 0 0 0 427 0 0 37 CollisionHandlerEvent::again_patterns 0

747 12 out_patterns 0 66 581 433 0 0 0 0 432 0 0 35 CollisionHandlerEvent::out_patterns 0

748 6 center 0 30 584 448 446 449 447 0 0 0 0 32 CollisionHandlerPhysical::center 0

749 6 offset 0 6 550 456 455 0 0 0 0 0 0 29 CollisionHandlerFloor::offset 0

750 5 reach 0 6 550 458 457 0 0 0 0 0 0 28 CollisionHandlerFloor::reach 0

751 12 max_velocity 0 6 550 460 459 0 0 0 0 0 0 35 CollisionHandlerFloor::max_velocity 0

752 10 horizontal 0 6 543 464 463 0 0 0 0 0 0 34 CollisionHandlerPusher::horizontal 0

753 6 offset 0 6 550 471 470 0 0 0 0 0 0 31 CollisionHandlerGravity::offset 0

754 5 reach 0 6 550 473 472 0 0 0 0 0 0 30 CollisionHandlerGravity::reach 0

755 15 airborne_height 0 2 550 474 0 0 0 0 0 0 0 40 CollisionHandlerGravity::airborne_height 0

756 9 on_ground 0 2 543 475 0 0 0 0 0 0 0 34 CollisionHandlerGravity::on_ground 0

757 15 impact_velocity 0 2 550 476 0 0 0 0 0 0 0 40 CollisionHandlerGravity::impact_velocity 0

758 14 contact_normal 0 2 589 477 0 0 0 0 0 0 0 39 CollisionHandlerGravity::contact_normal 0

759 8 velocity 0 6 550 480 479 0 0 0 0 0 0 33 CollisionHandlerGravity::velocity 0

760 7 gravity 0 6 550 482 481 0 0 0 0 0 0 32 CollisionHandlerGravity::gravity 0

761 12 max_velocity 0 6 550 484 483 0 0 0 0 0 0 37 CollisionHandlerGravity::max_velocity 0

762 7 entries 0 66 592 495 0 0 0 0 494 0 0 30 CollisionHandlerQueue::entries 0

763 6 center 0 6 546 503 502 0 0 0 0 0 0 23 CollisionSphere::center 0

764 6 radius 0 6 550 505 504 0 0 0 0 0 0 23 CollisionSphere::radius 0

765 6 origin 0 6 546 513 512 0 0 0 0 0 0 20 CollisionRay::origin 0

766 9 direction 0 6 589 515 514 0 0 0 0 0 0 23 CollisionRay::direction 0

767 8 parabola 0 6 598 524 523 0 0 0 0 0 0 27 CollisionParabola::parabola 0

768 2 t1 0 6 550 526 525 0 0 0 0 0 0 21 CollisionParabola::t1 0

769 2 t2 0 6 550 528 527 0 0 0 0 0 0 21 CollisionParabola::t2 0

770 7 point_a 0 6 546 533 532 0 0 0 0 0 0 25 CollisionSegment::point_a 0

771 7 point_b 0 6 546 535 534 0 0 0 0 0 0 25 CollisionSegment::point_b 0

9
772 10 get_solids 0 323 324 25 CollisionNode::get_solids 0

773 13 get_colliders 0 341 342 33 CollisionTraverser::get_colliders 0

774 12 get_vertices 0 403 404 32 CollisionFloorMesh::get_vertices 0

775 13 get_triangles 0 405 406 33 CollisionFloorMesh::get_triangles 0

776 10 get_points 0 410 411 28 CollisionPolygon::get_points 0

777 15 get_in_patterns 0 422 423 38 CollisionHandlerEvent::get_in_patterns 0

778 18 get_again_patterns 0 427 428 41 CollisionHandlerEvent::get_again_patterns 0

779 16 get_out_patterns 0 432 433 39 CollisionHandlerEvent::get_out_patterns 0

780 11 get_entries 0 494 495 34 CollisionHandlerQueue::get_entries 0

