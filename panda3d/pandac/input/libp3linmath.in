1609777924
3 3
12 libp3linmath 4 Ns0b 12 panda3d.core 
1576
1993 11 MathNumbers 0 4 3569 24 MathNumbers::MathNumbers 0 2 1 2 0
112
inline MathNumbers::MathNumbers(void) = default;
inline MathNumbers::MathNumbers(MathNumbers const &) = default;

1994 12 ~MathNumbers 0 4 3569 25 MathNumbers::~MathNumbers 0 0 0
32
MathNumbers::~MathNumbers(void);

1995 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1903 1904 0
67
inline double deg_2_rad(double f);
inline float deg_2_rad(float f);

1996 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1905 1906 0
67
inline double rad_2_deg(double f);
inline float rad_2_deg(float f);

1997 10 LVecBase2f 0 4 3570 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22
/**
 *
 */

/**
 *
 */
205
inline LVecBase2f::LVecBase2f(void) = default;
inline LVecBase2f::LVecBase2f(float fill_value);
inline LVecBase2f::LVecBase2f(float x, float y);
inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default;

1998 12 operator new 0 4 3570 24 LVecBase2f::operator new 0 1 7 0
124
inline void *LVecBase2f::operator new(std::size_t size);
inline void *LVecBase2f::operator new(std::size_t size, void *ptr);

1999 15 operator delete 0 4 3570 27 LVecBase2f::operator delete 0 0 0
108
inline void LVecBase2f::operator delete(void *ptr);
inline void LVecBase2f::operator delete(void *, void *);

2000 12 validate_ptr 0 4 3570 24 LVecBase2f::validate_ptr 0 0 0
61
static inline bool LVecBase2f::validate_ptr(void const *ptr);

2001 10 operator = 0 4 3570 22 LVecBase2f::operator = 0 2 8 9 0
119
void LVecBase2f::operator =(LVecBase2f const &copy) = default;
void LVecBase2f::operator =(float fill_value) = default;

2002 4 zero 0 4 3570 16 LVecBase2f::zero 0 1 10 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2f const &LVecBase2f::zero(void);

2003 6 unit_x 0 4 3570 18 LVecBase2f::unit_x 0 1 11 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_x(void);

2004 6 unit_y 0 4 3570 18 LVecBase2f::unit_y 0 1 12 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_y(void);

2005 10 __reduce__ 0 4 3570 22 LVecBase2f::__reduce__ 0 1 13 0
62
inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;

2006 11 __getattr__ 0 4 3570 23 LVecBase2f::__getattr__ 0 1 14 0
93
inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2007 11 __setattr__ 0 4 3570 23 LVecBase2f::__setattr__ 0 1 15 0
99
inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2008 11 operator [] 0 4 3570 23 LVecBase2f::operator [] 0 2 16 17 10
/**
 *
 */
96
inline float LVecBase2f::operator [](int i) const;
inline float &LVecBase2f::operator [](int i);

2009 4 size 0 4 3570 16 LVecBase2f::size 0 1 18 0
44
static constexpr int LVecBase2f::size(void);

2010 6 is_nan 0 4 3570 18 LVecBase2f::is_nan 0 1 19 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2f::is_nan(void) const;

2011 8 get_cell 0 4 3570 20 LVecBase2f::get_cell 0 1 20 10
/**
 *
 */
47
inline float LVecBase2f::get_cell(int i) const;

2012 8 set_cell 0 4 3570 20 LVecBase2f::set_cell 0 1 21 10
/**
 *
 */
53
inline void LVecBase2f::set_cell(int i, float value);

2013 5 get_x 0 4 3570 17 LVecBase2f::get_x 0 1 22 10
/**
 *
 */
43
inline float LVecBase2f::get_x(void) const;

2014 5 get_y 0 4 3570 17 LVecBase2f::get_y 0 1 23 10
/**
 *
 */
43
inline float LVecBase2f::get_y(void) const;

2015 5 set_x 0 4 3570 17 LVecBase2f::set_x 0 1 24 10
/**
 *
 */
43
inline void LVecBase2f::set_x(float value);

2016 5 set_y 0 4 3570 17 LVecBase2f::set_y 0 1 25 10
/**
 *
 */
43
inline void LVecBase2f::set_y(float value);

2017 11 add_to_cell 0 4 3570 23 LVecBase2f::add_to_cell 0 1 26 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase2f::add_to_cell(int i, float value);

2018 5 add_x 0 4 3570 17 LVecBase2f::add_x 0 1 27 10
/**
 *
 */
43
inline void LVecBase2f::add_x(float value);

2019 5 add_y 0 4 3570 17 LVecBase2f::add_y 0 1 28 10
/**
 *
 */
43
inline void LVecBase2f::add_y(float value);

2020 8 get_data 0 4 3570 20 LVecBase2f::get_data 0 1 29 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
53
inline float const *LVecBase2f::get_data(void) const;

2021 18 get_num_components 0 4 3570 30 LVecBase2f::get_num_components 0 1 30 0
58
static constexpr int LVecBase2f::get_num_components(void);

2022 4 fill 0 4 3570 16 LVecBase2f::fill 0 1 31 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase2f::fill(float fill_value);

2023 3 set 0 4 3570 15 LVecBase2f::set 0 1 32 10
/**
 *
 */
46
inline void LVecBase2f::set(float x, float y);

2024 3 dot 0 4 3570 15 LVecBase2f::dot 0 1 33 10
/**
 *
 */
60
inline float LVecBase2f::dot(LVecBase2f const &other) const;

2025 14 length_squared 0 4 3570 26 LVecBase2f::length_squared 0 1 34 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase2f::length_squared(void) const;

2026 6 length 0 4 3570 18 LVecBase2f::length 0 1 35 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase2f::length(void) const;

2027 9 normalize 0 4 3570 21 LVecBase2f::normalize 0 1 36 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2f::normalize(void);

2028 10 normalized 0 4 3570 22 LVecBase2f::normalized 0 1 37 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2f LVecBase2f::normalized(void) const;

2029 7 project 0 4 3570 19 LVecBase2f::project 0 1 38 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const;

2030 10 operator < 0 4 3570 22 LVecBase2f::operator < 0 1 39 0
66
inline bool LVecBase2f::operator <(LVecBase2f const &other) const;

2031 11 operator == 0 4 3570 23 LVecBase2f::operator == 0 1 40 0
67
inline bool LVecBase2f::operator ==(LVecBase2f const &other) const;

2032 11 operator != 0 4 3570 23 LVecBase2f::operator != 0 1 41 0
67
inline bool LVecBase2f::operator !=(LVecBase2f const &other) const;

2033 10 compare_to 0 4 3570 22 LVecBase2f::compare_to 0 2 42 43 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase2f::compare_to(LVecBase2f const &other) const;
inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const;

2034 8 get_hash 0 4 3570 20 LVecBase2f::get_hash 0 2 44 45 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase2f::get_hash(void) const;
inline std::size_t LVecBase2f::get_hash(float threshold) const;

2035 8 add_hash 0 4 3570 20 LVecBase2f::add_hash 0 2 46 47 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;

2036 13 generate_hash 0 4 3570 25 LVecBase2f::generate_hash 0 2 48 49 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2037 10 operator - 0 68 3570 22 LVecBase2f::operator - 0 1 50 0
53
inline LVecBase2f LVecBase2f::operator -(void) const;

2038 10 operator + 0 4 3570 22 LVecBase2f::operator + 0 1 51 0
72
inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const;

2039 10 operator - 0 4 3570 22 LVecBase2f::operator - 0 1 52 0
72
inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const;

2040 10 operator * 0 4 3570 22 LVecBase2f::operator * 0 1 53 0
61
inline LVecBase2f LVecBase2f::operator *(float scalar) const;

2041 10 operator / 0 4 3570 22 LVecBase2f::operator / 0 1 54 0
61
inline LVecBase2f LVecBase2f::operator /(float scalar) const;

2042 11 operator += 0 4 3570 23 LVecBase2f::operator += 0 1 55 0
61
inline void LVecBase2f::operator +=(LVecBase2f const &other);

2043 11 operator -= 0 4 3570 23 LVecBase2f::operator -= 0 1 56 0
61
inline void LVecBase2f::operator -=(LVecBase2f const &other);

2044 11 operator *= 0 4 3570 23 LVecBase2f::operator *= 0 1 57 0
50
inline void LVecBase2f::operator *=(float scalar);

2045 11 operator /= 0 4 3570 23 LVecBase2f::operator /= 0 1 58 0
50
inline void LVecBase2f::operator /=(float scalar);

2046 18 componentwise_mult 0 4 3570 30 LVecBase2f::componentwise_mult 0 1 59 10
/**
 *
 */
68
inline void LVecBase2f::componentwise_mult(LVecBase2f const &other);

2047 7 __pow__ 0 4 3570 19 LVecBase2f::__pow__ 0 1 60 0
60
inline LVecBase2f LVecBase2f::__pow__(float exponent) const;

2048 8 __ipow__ 0 4 3570 20 LVecBase2f::__ipow__ 0 1 61 0
70
inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);

2049 9 __round__ 0 4 3570 21 LVecBase2f::__round__ 0 1 62 0
55
inline PyObject *LVecBase2f::__round__(PyObject *self);

2050 9 __floor__ 0 4 3570 21 LVecBase2f::__floor__ 0 1 63 0
55
inline PyObject *LVecBase2f::__floor__(PyObject *self);

2051 8 __ceil__ 0 4 3570 20 LVecBase2f::__ceil__ 0 1 64 0
54
inline PyObject *LVecBase2f::__ceil__(PyObject *self);

2052 4 fmax 0 4 3570 16 LVecBase2f::fmax 0 1 65 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const;

2053 4 fmin 0 4 3570 16 LVecBase2f::fmin 0 1 66 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const;

2054 12 almost_equal 0 4 3570 24 LVecBase2f::almost_equal 0 2 67 68 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const;
inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const;

2055 6 output 0 4 3570 18 LVecBase2f::output 0 1 69 10
/**
 *
 */
56
inline void LVecBase2f::output(std::ostream &out) const;

2056 8 __repr__ 0 4 3570 20 LVecBase2f::__repr__ 0 1 70 0
52
inline std::string LVecBase2f::__repr__(void) const;

2057 20 write_datagram_fixed 0 4 3570 32 LVecBase2f::write_datagram_fixed 0 1 71 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const;

2058 19 read_datagram_fixed 0 4 3570 31 LVecBase2f::read_datagram_fixed 0 1 72 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source);

2059 14 write_datagram 0 4 3570 26 LVecBase2f::write_datagram 0 1 73 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2f::write_datagram(Datagram &destination) const;

2060 13 read_datagram 0 4 3570 25 LVecBase2f::read_datagram 0 1 74 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2f::read_datagram(DatagramIterator &source);

2061 14 get_class_type 0 4 3570 26 LVecBase2f::get_class_type 0 1 75 0
51
static TypeHandle LVecBase2f::get_class_type(void);

2062 11 ~LVecBase2f 0 4 3570 23 LVecBase2f::~LVecBase2f 0 0 0
30
LVecBase2f::~LVecBase2f(void);

2063 10 LVecBase2d 0 4 3573 22 LVecBase2d::LVecBase2d 0 4 76 77 78 79 22
/**
 *
 */

/**
 *
 */
208
inline LVecBase2d::LVecBase2d(void) = default;
inline LVecBase2d::LVecBase2d(double fill_value);
inline LVecBase2d::LVecBase2d(double x, double y);
inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default;

2064 12 operator new 0 4 3573 24 LVecBase2d::operator new 0 1 80 0
124
inline void *LVecBase2d::operator new(std::size_t size);
inline void *LVecBase2d::operator new(std::size_t size, void *ptr);

2065 15 operator delete 0 4 3573 27 LVecBase2d::operator delete 0 0 0
108
inline void LVecBase2d::operator delete(void *ptr);
inline void LVecBase2d::operator delete(void *, void *);

2066 12 validate_ptr 0 4 3573 24 LVecBase2d::validate_ptr 0 0 0
61
static inline bool LVecBase2d::validate_ptr(void const *ptr);

2067 10 operator = 0 4 3573 22 LVecBase2d::operator = 0 2 81 82 0
120
void LVecBase2d::operator =(LVecBase2d const &copy) = default;
void LVecBase2d::operator =(double fill_value) = default;

2068 4 zero 0 4 3573 16 LVecBase2d::zero 0 1 83 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2d const &LVecBase2d::zero(void);

2069 6 unit_x 0 4 3573 18 LVecBase2d::unit_x 0 1 84 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_x(void);

2070 6 unit_y 0 4 3573 18 LVecBase2d::unit_y 0 1 85 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_y(void);

2071 10 __reduce__ 0 4 3573 22 LVecBase2d::__reduce__ 0 1 86 0
62
inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;

2072 11 __getattr__ 0 4 3573 23 LVecBase2d::__getattr__ 0 1 87 0
93
inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2073 11 __setattr__ 0 4 3573 23 LVecBase2d::__setattr__ 0 1 88 0
99
inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2074 11 operator [] 0 4 3573 23 LVecBase2d::operator [] 0 2 89 90 10
/**
 *
 */
98
inline double LVecBase2d::operator [](int i) const;
inline double &LVecBase2d::operator [](int i);

2075 4 size 0 4 3573 16 LVecBase2d::size 0 1 91 0
44
static constexpr int LVecBase2d::size(void);

2076 6 is_nan 0 4 3573 18 LVecBase2d::is_nan 0 1 92 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2d::is_nan(void) const;

2077 8 get_cell 0 4 3573 20 LVecBase2d::get_cell 0 1 93 10
/**
 *
 */
48
inline double LVecBase2d::get_cell(int i) const;

2078 8 set_cell 0 4 3573 20 LVecBase2d::set_cell 0 1 94 10
/**
 *
 */
54
inline void LVecBase2d::set_cell(int i, double value);

2079 5 get_x 0 4 3573 17 LVecBase2d::get_x 0 1 95 10
/**
 *
 */
44
inline double LVecBase2d::get_x(void) const;

2080 5 get_y 0 4 3573 17 LVecBase2d::get_y 0 1 96 10
/**
 *
 */
44
inline double LVecBase2d::get_y(void) const;

2081 5 set_x 0 4 3573 17 LVecBase2d::set_x 0 1 97 10
/**
 *
 */
44
inline void LVecBase2d::set_x(double value);

2082 5 set_y 0 4 3573 17 LVecBase2d::set_y 0 1 98 10
/**
 *
 */
44
inline void LVecBase2d::set_y(double value);

2083 11 add_to_cell 0 4 3573 23 LVecBase2d::add_to_cell 0 1 99 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase2d::add_to_cell(int i, double value);

2084 5 add_x 0 4 3573 17 LVecBase2d::add_x 0 1 100 10
/**
 *
 */
44
inline void LVecBase2d::add_x(double value);

2085 5 add_y 0 4 3573 17 LVecBase2d::add_y 0 1 101 10
/**
 *
 */
44
inline void LVecBase2d::add_y(double value);

2086 8 get_data 0 4 3573 20 LVecBase2d::get_data 0 1 102 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
54
inline double const *LVecBase2d::get_data(void) const;

2087 18 get_num_components 0 4 3573 30 LVecBase2d::get_num_components 0 1 103 0
58
static constexpr int LVecBase2d::get_num_components(void);

2088 4 fill 0 4 3573 16 LVecBase2d::fill 0 1 104 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase2d::fill(double fill_value);

2089 3 set 0 4 3573 15 LVecBase2d::set 0 1 105 10
/**
 *
 */
48
inline void LVecBase2d::set(double x, double y);

2090 3 dot 0 4 3573 15 LVecBase2d::dot 0 1 106 10
/**
 *
 */
61
inline double LVecBase2d::dot(LVecBase2d const &other) const;

2091 14 length_squared 0 4 3573 26 LVecBase2d::length_squared 0 1 107 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase2d::length_squared(void) const;

2092 6 length 0 4 3573 18 LVecBase2d::length 0 1 108 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase2d::length(void) const;

2093 9 normalize 0 4 3573 21 LVecBase2d::normalize 0 1 109 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2d::normalize(void);

2094 10 normalized 0 4 3573 22 LVecBase2d::normalized 0 1 110 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2d LVecBase2d::normalized(void) const;

2095 7 project 0 4 3573 19 LVecBase2d::project 0 1 111 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const;

2096 10 operator < 0 4 3573 22 LVecBase2d::operator < 0 1 112 0
66
inline bool LVecBase2d::operator <(LVecBase2d const &other) const;

2097 11 operator == 0 4 3573 23 LVecBase2d::operator == 0 1 113 0
67
inline bool LVecBase2d::operator ==(LVecBase2d const &other) const;

2098 11 operator != 0 4 3573 23 LVecBase2d::operator != 0 1 114 0
67
inline bool LVecBase2d::operator !=(LVecBase2d const &other) const;

2099 10 compare_to 0 4 3573 22 LVecBase2d::compare_to 0 2 115 116 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase2d::compare_to(LVecBase2d const &other) const;
inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const;

2100 8 get_hash 0 4 3573 20 LVecBase2d::get_hash 0 2 117 118 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase2d::get_hash(void) const;
inline std::size_t LVecBase2d::get_hash(double threshold) const;

2101 8 add_hash 0 4 3573 20 LVecBase2d::add_hash 0 2 119 120 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;

2102 13 generate_hash 0 4 3573 25 LVecBase2d::generate_hash 0 2 121 122 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2103 10 operator - 0 68 3573 22 LVecBase2d::operator - 0 1 123 0
53
inline LVecBase2d LVecBase2d::operator -(void) const;

2104 10 operator + 0 4 3573 22 LVecBase2d::operator + 0 1 124 0
72
inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const;

2105 10 operator - 0 4 3573 22 LVecBase2d::operator - 0 1 125 0
72
inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const;

2106 10 operator * 0 4 3573 22 LVecBase2d::operator * 0 1 126 0
62
inline LVecBase2d LVecBase2d::operator *(double scalar) const;

2107 10 operator / 0 4 3573 22 LVecBase2d::operator / 0 1 127 0
62
inline LVecBase2d LVecBase2d::operator /(double scalar) const;

2108 11 operator += 0 4 3573 23 LVecBase2d::operator += 0 1 128 0
61
inline void LVecBase2d::operator +=(LVecBase2d const &other);

2109 11 operator -= 0 4 3573 23 LVecBase2d::operator -= 0 1 129 0
61
inline void LVecBase2d::operator -=(LVecBase2d const &other);

2110 11 operator *= 0 4 3573 23 LVecBase2d::operator *= 0 1 130 0
51
inline void LVecBase2d::operator *=(double scalar);

2111 11 operator /= 0 4 3573 23 LVecBase2d::operator /= 0 1 131 0
51
inline void LVecBase2d::operator /=(double scalar);

2112 18 componentwise_mult 0 4 3573 30 LVecBase2d::componentwise_mult 0 1 132 10
/**
 *
 */
68
inline void LVecBase2d::componentwise_mult(LVecBase2d const &other);

2113 7 __pow__ 0 4 3573 19 LVecBase2d::__pow__ 0 1 133 0
61
inline LVecBase2d LVecBase2d::__pow__(double exponent) const;

2114 8 __ipow__ 0 4 3573 20 LVecBase2d::__ipow__ 0 1 134 0
71
inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);

2115 9 __round__ 0 4 3573 21 LVecBase2d::__round__ 0 1 135 0
55
inline PyObject *LVecBase2d::__round__(PyObject *self);

2116 9 __floor__ 0 4 3573 21 LVecBase2d::__floor__ 0 1 136 0
55
inline PyObject *LVecBase2d::__floor__(PyObject *self);

2117 8 __ceil__ 0 4 3573 20 LVecBase2d::__ceil__ 0 1 137 0
54
inline PyObject *LVecBase2d::__ceil__(PyObject *self);

2118 4 fmax 0 4 3573 16 LVecBase2d::fmax 0 1 138 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const;

2119 4 fmin 0 4 3573 16 LVecBase2d::fmin 0 1 139 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const;

2120 12 almost_equal 0 4 3573 24 LVecBase2d::almost_equal 0 2 140 141 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const;
inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const;

2121 6 output 0 4 3573 18 LVecBase2d::output 0 1 142 10
/**
 *
 */
56
inline void LVecBase2d::output(std::ostream &out) const;

2122 8 __repr__ 0 4 3573 20 LVecBase2d::__repr__ 0 1 143 0
52
inline std::string LVecBase2d::__repr__(void) const;

2123 20 write_datagram_fixed 0 4 3573 32 LVecBase2d::write_datagram_fixed 0 1 144 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const;

2124 19 read_datagram_fixed 0 4 3573 31 LVecBase2d::read_datagram_fixed 0 1 145 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source);

2125 14 write_datagram 0 4 3573 26 LVecBase2d::write_datagram 0 1 146 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2d::write_datagram(Datagram &destination) const;

2126 13 read_datagram 0 4 3573 25 LVecBase2d::read_datagram 0 1 147 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2d::read_datagram(DatagramIterator &source);

2127 14 get_class_type 0 4 3573 26 LVecBase2d::get_class_type 0 1 148 0
51
static TypeHandle LVecBase2d::get_class_type(void);

2128 11 ~LVecBase2d 0 4 3573 23 LVecBase2d::~LVecBase2d 0 0 0
30
LVecBase2d::~LVecBase2d(void);

2129 10 LVecBase2i 0 4 3576 22 LVecBase2i::LVecBase2i 0 4 149 150 151 152 22
/**
 *
 */

/**
 *
 */
199
inline LVecBase2i::LVecBase2i(void) = default;
inline LVecBase2i::LVecBase2i(int fill_value);
inline LVecBase2i::LVecBase2i(int x, int y);
inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default;

2130 12 operator new 0 4 3576 24 LVecBase2i::operator new 0 1 153 0
124
inline void *LVecBase2i::operator new(std::size_t size);
inline void *LVecBase2i::operator new(std::size_t size, void *ptr);

2131 15 operator delete 0 4 3576 27 LVecBase2i::operator delete 0 0 0
108
inline void LVecBase2i::operator delete(void *ptr);
inline void LVecBase2i::operator delete(void *, void *);

2132 12 validate_ptr 0 4 3576 24 LVecBase2i::validate_ptr 0 0 0
61
static inline bool LVecBase2i::validate_ptr(void const *ptr);

2133 10 operator = 0 4 3576 22 LVecBase2i::operator = 0 2 154 155 0
117
void LVecBase2i::operator =(LVecBase2i const &copy) = default;
void LVecBase2i::operator =(int fill_value) = default;

2134 4 zero 0 4 3576 16 LVecBase2i::zero 0 1 156 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2i const &LVecBase2i::zero(void);

2135 6 unit_x 0 4 3576 18 LVecBase2i::unit_x 0 1 157 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_x(void);

2136 6 unit_y 0 4 3576 18 LVecBase2i::unit_y 0 1 158 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_y(void);

2137 10 __reduce__ 0 4 3576 22 LVecBase2i::__reduce__ 0 1 159 0
62
inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;

2138 11 __getattr__ 0 4 3576 23 LVecBase2i::__getattr__ 0 1 160 0
93
inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2139 11 __setattr__ 0 4 3576 23 LVecBase2i::__setattr__ 0 1 161 0
99
inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2140 11 operator [] 0 4 3576 23 LVecBase2i::operator [] 0 2 162 163 10
/**
 *
 */
92
inline int LVecBase2i::operator [](int i) const;
inline int &LVecBase2i::operator [](int i);

2141 4 size 0 4 3576 16 LVecBase2i::size 0 1 164 0
44
static constexpr int LVecBase2i::size(void);

2142 6 is_nan 0 4 3576 18 LVecBase2i::is_nan 0 1 165 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2i::is_nan(void) const;

2143 8 get_cell 0 4 3576 20 LVecBase2i::get_cell 0 1 166 10
/**
 *
 */
45
inline int LVecBase2i::get_cell(int i) const;

2144 8 set_cell 0 4 3576 20 LVecBase2i::set_cell 0 1 167 10
/**
 *
 */
51
inline void LVecBase2i::set_cell(int i, int value);

2145 5 get_x 0 4 3576 17 LVecBase2i::get_x 0 1 168 10
/**
 *
 */
41
inline int LVecBase2i::get_x(void) const;

2146 5 get_y 0 4 3576 17 LVecBase2i::get_y 0 1 169 10
/**
 *
 */
41
inline int LVecBase2i::get_y(void) const;

2147 5 set_x 0 4 3576 17 LVecBase2i::set_x 0 1 170 10
/**
 *
 */
41
inline void LVecBase2i::set_x(int value);

2148 5 set_y 0 4 3576 17 LVecBase2i::set_y 0 1 171 10
/**
 *
 */
41
inline void LVecBase2i::set_y(int value);

2149 11 add_to_cell 0 4 3576 23 LVecBase2i::add_to_cell 0 1 172 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase2i::add_to_cell(int i, int value);

2150 5 add_x 0 4 3576 17 LVecBase2i::add_x 0 1 173 10
/**
 *
 */
41
inline void LVecBase2i::add_x(int value);

2151 5 add_y 0 4 3576 17 LVecBase2i::add_y 0 1 174 10
/**
 *
 */
41
inline void LVecBase2i::add_y(int value);

2152 8 get_data 0 4 3576 20 LVecBase2i::get_data 0 1 175 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
51
inline int const *LVecBase2i::get_data(void) const;

2153 18 get_num_components 0 4 3576 30 LVecBase2i::get_num_components 0 1 176 0
58
static constexpr int LVecBase2i::get_num_components(void);

2154 4 fill 0 4 3576 16 LVecBase2i::fill 0 1 177 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase2i::fill(int fill_value);

2155 3 set 0 4 3576 15 LVecBase2i::set 0 1 178 10
/**
 *
 */
42
inline void LVecBase2i::set(int x, int y);

2156 3 dot 0 4 3576 15 LVecBase2i::dot 0 1 179 10
/**
 *
 */
58
inline int LVecBase2i::dot(LVecBase2i const &other) const;

2157 14 length_squared 0 4 3576 26 LVecBase2i::length_squared 0 1 180 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase2i::length_squared(void) const;

2158 10 operator < 0 4 3576 22 LVecBase2i::operator < 0 1 181 0
66
inline bool LVecBase2i::operator <(LVecBase2i const &other) const;

2159 11 operator == 0 4 3576 23 LVecBase2i::operator == 0 1 182 0
67
inline bool LVecBase2i::operator ==(LVecBase2i const &other) const;

2160 11 operator != 0 4 3576 23 LVecBase2i::operator != 0 1 183 0
67
inline bool LVecBase2i::operator !=(LVecBase2i const &other) const;

2161 10 compare_to 0 4 3576 22 LVecBase2i::compare_to 0 1 184 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase2i::compare_to(LVecBase2i const &other) const;

2162 8 get_hash 0 4 3576 20 LVecBase2i::get_hash 0 1 185 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase2i::get_hash(void) const;

2163 8 add_hash 0 4 3576 20 LVecBase2i::add_hash 0 1 186 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;

2164 13 generate_hash 0 4 3576 25 LVecBase2i::generate_hash 0 1 187 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase2i::generate_hash(ChecksumHashGenerator &hashgen) const;

2165 10 operator - 0 68 3576 22 LVecBase2i::operator - 0 1 188 0
53
inline LVecBase2i LVecBase2i::operator -(void) const;

2166 10 operator + 0 4 3576 22 LVecBase2i::operator + 0 1 189 0
72
inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const;

2167 10 operator - 0 4 3576 22 LVecBase2i::operator - 0 1 190 0
72
inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const;

2168 10 operator * 0 4 3576 22 LVecBase2i::operator * 0 1 191 0
59
inline LVecBase2i LVecBase2i::operator *(int scalar) const;

2169 10 operator / 0 4 3576 22 LVecBase2i::operator / 0 1 192 0
59
inline LVecBase2i LVecBase2i::operator /(int scalar) const;

2170 11 operator += 0 4 3576 23 LVecBase2i::operator += 0 1 193 0
61
inline void LVecBase2i::operator +=(LVecBase2i const &other);

2171 11 operator -= 0 4 3576 23 LVecBase2i::operator -= 0 1 194 0
61
inline void LVecBase2i::operator -=(LVecBase2i const &other);

2172 11 operator *= 0 4 3576 23 LVecBase2i::operator *= 0 1 195 0
48
inline void LVecBase2i::operator *=(int scalar);

2173 11 operator /= 0 4 3576 23 LVecBase2i::operator /= 0 1 196 0
48
inline void LVecBase2i::operator /=(int scalar);

2174 18 componentwise_mult 0 4 3576 30 LVecBase2i::componentwise_mult 0 1 197 10
/**
 *
 */
68
inline void LVecBase2i::componentwise_mult(LVecBase2i const &other);

2175 7 __pow__ 0 4 3576 19 LVecBase2i::__pow__ 0 1 198 0
58
inline LVecBase2i LVecBase2i::__pow__(int exponent) const;

2176 8 __ipow__ 0 4 3576 20 LVecBase2i::__ipow__ 0 1 199 0
68
inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);

2177 9 __round__ 0 4 3576 21 LVecBase2i::__round__ 0 1 200 0
55
inline PyObject *LVecBase2i::__round__(PyObject *self);

2178 9 __floor__ 0 4 3576 21 LVecBase2i::__floor__ 0 1 201 0
55
inline PyObject *LVecBase2i::__floor__(PyObject *self);

2179 8 __ceil__ 0 4 3576 20 LVecBase2i::__ceil__ 0 1 202 0
54
inline PyObject *LVecBase2i::__ceil__(PyObject *self);

2180 4 fmax 0 4 3576 16 LVecBase2i::fmax 0 1 203 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const;

2181 4 fmin 0 4 3576 16 LVecBase2i::fmin 0 1 204 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const;

2182 12 almost_equal 0 4 3576 24 LVecBase2i::almost_equal 0 2 205 206 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const;
inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const;

2183 6 output 0 4 3576 18 LVecBase2i::output 0 1 207 10
/**
 *
 */
56
inline void LVecBase2i::output(std::ostream &out) const;

2184 8 __repr__ 0 4 3576 20 LVecBase2i::__repr__ 0 1 208 0
52
inline std::string LVecBase2i::__repr__(void) const;

2185 20 write_datagram_fixed 0 4 3576 32 LVecBase2i::write_datagram_fixed 0 1 209 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const;

2186 19 read_datagram_fixed 0 4 3576 31 LVecBase2i::read_datagram_fixed 0 1 210 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source);

2187 14 write_datagram 0 4 3576 26 LVecBase2i::write_datagram 0 1 211 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2i::write_datagram(Datagram &destination) const;

2188 13 read_datagram 0 4 3576 25 LVecBase2i::read_datagram 0 1 212 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2i::read_datagram(DatagramIterator &source);

2189 14 get_class_type 0 4 3576 26 LVecBase2i::get_class_type 0 1 213 0
51
static TypeHandle LVecBase2i::get_class_type(void);

2190 11 ~LVecBase2i 0 4 3576 23 LVecBase2i::~LVecBase2i 0 0 0
30
LVecBase2i::~LVecBase2i(void);

2191 9 LVector2f 0 4 3579 20 LVector2f::LVector2f 0 5 214 215 216 217 218 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
249
inline LVector2f::LVector2f(void) = default;
inline LVector2f::LVector2f(LVecBase2f const &copy);
inline LVector2f::LVector2f(float fill_value);
inline LVector2f::LVector2f(float x, float y);
inline LVector2f::LVector2f(LVector2f const &) = default;

2192 11 __getattr__ 0 4 3579 22 LVector2f::__getattr__ 0 1 219 0
92
inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2193 11 __setattr__ 0 4 3579 22 LVector2f::__setattr__ 0 1 220 0
98
inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2194 4 zero 0 4 3579 15 LVector2f::zero 0 1 221 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2f const &LVector2f::zero(void);

2195 6 unit_x 0 4 3579 17 LVector2f::unit_x 0 1 222 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2f const &LVector2f::unit_x(void);

2196 6 unit_y 0 4 3579 17 LVector2f::unit_y 0 1 223 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2f const &LVector2f::unit_y(void);

2197 10 operator - 0 68 3579 21 LVector2f::operator - 0 1 224 0
51
inline LVector2f LVector2f::operator -(void) const;

2198 10 operator + 0 4 3579 21 LVector2f::operator + 0 2 225 226 0
141
inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator +(LVector2f const &other) const;

2199 10 operator - 0 4 3579 21 LVector2f::operator - 0 2 227 228 0
141
inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator -(LVector2f const &other) const;

2200 10 operator * 0 4 3579 21 LVector2f::operator * 0 1 229 0
59
inline LVector2f LVector2f::operator *(float scalar) const;

2201 10 operator / 0 4 3579 21 LVector2f::operator / 0 1 230 0
59
inline LVector2f LVector2f::operator /(float scalar) const;

2202 10 normalized 0 4 3579 21 LVector2f::normalized 0 1 231 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2f LVector2f::normalized(void) const;

2203 7 project 0 4 3579 18 LVector2f::project 0 1 232 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2f LVector2f::project(LVecBase2f const &onto) const;

2204 16 signed_angle_rad 0 4 3579 27 LVector2f::signed_angle_rad 0 1 233 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_rad(LVector2f const &other) const;

2205 16 signed_angle_deg 0 4 3579 27 LVector2f::signed_angle_deg 0 1 234 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_deg(LVector2f const &other) const;

2206 8 __repr__ 0 4 3579 19 LVector2f::__repr__ 0 1 235 0
51
inline std::string LVector2f::__repr__(void) const;

2207 14 get_class_type 0 4 3579 25 LVector2f::get_class_type 0 1 236 0
50
static TypeHandle LVector2f::get_class_type(void);

2208 10 ~LVector2f 0 4 3579 21 LVector2f::~LVector2f 0 0 0
28
LVector2f::~LVector2f(void);

2209 9 LVector2d 0 4 3580 20 LVector2d::LVector2d 0 5 237 238 239 240 241 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
252
inline LVector2d::LVector2d(void) = default;
inline LVector2d::LVector2d(LVecBase2d const &copy);
inline LVector2d::LVector2d(double fill_value);
inline LVector2d::LVector2d(double x, double y);
inline LVector2d::LVector2d(LVector2d const &) = default;

2210 11 __getattr__ 0 4 3580 22 LVector2d::__getattr__ 0 1 242 0
92
inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2211 11 __setattr__ 0 4 3580 22 LVector2d::__setattr__ 0 1 243 0
98
inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2212 4 zero 0 4 3580 15 LVector2d::zero 0 1 244 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2d const &LVector2d::zero(void);

2213 6 unit_x 0 4 3580 17 LVector2d::unit_x 0 1 245 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2d const &LVector2d::unit_x(void);

2214 6 unit_y 0 4 3580 17 LVector2d::unit_y 0 1 246 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2d const &LVector2d::unit_y(void);

2215 10 operator - 0 68 3580 21 LVector2d::operator - 0 1 247 0
51
inline LVector2d LVector2d::operator -(void) const;

2216 10 operator + 0 4 3580 21 LVector2d::operator + 0 2 248 249 0
141
inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator +(LVector2d const &other) const;

2217 10 operator - 0 4 3580 21 LVector2d::operator - 0 2 250 251 0
141
inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator -(LVector2d const &other) const;

2218 10 operator * 0 4 3580 21 LVector2d::operator * 0 1 252 0
60
inline LVector2d LVector2d::operator *(double scalar) const;

2219 10 operator / 0 4 3580 21 LVector2d::operator / 0 1 253 0
60
inline LVector2d LVector2d::operator /(double scalar) const;

2220 10 normalized 0 4 3580 21 LVector2d::normalized 0 1 254 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2d LVector2d::normalized(void) const;

2221 7 project 0 4 3580 18 LVector2d::project 0 1 255 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2d LVector2d::project(LVecBase2d const &onto) const;

2222 16 signed_angle_rad 0 4 3580 27 LVector2d::signed_angle_rad 0 1 256 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_rad(LVector2d const &other) const;

2223 16 signed_angle_deg 0 4 3580 27 LVector2d::signed_angle_deg 0 1 257 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_deg(LVector2d const &other) const;

2224 8 __repr__ 0 4 3580 19 LVector2d::__repr__ 0 1 258 0
51
inline std::string LVector2d::__repr__(void) const;

2225 14 get_class_type 0 4 3580 25 LVector2d::get_class_type 0 1 259 0
50
static TypeHandle LVector2d::get_class_type(void);

2226 10 ~LVector2d 0 4 3580 21 LVector2d::~LVector2d 0 0 0
28
LVector2d::~LVector2d(void);

2227 9 LVector2i 0 4 3581 20 LVector2i::LVector2i 0 5 260 261 262 263 264 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
243
inline LVector2i::LVector2i(void) = default;
inline LVector2i::LVector2i(LVecBase2i const &copy);
inline LVector2i::LVector2i(int fill_value);
inline LVector2i::LVector2i(int x, int y);
inline LVector2i::LVector2i(LVector2i const &) = default;

2228 11 __getattr__ 0 4 3581 22 LVector2i::__getattr__ 0 1 265 0
92
inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2229 11 __setattr__ 0 4 3581 22 LVector2i::__setattr__ 0 1 266 0
98
inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2230 4 zero 0 4 3581 15 LVector2i::zero 0 1 267 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2i const &LVector2i::zero(void);

2231 6 unit_x 0 4 3581 17 LVector2i::unit_x 0 1 268 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2i const &LVector2i::unit_x(void);

2232 6 unit_y 0 4 3581 17 LVector2i::unit_y 0 1 269 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2i const &LVector2i::unit_y(void);

2233 10 operator - 0 68 3581 21 LVector2i::operator - 0 1 270 0
51
inline LVector2i LVector2i::operator -(void) const;

2234 10 operator + 0 4 3581 21 LVector2i::operator + 0 2 271 272 0
141
inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator +(LVector2i const &other) const;

2235 10 operator - 0 4 3581 21 LVector2i::operator - 0 2 273 274 0
141
inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator -(LVector2i const &other) const;

2236 10 operator * 0 4 3581 21 LVector2i::operator * 0 1 275 0
57
inline LVector2i LVector2i::operator *(int scalar) const;

2237 10 operator / 0 4 3581 21 LVector2i::operator / 0 1 276 0
57
inline LVector2i LVector2i::operator /(int scalar) const;

2238 8 __repr__ 0 4 3581 19 LVector2i::__repr__ 0 1 277 0
51
inline std::string LVector2i::__repr__(void) const;

2239 14 get_class_type 0 4 3581 25 LVector2i::get_class_type 0 1 278 0
50
static TypeHandle LVector2i::get_class_type(void);

2240 10 ~LVector2i 0 4 3581 21 LVector2i::~LVector2i 0 0 0
28
LVector2i::~LVector2i(void);

2241 8 LPoint2f 0 4 3582 18 LPoint2f::LPoint2f 0 5 279 280 281 282 283 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
238
inline LPoint2f::LPoint2f(void) = default;
inline LPoint2f::LPoint2f(LVecBase2f const &copy);
inline LPoint2f::LPoint2f(float fill_value);
inline LPoint2f::LPoint2f(float x, float y);
inline LPoint2f::LPoint2f(LPoint2f const &) = default;

2242 11 __getattr__ 0 4 3582 21 LPoint2f::__getattr__ 0 1 284 0
91
inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2243 11 __setattr__ 0 4 3582 21 LPoint2f::__setattr__ 0 1 285 0
97
inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2244 4 zero 0 4 3582 14 LPoint2f::zero 0 1 286 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2f const &LPoint2f::zero(void);

2245 6 unit_x 0 4 3582 16 LPoint2f::unit_x 0 1 287 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2f const &LPoint2f::unit_x(void);

2246 6 unit_y 0 4 3582 16 LPoint2f::unit_y 0 1 288 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2f const &LPoint2f::unit_y(void);

2247 10 operator - 0 68 3582 20 LPoint2f::operator - 0 1 289 0
49
inline LPoint2f LPoint2f::operator -(void) const;

2248 10 operator + 0 4 3582 20 LPoint2f::operator + 0 2 290 291 0
138
inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const;
inline LPoint2f LPoint2f::operator +(LVector2f const &other) const;

2249 10 operator - 0 4 3582 20 LPoint2f::operator - 0 3 292 293 294 0
206
inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const;
inline LVector2f LPoint2f::operator -(LPoint2f const &other) const;
inline LPoint2f LPoint2f::operator -(LVector2f const &other) const;

2250 10 operator * 0 4 3582 20 LPoint2f::operator * 0 1 295 0
57
inline LPoint2f LPoint2f::operator *(float scalar) const;

2251 10 operator / 0 4 3582 20 LPoint2f::operator / 0 1 296 0
57
inline LPoint2f LPoint2f::operator /(float scalar) const;

2252 10 normalized 0 4 3582 20 LPoint2f::normalized 0 1 297 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2f LPoint2f::normalized(void) const;

2253 7 project 0 4 3582 17 LPoint2f::project 0 1 298 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const;

2254 8 __repr__ 0 4 3582 18 LPoint2f::__repr__ 0 1 299 0
50
inline std::string LPoint2f::__repr__(void) const;

2255 14 get_class_type 0 4 3582 24 LPoint2f::get_class_type 0 1 300 0
49
static TypeHandle LPoint2f::get_class_type(void);

2256 9 ~LPoint2f 0 4 3582 19 LPoint2f::~LPoint2f 0 0 0
26
LPoint2f::~LPoint2f(void);

2257 8 LPoint2d 0 4 3583 18 LPoint2d::LPoint2d 0 5 301 302 303 304 305 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
241
inline LPoint2d::LPoint2d(void) = default;
inline LPoint2d::LPoint2d(LVecBase2d const &copy);
inline LPoint2d::LPoint2d(double fill_value);
inline LPoint2d::LPoint2d(double x, double y);
inline LPoint2d::LPoint2d(LPoint2d const &) = default;

2258 11 __getattr__ 0 4 3583 21 LPoint2d::__getattr__ 0 1 306 0
91
inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2259 11 __setattr__ 0 4 3583 21 LPoint2d::__setattr__ 0 1 307 0
97
inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2260 4 zero 0 4 3583 14 LPoint2d::zero 0 1 308 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2d const &LPoint2d::zero(void);

2261 6 unit_x 0 4 3583 16 LPoint2d::unit_x 0 1 309 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2d const &LPoint2d::unit_x(void);

2262 6 unit_y 0 4 3583 16 LPoint2d::unit_y 0 1 310 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2d const &LPoint2d::unit_y(void);

2263 10 operator - 0 68 3583 20 LPoint2d::operator - 0 1 311 0
49
inline LPoint2d LPoint2d::operator -(void) const;

2264 10 operator + 0 4 3583 20 LPoint2d::operator + 0 2 312 313 0
138
inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const;
inline LPoint2d LPoint2d::operator +(LVector2d const &other) const;

2265 10 operator - 0 4 3583 20 LPoint2d::operator - 0 3 314 315 316 0
206
inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const;
inline LVector2d LPoint2d::operator -(LPoint2d const &other) const;
inline LPoint2d LPoint2d::operator -(LVector2d const &other) const;

2266 10 operator * 0 4 3583 20 LPoint2d::operator * 0 1 317 0
58
inline LPoint2d LPoint2d::operator *(double scalar) const;

2267 10 operator / 0 4 3583 20 LPoint2d::operator / 0 1 318 0
58
inline LPoint2d LPoint2d::operator /(double scalar) const;

2268 10 normalized 0 4 3583 20 LPoint2d::normalized 0 1 319 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2d LPoint2d::normalized(void) const;

2269 7 project 0 4 3583 17 LPoint2d::project 0 1 320 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const;

2270 8 __repr__ 0 4 3583 18 LPoint2d::__repr__ 0 1 321 0
50
inline std::string LPoint2d::__repr__(void) const;

2271 14 get_class_type 0 4 3583 24 LPoint2d::get_class_type 0 1 322 0
49
static TypeHandle LPoint2d::get_class_type(void);

2272 9 ~LPoint2d 0 4 3583 19 LPoint2d::~LPoint2d 0 0 0
26
LPoint2d::~LPoint2d(void);

2273 8 LPoint2i 0 4 3584 18 LPoint2i::LPoint2i 0 5 323 324 325 326 327 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
232
inline LPoint2i::LPoint2i(void) = default;
inline LPoint2i::LPoint2i(LVecBase2i const &copy);
inline LPoint2i::LPoint2i(int fill_value);
inline LPoint2i::LPoint2i(int x, int y);
inline LPoint2i::LPoint2i(LPoint2i const &) = default;

2274 11 __getattr__ 0 4 3584 21 LPoint2i::__getattr__ 0 1 328 0
91
inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2275 11 __setattr__ 0 4 3584 21 LPoint2i::__setattr__ 0 1 329 0
97
inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2276 4 zero 0 4 3584 14 LPoint2i::zero 0 1 330 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2i const &LPoint2i::zero(void);

2277 6 unit_x 0 4 3584 16 LPoint2i::unit_x 0 1 331 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2i const &LPoint2i::unit_x(void);

2278 6 unit_y 0 4 3584 16 LPoint2i::unit_y 0 1 332 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2i const &LPoint2i::unit_y(void);

2279 10 operator - 0 68 3584 20 LPoint2i::operator - 0 1 333 0
49
inline LPoint2i LPoint2i::operator -(void) const;

2280 10 operator + 0 4 3584 20 LPoint2i::operator + 0 2 334 335 0
138
inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const;
inline LPoint2i LPoint2i::operator +(LVector2i const &other) const;

2281 10 operator - 0 4 3584 20 LPoint2i::operator - 0 3 336 337 338 0
206
inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const;
inline LVector2i LPoint2i::operator -(LPoint2i const &other) const;
inline LPoint2i LPoint2i::operator -(LVector2i const &other) const;

2282 10 operator * 0 4 3584 20 LPoint2i::operator * 0 1 339 0
55
inline LPoint2i LPoint2i::operator *(int scalar) const;

2283 10 operator / 0 4 3584 20 LPoint2i::operator / 0 1 340 0
55
inline LPoint2i LPoint2i::operator /(int scalar) const;

2284 8 __repr__ 0 4 3584 18 LPoint2i::__repr__ 0 1 341 0
50
inline std::string LPoint2i::__repr__(void) const;

2285 14 get_class_type 0 4 3584 24 LPoint2i::get_class_type 0 1 342 0
49
static TypeHandle LPoint2i::get_class_type(void);

2286 9 ~LPoint2i 0 4 3584 19 LPoint2i::~LPoint2i 0 0 0
26
LPoint2i::~LPoint2i(void);

2287 10 LVecBase3f 0 4 3585 22 LVecBase3f::LVecBase3f 0 5 343 344 345 346 347 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
278
inline LVecBase3f::LVecBase3f(void) = default;
inline LVecBase3f::LVecBase3f(float fill_value);
inline LVecBase3f::LVecBase3f(float x, float y, float z);
inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z);
inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default;

2288 12 operator new 0 4 3585 24 LVecBase3f::operator new 0 1 348 0
124
inline void *LVecBase3f::operator new(std::size_t size);
inline void *LVecBase3f::operator new(std::size_t size, void *ptr);

2289 15 operator delete 0 4 3585 27 LVecBase3f::operator delete 0 0 0
108
inline void LVecBase3f::operator delete(void *ptr);
inline void LVecBase3f::operator delete(void *, void *);

2290 12 validate_ptr 0 4 3585 24 LVecBase3f::validate_ptr 0 0 0
61
static inline bool LVecBase3f::validate_ptr(void const *ptr);

2291 10 operator = 0 4 3585 22 LVecBase3f::operator = 0 2 349 350 0
119
void LVecBase3f::operator =(LVecBase3f const &copy) = default;
void LVecBase3f::operator =(float fill_value) = default;

2292 4 zero 0 4 3585 16 LVecBase3f::zero 0 1 351 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3f const &LVecBase3f::zero(void);

2293 6 unit_x 0 4 3585 18 LVecBase3f::unit_x 0 1 352 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_x(void);

2294 6 unit_y 0 4 3585 18 LVecBase3f::unit_y 0 1 353 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_y(void);

2295 6 unit_z 0 4 3585 18 LVecBase3f::unit_z 0 1 354 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_z(void);

2296 10 __reduce__ 0 4 3585 22 LVecBase3f::__reduce__ 0 1 355 0
62
inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;

2297 11 __getattr__ 0 4 3585 23 LVecBase3f::__getattr__ 0 1 356 0
93
inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2298 11 __setattr__ 0 4 3585 23 LVecBase3f::__setattr__ 0 1 357 0
99
inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2299 11 operator [] 0 4 3585 23 LVecBase3f::operator [] 0 2 358 359 10
/**
 *
 */
96
inline float LVecBase3f::operator [](int i) const;
inline float &LVecBase3f::operator [](int i);

2300 4 size 0 4 3585 16 LVecBase3f::size 0 1 360 0
44
static constexpr int LVecBase3f::size(void);

2301 6 is_nan 0 4 3585 18 LVecBase3f::is_nan 0 1 361 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3f::is_nan(void) const;

2302 8 get_cell 0 4 3585 20 LVecBase3f::get_cell 0 1 362 10
/**
 *
 */
47
inline float LVecBase3f::get_cell(int i) const;

2303 5 get_x 0 4 3585 17 LVecBase3f::get_x 0 1 363 10
/**
 *
 */
43
inline float LVecBase3f::get_x(void) const;

2304 5 get_y 0 4 3585 17 LVecBase3f::get_y 0 1 364 10
/**
 *
 */
43
inline float LVecBase3f::get_y(void) const;

2305 5 get_z 0 4 3585 17 LVecBase3f::get_z 0 1 365 10
/**
 *
 */
43
inline float LVecBase3f::get_z(void) const;

2306 8 set_cell 0 4 3585 20 LVecBase3f::set_cell 0 1 366 10
/**
 *
 */
53
inline void LVecBase3f::set_cell(int i, float value);

2307 5 set_x 0 4 3585 17 LVecBase3f::set_x 0 1 367 10
/**
 *
 */
43
inline void LVecBase3f::set_x(float value);

2308 5 set_y 0 4 3585 17 LVecBase3f::set_y 0 1 368 10
/**
 *
 */
43
inline void LVecBase3f::set_y(float value);

2309 5 set_z 0 4 3585 17 LVecBase3f::set_z 0 1 369 10
/**
 *
 */
43
inline void LVecBase3f::set_z(float value);

2310 6 get_xy 0 4 3585 18 LVecBase3f::get_xy 0 1 370 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xy(void) const;

2311 6 get_xz 0 4 3585 18 LVecBase3f::get_xz 0 1 371 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xz(void) const;

2312 6 get_yz 0 4 3585 18 LVecBase3f::get_yz 0 1 372 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_yz(void) const;

2313 11 add_to_cell 0 4 3585 23 LVecBase3f::add_to_cell 0 1 373 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase3f::add_to_cell(int i, float value);

2314 5 add_x 0 4 3585 17 LVecBase3f::add_x 0 1 374 10
/**
 *
 */
43
inline void LVecBase3f::add_x(float value);

2315 5 add_y 0 4 3585 17 LVecBase3f::add_y 0 1 375 10
/**
 *
 */
43
inline void LVecBase3f::add_y(float value);

2316 5 add_z 0 4 3585 17 LVecBase3f::add_z 0 1 376 10
/**
 *
 */
43
inline void LVecBase3f::add_z(float value);

2317 8 get_data 0 4 3585 20 LVecBase3f::get_data 0 1 377 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase3f::get_data(void) const;

2318 18 get_num_components 0 4 3585 30 LVecBase3f::get_num_components 0 1 378 0
58
static constexpr int LVecBase3f::get_num_components(void);

2319 4 fill 0 4 3585 16 LVecBase3f::fill 0 1 379 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase3f::fill(float fill_value);

2320 3 set 0 4 3585 15 LVecBase3f::set 0 1 380 10
/**
 *
 */
55
inline void LVecBase3f::set(float x, float y, float z);

2321 3 dot 0 4 3585 15 LVecBase3f::dot 0 1 381 10
/**
 *
 */
60
inline float LVecBase3f::dot(LVecBase3f const &other) const;

2322 14 length_squared 0 4 3585 26 LVecBase3f::length_squared 0 1 382 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase3f::length_squared(void) const;

2323 6 length 0 4 3585 18 LVecBase3f::length 0 1 383 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase3f::length(void) const;

2324 9 normalize 0 4 3585 21 LVecBase3f::normalize 0 1 384 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3f::normalize(void);

2325 10 normalized 0 4 3585 22 LVecBase3f::normalized 0 1 385 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3f LVecBase3f::normalized(void) const;

2326 7 project 0 4 3585 19 LVecBase3f::project 0 1 386 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const;

2327 5 cross 0 4 3585 17 LVecBase3f::cross 0 1 387 10
/**
 *
 */
67
inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const;

2328 10 operator < 0 4 3585 22 LVecBase3f::operator < 0 1 388 0
66
inline bool LVecBase3f::operator <(LVecBase3f const &other) const;

2329 11 operator == 0 4 3585 23 LVecBase3f::operator == 0 1 389 0
67
inline bool LVecBase3f::operator ==(LVecBase3f const &other) const;

2330 11 operator != 0 4 3585 23 LVecBase3f::operator != 0 1 390 0
67
inline bool LVecBase3f::operator !=(LVecBase3f const &other) const;

2331 20 get_standardized_hpr 0 4 3585 32 LVecBase3f::get_standardized_hpr 0 1 391 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;

2332 10 compare_to 0 4 3585 22 LVecBase3f::compare_to 0 2 392 393 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase3f::compare_to(LVecBase3f const &other) const;
inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const;

2333 8 get_hash 0 4 3585 20 LVecBase3f::get_hash 0 2 394 395 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase3f::get_hash(void) const;
inline std::size_t LVecBase3f::get_hash(float threshold) const;

2334 8 add_hash 0 4 3585 20 LVecBase3f::add_hash 0 2 396 397 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;

2335 13 generate_hash 0 4 3585 25 LVecBase3f::generate_hash 0 2 398 399 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2336 10 operator - 0 68 3585 22 LVecBase3f::operator - 0 1 400 0
53
inline LVecBase3f LVecBase3f::operator -(void) const;

2337 10 operator + 0 4 3585 22 LVecBase3f::operator + 0 1 401 0
72
inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const;

2338 10 operator - 0 4 3585 22 LVecBase3f::operator - 0 1 402 0
72
inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const;

2339 10 operator * 0 4 3585 22 LVecBase3f::operator * 0 1 403 0
61
inline LVecBase3f LVecBase3f::operator *(float scalar) const;

2340 10 operator / 0 4 3585 22 LVecBase3f::operator / 0 1 404 0
61
inline LVecBase3f LVecBase3f::operator /(float scalar) const;

2341 11 operator += 0 4 3585 23 LVecBase3f::operator += 0 1 405 0
61
inline void LVecBase3f::operator +=(LVecBase3f const &other);

2342 11 operator -= 0 4 3585 23 LVecBase3f::operator -= 0 1 406 0
61
inline void LVecBase3f::operator -=(LVecBase3f const &other);

2343 11 operator *= 0 4 3585 23 LVecBase3f::operator *= 0 1 407 0
50
inline void LVecBase3f::operator *=(float scalar);

2344 11 operator /= 0 4 3585 23 LVecBase3f::operator /= 0 1 408 0
50
inline void LVecBase3f::operator /=(float scalar);

2345 18 componentwise_mult 0 4 3585 30 LVecBase3f::componentwise_mult 0 1 409 10
/**
 *
 */
68
inline void LVecBase3f::componentwise_mult(LVecBase3f const &other);

2346 7 __pow__ 0 4 3585 19 LVecBase3f::__pow__ 0 1 410 0
60
inline LVecBase3f LVecBase3f::__pow__(float exponent) const;

2347 8 __ipow__ 0 4 3585 20 LVecBase3f::__ipow__ 0 1 411 0
70
inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);

2348 9 __round__ 0 4 3585 21 LVecBase3f::__round__ 0 1 412 0
55
inline PyObject *LVecBase3f::__round__(PyObject *self);

2349 9 __floor__ 0 4 3585 21 LVecBase3f::__floor__ 0 1 413 0
55
inline PyObject *LVecBase3f::__floor__(PyObject *self);

2350 8 __ceil__ 0 4 3585 20 LVecBase3f::__ceil__ 0 1 414 0
54
inline PyObject *LVecBase3f::__ceil__(PyObject *self);

2351 4 fmax 0 4 3585 16 LVecBase3f::fmax 0 1 415 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const;

2352 4 fmin 0 4 3585 16 LVecBase3f::fmin 0 1 416 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const;

2353 10 cross_into 0 4 3585 22 LVecBase3f::cross_into 0 1 417 10
/**
 *
 */
60
inline void LVecBase3f::cross_into(LVecBase3f const &other);

2354 12 almost_equal 0 4 3585 24 LVecBase3f::almost_equal 0 2 418 419 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const;
inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const;

2355 6 output 0 4 3585 18 LVecBase3f::output 0 1 420 10
/**
 *
 */
56
inline void LVecBase3f::output(std::ostream &out) const;

2356 8 __repr__ 0 4 3585 20 LVecBase3f::__repr__ 0 1 421 0
52
inline std::string LVecBase3f::__repr__(void) const;

2357 20 write_datagram_fixed 0 4 3585 32 LVecBase3f::write_datagram_fixed 0 1 422 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const;

2358 19 read_datagram_fixed 0 4 3585 31 LVecBase3f::read_datagram_fixed 0 1 423 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source);

2359 14 write_datagram 0 4 3585 26 LVecBase3f::write_datagram 0 1 424 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3f::write_datagram(Datagram &destination) const;

2360 13 read_datagram 0 4 3585 25 LVecBase3f::read_datagram 0 1 425 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3f::read_datagram(DatagramIterator &source);

2361 14 get_class_type 0 4 3585 26 LVecBase3f::get_class_type 0 1 426 0
51
static TypeHandle LVecBase3f::get_class_type(void);

2362 11 ~LVecBase3f 0 4 3585 23 LVecBase3f::~LVecBase3f 0 0 0
30
LVecBase3f::~LVecBase3f(void);

2363 10 LVecBase3d 0 4 3587 22 LVecBase3d::LVecBase3d 0 5 427 428 429 430 431 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
283
inline LVecBase3d::LVecBase3d(void) = default;
inline LVecBase3d::LVecBase3d(double fill_value);
inline LVecBase3d::LVecBase3d(double x, double y, double z);
inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z);
inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default;

2364 12 operator new 0 4 3587 24 LVecBase3d::operator new 0 1 432 0
124
inline void *LVecBase3d::operator new(std::size_t size);
inline void *LVecBase3d::operator new(std::size_t size, void *ptr);

2365 15 operator delete 0 4 3587 27 LVecBase3d::operator delete 0 0 0
108
inline void LVecBase3d::operator delete(void *ptr);
inline void LVecBase3d::operator delete(void *, void *);

2366 12 validate_ptr 0 4 3587 24 LVecBase3d::validate_ptr 0 0 0
61
static inline bool LVecBase3d::validate_ptr(void const *ptr);

2367 10 operator = 0 4 3587 22 LVecBase3d::operator = 0 2 433 434 0
120
void LVecBase3d::operator =(LVecBase3d const &copy) = default;
void LVecBase3d::operator =(double fill_value) = default;

2368 4 zero 0 4 3587 16 LVecBase3d::zero 0 1 435 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3d const &LVecBase3d::zero(void);

2369 6 unit_x 0 4 3587 18 LVecBase3d::unit_x 0 1 436 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_x(void);

2370 6 unit_y 0 4 3587 18 LVecBase3d::unit_y 0 1 437 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_y(void);

2371 6 unit_z 0 4 3587 18 LVecBase3d::unit_z 0 1 438 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_z(void);

2372 10 __reduce__ 0 4 3587 22 LVecBase3d::__reduce__ 0 1 439 0
62
inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;

2373 11 __getattr__ 0 4 3587 23 LVecBase3d::__getattr__ 0 1 440 0
93
inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2374 11 __setattr__ 0 4 3587 23 LVecBase3d::__setattr__ 0 1 441 0
99
inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2375 11 operator [] 0 4 3587 23 LVecBase3d::operator [] 0 2 442 443 10
/**
 *
 */
98
inline double LVecBase3d::operator [](int i) const;
inline double &LVecBase3d::operator [](int i);

2376 4 size 0 4 3587 16 LVecBase3d::size 0 1 444 0
44
static constexpr int LVecBase3d::size(void);

2377 6 is_nan 0 4 3587 18 LVecBase3d::is_nan 0 1 445 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3d::is_nan(void) const;

2378 8 get_cell 0 4 3587 20 LVecBase3d::get_cell 0 1 446 10
/**
 *
 */
48
inline double LVecBase3d::get_cell(int i) const;

2379 5 get_x 0 4 3587 17 LVecBase3d::get_x 0 1 447 10
/**
 *
 */
44
inline double LVecBase3d::get_x(void) const;

2380 5 get_y 0 4 3587 17 LVecBase3d::get_y 0 1 448 10
/**
 *
 */
44
inline double LVecBase3d::get_y(void) const;

2381 5 get_z 0 4 3587 17 LVecBase3d::get_z 0 1 449 10
/**
 *
 */
44
inline double LVecBase3d::get_z(void) const;

2382 8 set_cell 0 4 3587 20 LVecBase3d::set_cell 0 1 450 10
/**
 *
 */
54
inline void LVecBase3d::set_cell(int i, double value);

2383 5 set_x 0 4 3587 17 LVecBase3d::set_x 0 1 451 10
/**
 *
 */
44
inline void LVecBase3d::set_x(double value);

2384 5 set_y 0 4 3587 17 LVecBase3d::set_y 0 1 452 10
/**
 *
 */
44
inline void LVecBase3d::set_y(double value);

2385 5 set_z 0 4 3587 17 LVecBase3d::set_z 0 1 453 10
/**
 *
 */
44
inline void LVecBase3d::set_z(double value);

2386 6 get_xy 0 4 3587 18 LVecBase3d::get_xy 0 1 454 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xy(void) const;

2387 6 get_xz 0 4 3587 18 LVecBase3d::get_xz 0 1 455 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xz(void) const;

2388 6 get_yz 0 4 3587 18 LVecBase3d::get_yz 0 1 456 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_yz(void) const;

2389 11 add_to_cell 0 4 3587 23 LVecBase3d::add_to_cell 0 1 457 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase3d::add_to_cell(int i, double value);

2390 5 add_x 0 4 3587 17 LVecBase3d::add_x 0 1 458 10
/**
 *
 */
44
inline void LVecBase3d::add_x(double value);

2391 5 add_y 0 4 3587 17 LVecBase3d::add_y 0 1 459 10
/**
 *
 */
44
inline void LVecBase3d::add_y(double value);

2392 5 add_z 0 4 3587 17 LVecBase3d::add_z 0 1 460 10
/**
 *
 */
44
inline void LVecBase3d::add_z(double value);

2393 8 get_data 0 4 3587 20 LVecBase3d::get_data 0 1 461 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase3d::get_data(void) const;

2394 18 get_num_components 0 4 3587 30 LVecBase3d::get_num_components 0 1 462 0
58
static constexpr int LVecBase3d::get_num_components(void);

2395 4 fill 0 4 3587 16 LVecBase3d::fill 0 1 463 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase3d::fill(double fill_value);

2396 3 set 0 4 3587 15 LVecBase3d::set 0 1 464 10
/**
 *
 */
58
inline void LVecBase3d::set(double x, double y, double z);

2397 3 dot 0 4 3587 15 LVecBase3d::dot 0 1 465 10
/**
 *
 */
61
inline double LVecBase3d::dot(LVecBase3d const &other) const;

2398 14 length_squared 0 4 3587 26 LVecBase3d::length_squared 0 1 466 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase3d::length_squared(void) const;

2399 6 length 0 4 3587 18 LVecBase3d::length 0 1 467 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase3d::length(void) const;

2400 9 normalize 0 4 3587 21 LVecBase3d::normalize 0 1 468 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3d::normalize(void);

2401 10 normalized 0 4 3587 22 LVecBase3d::normalized 0 1 469 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3d LVecBase3d::normalized(void) const;

2402 7 project 0 4 3587 19 LVecBase3d::project 0 1 470 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const;

2403 5 cross 0 4 3587 17 LVecBase3d::cross 0 1 471 10
/**
 *
 */
67
inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const;

2404 10 operator < 0 4 3587 22 LVecBase3d::operator < 0 1 472 0
66
inline bool LVecBase3d::operator <(LVecBase3d const &other) const;

2405 11 operator == 0 4 3587 23 LVecBase3d::operator == 0 1 473 0
67
inline bool LVecBase3d::operator ==(LVecBase3d const &other) const;

2406 11 operator != 0 4 3587 23 LVecBase3d::operator != 0 1 474 0
67
inline bool LVecBase3d::operator !=(LVecBase3d const &other) const;

2407 20 get_standardized_hpr 0 4 3587 32 LVecBase3d::get_standardized_hpr 0 1 475 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;

2408 10 compare_to 0 4 3587 22 LVecBase3d::compare_to 0 2 476 477 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase3d::compare_to(LVecBase3d const &other) const;
inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const;

2409 8 get_hash 0 4 3587 20 LVecBase3d::get_hash 0 2 478 479 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase3d::get_hash(void) const;
inline std::size_t LVecBase3d::get_hash(double threshold) const;

2410 8 add_hash 0 4 3587 20 LVecBase3d::add_hash 0 2 480 481 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;

2411 13 generate_hash 0 4 3587 25 LVecBase3d::generate_hash 0 2 482 483 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2412 10 operator - 0 68 3587 22 LVecBase3d::operator - 0 1 484 0
53
inline LVecBase3d LVecBase3d::operator -(void) const;

2413 10 operator + 0 4 3587 22 LVecBase3d::operator + 0 1 485 0
72
inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const;

2414 10 operator - 0 4 3587 22 LVecBase3d::operator - 0 1 486 0
72
inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const;

2415 10 operator * 0 4 3587 22 LVecBase3d::operator * 0 1 487 0
62
inline LVecBase3d LVecBase3d::operator *(double scalar) const;

2416 10 operator / 0 4 3587 22 LVecBase3d::operator / 0 1 488 0
62
inline LVecBase3d LVecBase3d::operator /(double scalar) const;

2417 11 operator += 0 4 3587 23 LVecBase3d::operator += 0 1 489 0
61
inline void LVecBase3d::operator +=(LVecBase3d const &other);

2418 11 operator -= 0 4 3587 23 LVecBase3d::operator -= 0 1 490 0
61
inline void LVecBase3d::operator -=(LVecBase3d const &other);

2419 11 operator *= 0 4 3587 23 LVecBase3d::operator *= 0 1 491 0
51
inline void LVecBase3d::operator *=(double scalar);

2420 11 operator /= 0 4 3587 23 LVecBase3d::operator /= 0 1 492 0
51
inline void LVecBase3d::operator /=(double scalar);

2421 18 componentwise_mult 0 4 3587 30 LVecBase3d::componentwise_mult 0 1 493 10
/**
 *
 */
68
inline void LVecBase3d::componentwise_mult(LVecBase3d const &other);

2422 7 __pow__ 0 4 3587 19 LVecBase3d::__pow__ 0 1 494 0
61
inline LVecBase3d LVecBase3d::__pow__(double exponent) const;

2423 8 __ipow__ 0 4 3587 20 LVecBase3d::__ipow__ 0 1 495 0
71
inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);

2424 9 __round__ 0 4 3587 21 LVecBase3d::__round__ 0 1 496 0
55
inline PyObject *LVecBase3d::__round__(PyObject *self);

2425 9 __floor__ 0 4 3587 21 LVecBase3d::__floor__ 0 1 497 0
55
inline PyObject *LVecBase3d::__floor__(PyObject *self);

2426 8 __ceil__ 0 4 3587 20 LVecBase3d::__ceil__ 0 1 498 0
54
inline PyObject *LVecBase3d::__ceil__(PyObject *self);

2427 4 fmax 0 4 3587 16 LVecBase3d::fmax 0 1 499 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const;

2428 4 fmin 0 4 3587 16 LVecBase3d::fmin 0 1 500 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const;

2429 10 cross_into 0 4 3587 22 LVecBase3d::cross_into 0 1 501 10
/**
 *
 */
60
inline void LVecBase3d::cross_into(LVecBase3d const &other);

2430 12 almost_equal 0 4 3587 24 LVecBase3d::almost_equal 0 2 502 503 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const;
inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const;

2431 6 output 0 4 3587 18 LVecBase3d::output 0 1 504 10
/**
 *
 */
56
inline void LVecBase3d::output(std::ostream &out) const;

2432 8 __repr__ 0 4 3587 20 LVecBase3d::__repr__ 0 1 505 0
52
inline std::string LVecBase3d::__repr__(void) const;

2433 20 write_datagram_fixed 0 4 3587 32 LVecBase3d::write_datagram_fixed 0 1 506 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const;

2434 19 read_datagram_fixed 0 4 3587 31 LVecBase3d::read_datagram_fixed 0 1 507 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source);

2435 14 write_datagram 0 4 3587 26 LVecBase3d::write_datagram 0 1 508 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3d::write_datagram(Datagram &destination) const;

2436 13 read_datagram 0 4 3587 25 LVecBase3d::read_datagram 0 1 509 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3d::read_datagram(DatagramIterator &source);

2437 14 get_class_type 0 4 3587 26 LVecBase3d::get_class_type 0 1 510 0
51
static TypeHandle LVecBase3d::get_class_type(void);

2438 11 ~LVecBase3d 0 4 3587 23 LVecBase3d::~LVecBase3d 0 0 0
30
LVecBase3d::~LVecBase3d(void);

2439 10 LVecBase3i 0 4 3589 22 LVecBase3i::LVecBase3i 0 5 511 512 513 514 515 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
268
inline LVecBase3i::LVecBase3i(void) = default;
inline LVecBase3i::LVecBase3i(int fill_value);
inline LVecBase3i::LVecBase3i(int x, int y, int z);
inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z);
inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default;

2440 12 operator new 0 4 3589 24 LVecBase3i::operator new 0 1 516 0
124
inline void *LVecBase3i::operator new(std::size_t size);
inline void *LVecBase3i::operator new(std::size_t size, void *ptr);

2441 15 operator delete 0 4 3589 27 LVecBase3i::operator delete 0 0 0
108
inline void LVecBase3i::operator delete(void *ptr);
inline void LVecBase3i::operator delete(void *, void *);

2442 12 validate_ptr 0 4 3589 24 LVecBase3i::validate_ptr 0 0 0
61
static inline bool LVecBase3i::validate_ptr(void const *ptr);

2443 10 operator = 0 4 3589 22 LVecBase3i::operator = 0 2 517 518 0
117
void LVecBase3i::operator =(LVecBase3i const &copy) = default;
void LVecBase3i::operator =(int fill_value) = default;

2444 4 zero 0 4 3589 16 LVecBase3i::zero 0 1 519 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3i const &LVecBase3i::zero(void);

2445 6 unit_x 0 4 3589 18 LVecBase3i::unit_x 0 1 520 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_x(void);

2446 6 unit_y 0 4 3589 18 LVecBase3i::unit_y 0 1 521 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_y(void);

2447 6 unit_z 0 4 3589 18 LVecBase3i::unit_z 0 1 522 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_z(void);

2448 10 __reduce__ 0 4 3589 22 LVecBase3i::__reduce__ 0 1 523 0
62
inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;

2449 11 __getattr__ 0 4 3589 23 LVecBase3i::__getattr__ 0 1 524 0
93
inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2450 11 __setattr__ 0 4 3589 23 LVecBase3i::__setattr__ 0 1 525 0
99
inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2451 11 operator [] 0 4 3589 23 LVecBase3i::operator [] 0 2 526 527 10
/**
 *
 */
92
inline int LVecBase3i::operator [](int i) const;
inline int &LVecBase3i::operator [](int i);

2452 4 size 0 4 3589 16 LVecBase3i::size 0 1 528 0
44
static constexpr int LVecBase3i::size(void);

2453 6 is_nan 0 4 3589 18 LVecBase3i::is_nan 0 1 529 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3i::is_nan(void) const;

2454 8 get_cell 0 4 3589 20 LVecBase3i::get_cell 0 1 530 10
/**
 *
 */
45
inline int LVecBase3i::get_cell(int i) const;

2455 5 get_x 0 4 3589 17 LVecBase3i::get_x 0 1 531 10
/**
 *
 */
41
inline int LVecBase3i::get_x(void) const;

2456 5 get_y 0 4 3589 17 LVecBase3i::get_y 0 1 532 10
/**
 *
 */
41
inline int LVecBase3i::get_y(void) const;

2457 5 get_z 0 4 3589 17 LVecBase3i::get_z 0 1 533 10
/**
 *
 */
41
inline int LVecBase3i::get_z(void) const;

2458 8 set_cell 0 4 3589 20 LVecBase3i::set_cell 0 1 534 10
/**
 *
 */
51
inline void LVecBase3i::set_cell(int i, int value);

2459 5 set_x 0 4 3589 17 LVecBase3i::set_x 0 1 535 10
/**
 *
 */
41
inline void LVecBase3i::set_x(int value);

2460 5 set_y 0 4 3589 17 LVecBase3i::set_y 0 1 536 10
/**
 *
 */
41
inline void LVecBase3i::set_y(int value);

2461 5 set_z 0 4 3589 17 LVecBase3i::set_z 0 1 537 10
/**
 *
 */
41
inline void LVecBase3i::set_z(int value);

2462 6 get_xy 0 4 3589 18 LVecBase3i::get_xy 0 1 538 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xy(void) const;

2463 6 get_xz 0 4 3589 18 LVecBase3i::get_xz 0 1 539 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xz(void) const;

2464 6 get_yz 0 4 3589 18 LVecBase3i::get_yz 0 1 540 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_yz(void) const;

2465 11 add_to_cell 0 4 3589 23 LVecBase3i::add_to_cell 0 1 541 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase3i::add_to_cell(int i, int value);

2466 5 add_x 0 4 3589 17 LVecBase3i::add_x 0 1 542 10
/**
 *
 */
41
inline void LVecBase3i::add_x(int value);

2467 5 add_y 0 4 3589 17 LVecBase3i::add_y 0 1 543 10
/**
 *
 */
41
inline void LVecBase3i::add_y(int value);

2468 5 add_z 0 4 3589 17 LVecBase3i::add_z 0 1 544 10
/**
 *
 */
41
inline void LVecBase3i::add_z(int value);

2469 8 get_data 0 4 3589 20 LVecBase3i::get_data 0 1 545 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase3i::get_data(void) const;

2470 18 get_num_components 0 4 3589 30 LVecBase3i::get_num_components 0 1 546 0
58
static constexpr int LVecBase3i::get_num_components(void);

2471 4 fill 0 4 3589 16 LVecBase3i::fill 0 1 547 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase3i::fill(int fill_value);

2472 3 set 0 4 3589 15 LVecBase3i::set 0 1 548 10
/**
 *
 */
49
inline void LVecBase3i::set(int x, int y, int z);

2473 3 dot 0 4 3589 15 LVecBase3i::dot 0 1 549 10
/**
 *
 */
58
inline int LVecBase3i::dot(LVecBase3i const &other) const;

2474 14 length_squared 0 4 3589 26 LVecBase3i::length_squared 0 1 550 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase3i::length_squared(void) const;

2475 5 cross 0 4 3589 17 LVecBase3i::cross 0 1 551 10
/**
 *
 */
67
inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const;

2476 10 operator < 0 4 3589 22 LVecBase3i::operator < 0 1 552 0
66
inline bool LVecBase3i::operator <(LVecBase3i const &other) const;

2477 11 operator == 0 4 3589 23 LVecBase3i::operator == 0 1 553 0
67
inline bool LVecBase3i::operator ==(LVecBase3i const &other) const;

2478 11 operator != 0 4 3589 23 LVecBase3i::operator != 0 1 554 0
67
inline bool LVecBase3i::operator !=(LVecBase3i const &other) const;

2479 10 compare_to 0 4 3589 22 LVecBase3i::compare_to 0 1 555 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase3i::compare_to(LVecBase3i const &other) const;

2480 8 get_hash 0 4 3589 20 LVecBase3i::get_hash 0 1 556 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase3i::get_hash(void) const;

2481 8 add_hash 0 4 3589 20 LVecBase3i::add_hash 0 1 557 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;

2482 13 generate_hash 0 4 3589 25 LVecBase3i::generate_hash 0 1 558 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase3i::generate_hash(ChecksumHashGenerator &hashgen) const;

2483 10 operator - 0 68 3589 22 LVecBase3i::operator - 0 1 559 0
53
inline LVecBase3i LVecBase3i::operator -(void) const;

2484 10 operator + 0 4 3589 22 LVecBase3i::operator + 0 1 560 0
72
inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const;

2485 10 operator - 0 4 3589 22 LVecBase3i::operator - 0 1 561 0
72
inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const;

2486 10 operator * 0 4 3589 22 LVecBase3i::operator * 0 1 562 0
59
inline LVecBase3i LVecBase3i::operator *(int scalar) const;

2487 10 operator / 0 4 3589 22 LVecBase3i::operator / 0 1 563 0
59
inline LVecBase3i LVecBase3i::operator /(int scalar) const;

2488 11 operator += 0 4 3589 23 LVecBase3i::operator += 0 1 564 0
61
inline void LVecBase3i::operator +=(LVecBase3i const &other);

2489 11 operator -= 0 4 3589 23 LVecBase3i::operator -= 0 1 565 0
61
inline void LVecBase3i::operator -=(LVecBase3i const &other);

2490 11 operator *= 0 4 3589 23 LVecBase3i::operator *= 0 1 566 0
48
inline void LVecBase3i::operator *=(int scalar);

2491 11 operator /= 0 4 3589 23 LVecBase3i::operator /= 0 1 567 0
48
inline void LVecBase3i::operator /=(int scalar);

2492 18 componentwise_mult 0 4 3589 30 LVecBase3i::componentwise_mult 0 1 568 10
/**
 *
 */
68
inline void LVecBase3i::componentwise_mult(LVecBase3i const &other);

2493 7 __pow__ 0 4 3589 19 LVecBase3i::__pow__ 0 1 569 0
58
inline LVecBase3i LVecBase3i::__pow__(int exponent) const;

2494 8 __ipow__ 0 4 3589 20 LVecBase3i::__ipow__ 0 1 570 0
68
inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);

2495 9 __round__ 0 4 3589 21 LVecBase3i::__round__ 0 1 571 0
55
inline PyObject *LVecBase3i::__round__(PyObject *self);

2496 9 __floor__ 0 4 3589 21 LVecBase3i::__floor__ 0 1 572 0
55
inline PyObject *LVecBase3i::__floor__(PyObject *self);

2497 8 __ceil__ 0 4 3589 20 LVecBase3i::__ceil__ 0 1 573 0
54
inline PyObject *LVecBase3i::__ceil__(PyObject *self);

2498 4 fmax 0 4 3589 16 LVecBase3i::fmax 0 1 574 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const;

2499 4 fmin 0 4 3589 16 LVecBase3i::fmin 0 1 575 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const;

2500 10 cross_into 0 4 3589 22 LVecBase3i::cross_into 0 1 576 10
/**
 *
 */
60
inline void LVecBase3i::cross_into(LVecBase3i const &other);

2501 12 almost_equal 0 4 3589 24 LVecBase3i::almost_equal 0 2 577 578 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const;
inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const;

2502 6 output 0 4 3589 18 LVecBase3i::output 0 1 579 10
/**
 *
 */
56
inline void LVecBase3i::output(std::ostream &out) const;

2503 8 __repr__ 0 4 3589 20 LVecBase3i::__repr__ 0 1 580 0
52
inline std::string LVecBase3i::__repr__(void) const;

2504 20 write_datagram_fixed 0 4 3589 32 LVecBase3i::write_datagram_fixed 0 1 581 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const;

2505 19 read_datagram_fixed 0 4 3589 31 LVecBase3i::read_datagram_fixed 0 1 582 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source);

2506 14 write_datagram 0 4 3589 26 LVecBase3i::write_datagram 0 1 583 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3i::write_datagram(Datagram &destination) const;

2507 13 read_datagram 0 4 3589 25 LVecBase3i::read_datagram 0 1 584 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3i::read_datagram(DatagramIterator &source);

2508 14 get_class_type 0 4 3589 26 LVecBase3i::get_class_type 0 1 585 0
51
static TypeHandle LVecBase3i::get_class_type(void);

2509 11 ~LVecBase3i 0 4 3589 23 LVecBase3i::~LVecBase3i 0 0 0
30
LVecBase3i::~LVecBase3i(void);

2510 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1907 0
53
CoordinateSystem get_default_coordinate_system(void);

2511 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1908 0
72
CoordinateSystem parse_coordinate_system_string(std::string const &str);

2512 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1909 0
58
std::string format_coordinate_system(CoordinateSystem cs);

2513 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1910 0
57
bool is_right_handed(CoordinateSystem cs = ::CS_default);

2514 9 LVector3f 0 4 3592 20 LVector3f::LVector3f 0 6 586 587 588 589 590 591 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
320
inline LVector3f::LVector3f(void) = default;
inline LVector3f::LVector3f(LVecBase3f const &copy);
inline LVector3f::LVector3f(float fill_value);
inline LVector3f::LVector3f(float x, float y, float z);
inline LVector3f::LVector3f(LVecBase2f const &copy, float z);
inline LVector3f::LVector3f(LVector3f const &) = default;

2515 11 __getattr__ 0 4 3592 22 LVector3f::__getattr__ 0 1 592 0
92
inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2516 11 __setattr__ 0 4 3592 22 LVector3f::__setattr__ 0 1 593 0
98
inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2517 4 zero 0 4 3592 15 LVector3f::zero 0 1 594 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3f const &LVector3f::zero(void);

2518 6 unit_x 0 4 3592 17 LVector3f::unit_x 0 1 595 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3f const &LVector3f::unit_x(void);

2519 6 unit_y 0 4 3592 17 LVector3f::unit_y 0 1 596 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3f const &LVector3f::unit_y(void);

2520 6 unit_z 0 4 3592 17 LVector3f::unit_z 0 1 597 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3f const &LVector3f::unit_z(void);

2521 6 get_xy 0 4 3592 17 LVector3f::get_xy 0 1 598 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_xy(void) const;

2522 6 get_xz 0 4 3592 17 LVector3f::get_xz 0 1 599 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2f LVector3f::get_xz(void) const;

2523 6 get_yz 0 4 3592 17 LVector3f::get_yz 0 1 600 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_yz(void) const;

2524 10 operator - 0 68 3592 21 LVector3f::operator - 0 1 601 0
51
inline LVector3f LVector3f::operator -(void) const;

2525 10 operator + 0 4 3592 21 LVector3f::operator + 0 2 602 603 0
141
inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator +(LVector3f const &other) const;

2526 10 operator - 0 4 3592 21 LVector3f::operator - 0 2 604 605 0
141
inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator -(LVector3f const &other) const;

2527 5 cross 0 4 3592 16 LVector3f::cross 0 1 606 10
/**
 *
 */
65
inline LVector3f LVector3f::cross(LVecBase3f const &other) const;

2528 10 normalized 0 4 3592 21 LVector3f::normalized 0 1 607 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3f LVector3f::normalized(void) const;

2529 7 project 0 4 3592 18 LVector3f::project 0 1 608 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3f LVector3f::project(LVecBase3f const &onto) const;

2530 9 angle_rad 0 4 3592 20 LVector3f::angle_rad 0 1 609 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_rad(LVector3f const &other) const;

2531 9 angle_deg 0 4 3592 20 LVector3f::angle_deg 0 1 610 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_deg(LVector3f const &other) const;

2532 16 signed_angle_rad 0 4 3592 27 LVector3f::signed_angle_rad 0 1 611 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const;

2533 16 signed_angle_deg 0 4 3592 27 LVector3f::signed_angle_deg 0 1 612 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const;

2534 18 relative_angle_rad 0 4 3592 29 LVector3f::relative_angle_rad 0 1 613 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_rad(LVector3f const &other) const;

2535 18 relative_angle_deg 0 4 3592 29 LVector3f::relative_angle_deg 0 1 614 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_deg(LVector3f const &other) const;

2536 10 operator * 0 4 3592 21 LVector3f::operator * 0 1 615 0
59
inline LVector3f LVector3f::operator *(float scalar) const;

2537 10 operator / 0 4 3592 21 LVector3f::operator / 0 1 616 0
59
inline LVector3f LVector3f::operator /(float scalar) const;

2538 2 up 0 4 3592 13 LVector3f::up 0 1 617 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);

2539 5 right 0 4 3592 16 LVector3f::right 0 1 618 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);

2540 7 forward 0 4 3592 18 LVector3f::forward 0 1 619 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);

2541 4 down 0 4 3592 15 LVector3f::down 0 1 620 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);

2542 4 left 0 4 3592 15 LVector3f::left 0 1 621 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);

2543 4 back 0 4 3592 15 LVector3f::back 0 1 622 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);

2544 3 rfu 0 4 3592 14 LVector3f::rfu 0 1 623 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
109
static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2545 8 __repr__ 0 4 3592 19 LVector3f::__repr__ 0 1 624 0
51
inline std::string LVector3f::__repr__(void) const;

2546 14 get_class_type 0 4 3592 25 LVector3f::get_class_type 0 1 625 0
50
static TypeHandle LVector3f::get_class_type(void);

2547 10 ~LVector3f 0 4 3592 21 LVector3f::~LVector3f 0 0 0
28
LVector3f::~LVector3f(void);

2548 9 LVector3d 0 4 3593 20 LVector3d::LVector3d 0 6 626 627 628 629 630 631 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
325
inline LVector3d::LVector3d(void) = default;
inline LVector3d::LVector3d(LVecBase3d const &copy);
inline LVector3d::LVector3d(double fill_value);
inline LVector3d::LVector3d(double x, double y, double z);
inline LVector3d::LVector3d(LVecBase2d const &copy, double z);
inline LVector3d::LVector3d(LVector3d const &) = default;

2549 11 __getattr__ 0 4 3593 22 LVector3d::__getattr__ 0 1 632 0
92
inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2550 11 __setattr__ 0 4 3593 22 LVector3d::__setattr__ 0 1 633 0
98
inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2551 4 zero 0 4 3593 15 LVector3d::zero 0 1 634 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3d const &LVector3d::zero(void);

2552 6 unit_x 0 4 3593 17 LVector3d::unit_x 0 1 635 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3d const &LVector3d::unit_x(void);

2553 6 unit_y 0 4 3593 17 LVector3d::unit_y 0 1 636 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3d const &LVector3d::unit_y(void);

2554 6 unit_z 0 4 3593 17 LVector3d::unit_z 0 1 637 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3d const &LVector3d::unit_z(void);

2555 6 get_xy 0 4 3593 17 LVector3d::get_xy 0 1 638 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_xy(void) const;

2556 6 get_xz 0 4 3593 17 LVector3d::get_xz 0 1 639 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2d LVector3d::get_xz(void) const;

2557 6 get_yz 0 4 3593 17 LVector3d::get_yz 0 1 640 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_yz(void) const;

2558 10 operator - 0 68 3593 21 LVector3d::operator - 0 1 641 0
51
inline LVector3d LVector3d::operator -(void) const;

2559 10 operator + 0 4 3593 21 LVector3d::operator + 0 2 642 643 0
141
inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator +(LVector3d const &other) const;

2560 10 operator - 0 4 3593 21 LVector3d::operator - 0 2 644 645 0
141
inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator -(LVector3d const &other) const;

2561 5 cross 0 4 3593 16 LVector3d::cross 0 1 646 10
/**
 *
 */
65
inline LVector3d LVector3d::cross(LVecBase3d const &other) const;

2562 10 normalized 0 4 3593 21 LVector3d::normalized 0 1 647 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3d LVector3d::normalized(void) const;

2563 7 project 0 4 3593 18 LVector3d::project 0 1 648 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3d LVector3d::project(LVecBase3d const &onto) const;

2564 9 angle_rad 0 4 3593 20 LVector3d::angle_rad 0 1 649 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_rad(LVector3d const &other) const;

2565 9 angle_deg 0 4 3593 20 LVector3d::angle_deg 0 1 650 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_deg(LVector3d const &other) const;

2566 16 signed_angle_rad 0 4 3593 27 LVector3d::signed_angle_rad 0 1 651 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const;

2567 16 signed_angle_deg 0 4 3593 27 LVector3d::signed_angle_deg 0 1 652 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const;

2568 18 relative_angle_rad 0 4 3593 29 LVector3d::relative_angle_rad 0 1 653 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_rad(LVector3d const &other) const;

2569 18 relative_angle_deg 0 4 3593 29 LVector3d::relative_angle_deg 0 1 654 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_deg(LVector3d const &other) const;

2570 10 operator * 0 4 3593 21 LVector3d::operator * 0 1 655 0
60
inline LVector3d LVector3d::operator *(double scalar) const;

2571 10 operator / 0 4 3593 21 LVector3d::operator / 0 1 656 0
60
inline LVector3d LVector3d::operator /(double scalar) const;

2572 2 up 0 4 3593 13 LVector3d::up 0 1 657 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);

2573 5 right 0 4 3593 16 LVector3d::right 0 1 658 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);

2574 7 forward 0 4 3593 18 LVector3d::forward 0 1 659 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);

2575 4 down 0 4 3593 15 LVector3d::down 0 1 660 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);

2576 4 left 0 4 3593 15 LVector3d::left 0 1 661 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);

2577 4 back 0 4 3593 15 LVector3d::back 0 1 662 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);

2578 3 rfu 0 4 3593 14 LVector3d::rfu 0 1 663 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
112
static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2579 8 __repr__ 0 4 3593 19 LVector3d::__repr__ 0 1 664 0
51
inline std::string LVector3d::__repr__(void) const;

2580 14 get_class_type 0 4 3593 25 LVector3d::get_class_type 0 1 665 0
50
static TypeHandle LVector3d::get_class_type(void);

2581 10 ~LVector3d 0 4 3593 21 LVector3d::~LVector3d 0 0 0
28
LVector3d::~LVector3d(void);

2582 9 LVector3i 0 4 3594 20 LVector3i::LVector3i 0 6 666 667 668 669 670 671 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LVector3i::LVector3i(void) = default;
inline LVector3i::LVector3i(LVecBase3i const &copy);
inline LVector3i::LVector3i(int fill_value);
inline LVector3i::LVector3i(int x, int y, int z);
inline LVector3i::LVector3i(LVecBase2i const &copy, int z);
inline LVector3i::LVector3i(LVector3i const &) = default;

2583 11 __getattr__ 0 4 3594 22 LVector3i::__getattr__ 0 1 672 0
92
inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2584 11 __setattr__ 0 4 3594 22 LVector3i::__setattr__ 0 1 673 0
98
inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2585 4 zero 0 4 3594 15 LVector3i::zero 0 1 674 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3i const &LVector3i::zero(void);

2586 6 unit_x 0 4 3594 17 LVector3i::unit_x 0 1 675 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3i const &LVector3i::unit_x(void);

2587 6 unit_y 0 4 3594 17 LVector3i::unit_y 0 1 676 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3i const &LVector3i::unit_y(void);

2588 6 unit_z 0 4 3594 17 LVector3i::unit_z 0 1 677 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3i const &LVector3i::unit_z(void);

2589 6 get_xy 0 4 3594 17 LVector3i::get_xy 0 1 678 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_xy(void) const;

2590 6 get_xz 0 4 3594 17 LVector3i::get_xz 0 1 679 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2i LVector3i::get_xz(void) const;

2591 6 get_yz 0 4 3594 17 LVector3i::get_yz 0 1 680 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_yz(void) const;

2592 10 operator - 0 68 3594 21 LVector3i::operator - 0 1 681 0
51
inline LVector3i LVector3i::operator -(void) const;

2593 10 operator + 0 4 3594 21 LVector3i::operator + 0 2 682 683 0
141
inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator +(LVector3i const &other) const;

2594 10 operator - 0 4 3594 21 LVector3i::operator - 0 2 684 685 0
141
inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator -(LVector3i const &other) const;

2595 5 cross 0 4 3594 16 LVector3i::cross 0 1 686 10
/**
 *
 */
65
inline LVector3i LVector3i::cross(LVecBase3i const &other) const;

2596 10 operator * 0 4 3594 21 LVector3i::operator * 0 1 687 0
57
inline LVector3i LVector3i::operator *(int scalar) const;

2597 10 operator / 0 4 3594 21 LVector3i::operator / 0 1 688 0
57
inline LVector3i LVector3i::operator /(int scalar) const;

2598 2 up 0 4 3594 13 LVector3i::up 0 1 689 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);

2599 5 right 0 4 3594 16 LVector3i::right 0 1 690 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);

2600 7 forward 0 4 3594 18 LVector3i::forward 0 1 691 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);

2601 4 down 0 4 3594 15 LVector3i::down 0 1 692 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);

2602 4 left 0 4 3594 15 LVector3i::left 0 1 693 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);

2603 4 back 0 4 3594 15 LVector3i::back 0 1 694 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);

2604 3 rfu 0 4 3594 14 LVector3i::rfu 0 1 695 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
103
static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2605 8 __repr__ 0 4 3594 19 LVector3i::__repr__ 0 1 696 0
51
inline std::string LVector3i::__repr__(void) const;

2606 14 get_class_type 0 4 3594 25 LVector3i::get_class_type 0 1 697 0
50
static TypeHandle LVector3i::get_class_type(void);

2607 10 ~LVector3i 0 4 3594 21 LVector3i::~LVector3i 0 0 0
28
LVector3i::~LVector3i(void);

2608 8 LPoint3f 0 4 3595 18 LPoint3f::LPoint3f 0 6 698 699 700 701 702 703 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
307
inline LPoint3f::LPoint3f(void) = default;
inline LPoint3f::LPoint3f(LVecBase3f const &copy);
inline LPoint3f::LPoint3f(float fill_value);
inline LPoint3f::LPoint3f(float x, float y, float z);
inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z);
inline LPoint3f::LPoint3f(LPoint3f const &) = default;

2609 11 __getattr__ 0 4 3595 21 LPoint3f::__getattr__ 0 1 704 0
91
inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2610 11 __setattr__ 0 4 3595 21 LPoint3f::__setattr__ 0 1 705 0
97
inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2611 4 zero 0 4 3595 14 LPoint3f::zero 0 1 706 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3f const &LPoint3f::zero(void);

2612 6 unit_x 0 4 3595 16 LPoint3f::unit_x 0 1 707 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3f const &LPoint3f::unit_x(void);

2613 6 unit_y 0 4 3595 16 LPoint3f::unit_y 0 1 708 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3f const &LPoint3f::unit_y(void);

2614 6 unit_z 0 4 3595 16 LPoint3f::unit_z 0 1 709 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3f const &LPoint3f::unit_z(void);

2615 6 get_xy 0 4 3595 16 LPoint3f::get_xy 0 1 710 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_xy(void) const;

2616 6 get_xz 0 4 3595 16 LPoint3f::get_xz 0 1 711 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2f LPoint3f::get_xz(void) const;

2617 6 get_yz 0 4 3595 16 LPoint3f::get_yz 0 1 712 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_yz(void) const;

2618 10 operator - 0 68 3595 20 LPoint3f::operator - 0 1 713 0
49
inline LPoint3f LPoint3f::operator -(void) const;

2619 10 operator + 0 4 3595 20 LPoint3f::operator + 0 2 714 715 0
138
inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const;
inline LPoint3f LPoint3f::operator +(LVector3f const &other) const;

2620 10 operator - 0 4 3595 20 LPoint3f::operator - 0 3 716 717 718 0
206
inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const;
inline LVector3f LPoint3f::operator -(LPoint3f const &other) const;
inline LPoint3f LPoint3f::operator -(LVector3f const &other) const;

2621 5 cross 0 4 3595 15 LPoint3f::cross 0 1 719 10
/**
 *
 */
63
inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const;

2622 10 normalized 0 4 3595 20 LPoint3f::normalized 0 1 720 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3f LPoint3f::normalized(void) const;

2623 7 project 0 4 3595 17 LPoint3f::project 0 1 721 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const;

2624 10 operator * 0 4 3595 20 LPoint3f::operator * 0 1 722 0
57
inline LPoint3f LPoint3f::operator *(float scalar) const;

2625 10 operator / 0 4 3595 20 LPoint3f::operator / 0 1 723 0
57
inline LPoint3f LPoint3f::operator /(float scalar) const;

2626 6 origin 0 4 3595 16 LPoint3f::origin 0 1 724 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default);

2627 3 rfu 0 4 3595 13 LPoint3f::rfu 0 1 725 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
107
static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2628 8 __repr__ 0 4 3595 18 LPoint3f::__repr__ 0 1 726 0
50
inline std::string LPoint3f::__repr__(void) const;

2629 14 get_class_type 0 4 3595 24 LPoint3f::get_class_type 0 1 727 0
49
static TypeHandle LPoint3f::get_class_type(void);

2630 9 ~LPoint3f 0 4 3595 19 LPoint3f::~LPoint3f 0 0 0
26
LPoint3f::~LPoint3f(void);

2631 8 LPoint3d 0 4 3596 18 LPoint3d::LPoint3d 0 6 728 729 730 731 732 733 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
312
inline LPoint3d::LPoint3d(void) = default;
inline LPoint3d::LPoint3d(LVecBase3d const &copy);
inline LPoint3d::LPoint3d(double fill_value);
inline LPoint3d::LPoint3d(double x, double y, double z);
inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z);
inline LPoint3d::LPoint3d(LPoint3d const &) = default;

2632 11 __getattr__ 0 4 3596 21 LPoint3d::__getattr__ 0 1 734 0
91
inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2633 11 __setattr__ 0 4 3596 21 LPoint3d::__setattr__ 0 1 735 0
97
inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2634 4 zero 0 4 3596 14 LPoint3d::zero 0 1 736 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3d const &LPoint3d::zero(void);

2635 6 unit_x 0 4 3596 16 LPoint3d::unit_x 0 1 737 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3d const &LPoint3d::unit_x(void);

2636 6 unit_y 0 4 3596 16 LPoint3d::unit_y 0 1 738 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3d const &LPoint3d::unit_y(void);

2637 6 unit_z 0 4 3596 16 LPoint3d::unit_z 0 1 739 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3d const &LPoint3d::unit_z(void);

2638 6 get_xy 0 4 3596 16 LPoint3d::get_xy 0 1 740 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_xy(void) const;

2639 6 get_xz 0 4 3596 16 LPoint3d::get_xz 0 1 741 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2d LPoint3d::get_xz(void) const;

2640 6 get_yz 0 4 3596 16 LPoint3d::get_yz 0 1 742 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_yz(void) const;

2641 10 operator - 0 68 3596 20 LPoint3d::operator - 0 1 743 0
49
inline LPoint3d LPoint3d::operator -(void) const;

2642 10 operator + 0 4 3596 20 LPoint3d::operator + 0 2 744 745 0
138
inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const;
inline LPoint3d LPoint3d::operator +(LVector3d const &other) const;

2643 10 operator - 0 4 3596 20 LPoint3d::operator - 0 3 746 747 748 0
206
inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const;
inline LVector3d LPoint3d::operator -(LPoint3d const &other) const;
inline LPoint3d LPoint3d::operator -(LVector3d const &other) const;

2644 5 cross 0 4 3596 15 LPoint3d::cross 0 1 749 10
/**
 *
 */
63
inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const;

2645 10 normalized 0 4 3596 20 LPoint3d::normalized 0 1 750 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3d LPoint3d::normalized(void) const;

2646 7 project 0 4 3596 17 LPoint3d::project 0 1 751 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const;

2647 10 operator * 0 4 3596 20 LPoint3d::operator * 0 1 752 0
58
inline LPoint3d LPoint3d::operator *(double scalar) const;

2648 10 operator / 0 4 3596 20 LPoint3d::operator / 0 1 753 0
58
inline LPoint3d LPoint3d::operator /(double scalar) const;

2649 6 origin 0 4 3596 16 LPoint3d::origin 0 1 754 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default);

2650 3 rfu 0 4 3596 13 LPoint3d::rfu 0 1 755 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
110
static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2651 8 __repr__ 0 4 3596 18 LPoint3d::__repr__ 0 1 756 0
50
inline std::string LPoint3d::__repr__(void) const;

2652 14 get_class_type 0 4 3596 24 LPoint3d::get_class_type 0 1 757 0
49
static TypeHandle LPoint3d::get_class_type(void);

2653 9 ~LPoint3d 0 4 3596 19 LPoint3d::~LPoint3d 0 0 0
26
LPoint3d::~LPoint3d(void);

2654 8 LPoint3i 0 4 3597 18 LPoint3i::LPoint3i 0 6 758 759 760 761 762 763 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
297
inline LPoint3i::LPoint3i(void) = default;
inline LPoint3i::LPoint3i(LVecBase3i const &copy);
inline LPoint3i::LPoint3i(int fill_value);
inline LPoint3i::LPoint3i(int x, int y, int z);
inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z);
inline LPoint3i::LPoint3i(LPoint3i const &) = default;

2655 11 __getattr__ 0 4 3597 21 LPoint3i::__getattr__ 0 1 764 0
91
inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2656 11 __setattr__ 0 4 3597 21 LPoint3i::__setattr__ 0 1 765 0
97
inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2657 4 zero 0 4 3597 14 LPoint3i::zero 0 1 766 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3i const &LPoint3i::zero(void);

2658 6 unit_x 0 4 3597 16 LPoint3i::unit_x 0 1 767 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3i const &LPoint3i::unit_x(void);

2659 6 unit_y 0 4 3597 16 LPoint3i::unit_y 0 1 768 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3i const &LPoint3i::unit_y(void);

2660 6 unit_z 0 4 3597 16 LPoint3i::unit_z 0 1 769 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3i const &LPoint3i::unit_z(void);

2661 6 get_xy 0 4 3597 16 LPoint3i::get_xy 0 1 770 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_xy(void) const;

2662 6 get_xz 0 4 3597 16 LPoint3i::get_xz 0 1 771 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2i LPoint3i::get_xz(void) const;

2663 6 get_yz 0 4 3597 16 LPoint3i::get_yz 0 1 772 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_yz(void) const;

2664 10 operator - 0 68 3597 20 LPoint3i::operator - 0 1 773 0
49
inline LPoint3i LPoint3i::operator -(void) const;

2665 10 operator + 0 4 3597 20 LPoint3i::operator + 0 2 774 775 0
138
inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const;
inline LPoint3i LPoint3i::operator +(LVector3i const &other) const;

2666 10 operator - 0 4 3597 20 LPoint3i::operator - 0 3 776 777 778 0
206
inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const;
inline LVector3i LPoint3i::operator -(LPoint3i const &other) const;
inline LPoint3i LPoint3i::operator -(LVector3i const &other) const;

2667 5 cross 0 4 3597 15 LPoint3i::cross 0 1 779 10
/**
 *
 */
63
inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const;

2668 10 operator * 0 4 3597 20 LPoint3i::operator * 0 1 780 0
55
inline LPoint3i LPoint3i::operator *(int scalar) const;

2669 10 operator / 0 4 3597 20 LPoint3i::operator / 0 1 781 0
55
inline LPoint3i LPoint3i::operator /(int scalar) const;

2670 6 origin 0 4 3597 16 LPoint3i::origin 0 1 782 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default);

2671 3 rfu 0 4 3597 13 LPoint3i::rfu 0 1 783 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
101
static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2672 8 __repr__ 0 4 3597 18 LPoint3i::__repr__ 0 1 784 0
50
inline std::string LPoint3i::__repr__(void) const;

2673 14 get_class_type 0 4 3597 24 LPoint3i::get_class_type 0 1 785 0
49
static TypeHandle LPoint3i::get_class_type(void);

2674 9 ~LPoint3i 0 4 3597 19 LPoint3i::~LPoint3i 0 0 0
26
LPoint3i::~LPoint3i(void);

2675 10 LVecBase4f 0 4 3598 22 LVecBase4f::LVecBase4f 0 8 786 787 788 789 790 791 792 793 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
461
inline LVecBase4f::LVecBase4f(void) = default;
inline LVecBase4f::LVecBase4f(float fill_value);
inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);
inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy);
inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w);
inline LVecBase4f::LVecBase4f(LPoint3f const &point);
inline LVecBase4f::LVecBase4f(LVector3f const &vector);
inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default;

2676 12 operator new 0 4 3598 24 LVecBase4f::operator new 0 1 794 0
124
inline void *LVecBase4f::operator new(std::size_t size);
inline void *LVecBase4f::operator new(std::size_t size, void *ptr);

2677 15 operator delete 0 4 3598 27 LVecBase4f::operator delete 0 0 0
108
inline void LVecBase4f::operator delete(void *ptr);
inline void LVecBase4f::operator delete(void *, void *);

2678 12 validate_ptr 0 4 3598 24 LVecBase4f::validate_ptr 0 0 0
61
static inline bool LVecBase4f::validate_ptr(void const *ptr);

2679 10 operator = 0 4 3598 22 LVecBase4f::operator = 0 2 795 796 0
119
void LVecBase4f::operator =(LVecBase4f const &copy) = default;
void LVecBase4f::operator =(float fill_value) = default;

2680 4 zero 0 4 3598 16 LVecBase4f::zero 0 1 797 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4f const &LVecBase4f::zero(void);

2681 6 unit_x 0 4 3598 18 LVecBase4f::unit_x 0 1 798 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_x(void);

2682 6 unit_y 0 4 3598 18 LVecBase4f::unit_y 0 1 799 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_y(void);

2683 6 unit_z 0 4 3598 18 LVecBase4f::unit_z 0 1 800 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_z(void);

2684 6 unit_w 0 4 3598 18 LVecBase4f::unit_w 0 1 801 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_w(void);

2685 10 __reduce__ 0 4 3598 22 LVecBase4f::__reduce__ 0 1 802 0
62
inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;

2686 11 __getattr__ 0 4 3598 23 LVecBase4f::__getattr__ 0 1 803 0
93
inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2687 11 __setattr__ 0 4 3598 23 LVecBase4f::__setattr__ 0 1 804 0
99
inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2688 11 operator [] 0 4 3598 23 LVecBase4f::operator [] 0 2 805 806 10
/**
 *
 */
96
inline float LVecBase4f::operator [](int i) const;
inline float &LVecBase4f::operator [](int i);

2689 4 size 0 4 3598 16 LVecBase4f::size 0 1 807 0
44
static constexpr int LVecBase4f::size(void);

2690 6 is_nan 0 4 3598 18 LVecBase4f::is_nan 0 1 808 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4f::is_nan(void) const;

2691 8 get_cell 0 4 3598 20 LVecBase4f::get_cell 0 1 809 10
/**
 *
 */
47
inline float LVecBase4f::get_cell(int i) const;

2692 8 set_cell 0 4 3598 20 LVecBase4f::set_cell 0 1 810 10
/**
 *
 */
53
inline void LVecBase4f::set_cell(int i, float value);

2693 5 get_x 0 4 3598 17 LVecBase4f::get_x 0 1 811 10
/**
 *
 */
43
inline float LVecBase4f::get_x(void) const;

2694 5 get_y 0 4 3598 17 LVecBase4f::get_y 0 1 812 10
/**
 *
 */
43
inline float LVecBase4f::get_y(void) const;

2695 5 get_z 0 4 3598 17 LVecBase4f::get_z 0 1 813 10
/**
 *
 */
43
inline float LVecBase4f::get_z(void) const;

2696 5 get_w 0 4 3598 17 LVecBase4f::get_w 0 1 814 10
/**
 *
 */
43
inline float LVecBase4f::get_w(void) const;

2697 7 get_xyz 0 4 3598 19 LVecBase4f::get_xyz 0 1 815 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3f LVecBase4f::get_xyz(void) const;

2698 6 get_xy 0 4 3598 18 LVecBase4f::get_xy 0 1 816 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2f LVecBase4f::get_xy(void) const;

2699 5 set_x 0 4 3598 17 LVecBase4f::set_x 0 1 817 10
/**
 *
 */
43
inline void LVecBase4f::set_x(float value);

2700 5 set_y 0 4 3598 17 LVecBase4f::set_y 0 1 818 10
/**
 *
 */
43
inline void LVecBase4f::set_y(float value);

2701 5 set_z 0 4 3598 17 LVecBase4f::set_z 0 1 819 10
/**
 *
 */
43
inline void LVecBase4f::set_z(float value);

2702 5 set_w 0 4 3598 17 LVecBase4f::set_w 0 1 820 10
/**
 *
 */
43
inline void LVecBase4f::set_w(float value);

2703 11 add_to_cell 0 4 3598 23 LVecBase4f::add_to_cell 0 1 821 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase4f::add_to_cell(int i, float value);

2704 5 add_x 0 4 3598 17 LVecBase4f::add_x 0 1 822 10
/**
 *
 */
43
inline void LVecBase4f::add_x(float value);

2705 5 add_y 0 4 3598 17 LVecBase4f::add_y 0 1 823 10
/**
 *
 */
43
inline void LVecBase4f::add_y(float value);

2706 5 add_z 0 4 3598 17 LVecBase4f::add_z 0 1 824 10
/**
 *
 */
43
inline void LVecBase4f::add_z(float value);

2707 5 add_w 0 4 3598 17 LVecBase4f::add_w 0 1 825 10
/**
 *
 */
43
inline void LVecBase4f::add_w(float value);

2708 8 get_data 0 4 3598 20 LVecBase4f::get_data 0 1 826 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase4f::get_data(void) const;

2709 18 get_num_components 0 4 3598 30 LVecBase4f::get_num_components 0 1 827 0
58
static constexpr int LVecBase4f::get_num_components(void);

2710 12 extract_data 0 4 3598 24 LVecBase4f::extract_data 0 0 0
46
inline void LVecBase4f::extract_data(float *);

2711 4 fill 0 4 3598 16 LVecBase4f::fill 0 1 828 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase4f::fill(float fill_value);

2712 3 set 0 4 3598 15 LVecBase4f::set 0 1 829 10
/**
 *
 */
64
inline void LVecBase4f::set(float x, float y, float z, float w);

2713 3 dot 0 4 3598 15 LVecBase4f::dot 0 1 830 10
/**
 *
 */
60
inline float LVecBase4f::dot(LVecBase4f const &other) const;

2714 14 length_squared 0 4 3598 26 LVecBase4f::length_squared 0 1 831 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase4f::length_squared(void) const;

2715 6 length 0 4 3598 18 LVecBase4f::length 0 1 832 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase4f::length(void) const;

2716 9 normalize 0 4 3598 21 LVecBase4f::normalize 0 1 833 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4f::normalize(void);

2717 10 normalized 0 4 3598 22 LVecBase4f::normalized 0 1 834 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4f LVecBase4f::normalized(void) const;

2718 7 project 0 4 3598 19 LVecBase4f::project 0 1 835 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const;

2719 10 operator < 0 4 3598 22 LVecBase4f::operator < 0 1 836 0
66
inline bool LVecBase4f::operator <(LVecBase4f const &other) const;

2720 11 operator == 0 4 3598 23 LVecBase4f::operator == 0 1 837 0
67
inline bool LVecBase4f::operator ==(LVecBase4f const &other) const;

2721 11 operator != 0 4 3598 23 LVecBase4f::operator != 0 1 838 0
67
inline bool LVecBase4f::operator !=(LVecBase4f const &other) const;

2722 10 compare_to 0 4 3598 22 LVecBase4f::compare_to 0 2 839 840 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase4f::compare_to(LVecBase4f const &other) const;
inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const;

2723 8 get_hash 0 4 3598 20 LVecBase4f::get_hash 0 2 841 842 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase4f::get_hash(void) const;
inline std::size_t LVecBase4f::get_hash(float threshold) const;

2724 8 add_hash 0 4 3598 20 LVecBase4f::add_hash 0 2 843 844 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;

2725 13 generate_hash 0 4 3598 25 LVecBase4f::generate_hash 0 2 845 846 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2726 10 operator - 0 68 3598 22 LVecBase4f::operator - 0 1 847 0
53
inline LVecBase4f LVecBase4f::operator -(void) const;

2727 10 operator + 0 4 3598 22 LVecBase4f::operator + 0 1 848 0
72
inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const;

2728 10 operator - 0 4 3598 22 LVecBase4f::operator - 0 1 849 0
72
inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const;

2729 10 operator * 0 4 3598 22 LVecBase4f::operator * 0 1 850 0
61
inline LVecBase4f LVecBase4f::operator *(float scalar) const;

2730 10 operator / 0 4 3598 22 LVecBase4f::operator / 0 1 851 0
61
inline LVecBase4f LVecBase4f::operator /(float scalar) const;

2731 11 operator += 0 4 3598 23 LVecBase4f::operator += 0 1 852 0
61
inline void LVecBase4f::operator +=(LVecBase4f const &other);

2732 11 operator -= 0 4 3598 23 LVecBase4f::operator -= 0 1 853 0
61
inline void LVecBase4f::operator -=(LVecBase4f const &other);

2733 11 operator *= 0 4 3598 23 LVecBase4f::operator *= 0 1 854 0
50
inline void LVecBase4f::operator *=(float scalar);

2734 11 operator /= 0 4 3598 23 LVecBase4f::operator /= 0 1 855 0
50
inline void LVecBase4f::operator /=(float scalar);

2735 18 componentwise_mult 0 4 3598 30 LVecBase4f::componentwise_mult 0 1 856 10
/**
 *
 */
68
inline void LVecBase4f::componentwise_mult(LVecBase4f const &other);

2736 7 __pow__ 0 4 3598 19 LVecBase4f::__pow__ 0 1 857 0
60
inline LVecBase4f LVecBase4f::__pow__(float exponent) const;

2737 8 __ipow__ 0 4 3598 20 LVecBase4f::__ipow__ 0 1 858 0
70
inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);

2738 9 __round__ 0 4 3598 21 LVecBase4f::__round__ 0 1 859 0
55
inline PyObject *LVecBase4f::__round__(PyObject *self);

2739 9 __floor__ 0 4 3598 21 LVecBase4f::__floor__ 0 1 860 0
55
inline PyObject *LVecBase4f::__floor__(PyObject *self);

2740 8 __ceil__ 0 4 3598 20 LVecBase4f::__ceil__ 0 1 861 0
54
inline PyObject *LVecBase4f::__ceil__(PyObject *self);

2741 4 fmax 0 4 3598 16 LVecBase4f::fmax 0 1 862 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const;

2742 4 fmin 0 4 3598 16 LVecBase4f::fmin 0 1 863 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const;

2743 12 almost_equal 0 4 3598 24 LVecBase4f::almost_equal 0 2 864 865 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const;
inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const;

2744 6 output 0 4 3598 18 LVecBase4f::output 0 1 866 10
/**
 *
 */
56
inline void LVecBase4f::output(std::ostream &out) const;

2745 8 __repr__ 0 4 3598 20 LVecBase4f::__repr__ 0 1 867 0
52
inline std::string LVecBase4f::__repr__(void) const;

2746 20 write_datagram_fixed 0 4 3598 32 LVecBase4f::write_datagram_fixed 0 1 868 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const;

2747 19 read_datagram_fixed 0 4 3598 31 LVecBase4f::read_datagram_fixed 0 1 869 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source);

2748 14 write_datagram 0 4 3598 26 LVecBase4f::write_datagram 0 1 870 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4f::write_datagram(Datagram &destination) const;

2749 13 read_datagram 0 4 3598 25 LVecBase4f::read_datagram 0 1 871 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4f::read_datagram(DatagramIterator &source);

2750 14 get_class_type 0 4 3598 26 LVecBase4f::get_class_type 0 1 872 0
51
static TypeHandle LVecBase4f::get_class_type(void);

2751 11 ~LVecBase4f 0 4 3598 23 LVecBase4f::~LVecBase4f 0 0 0
30
LVecBase4f::~LVecBase4f(void);

2752 19 UnalignedLVecBase4f 0 4 3600 40 UnalignedLVecBase4f::UnalignedLVecBase4f 0 5 873 874 875 876 877 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
377
inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default;
inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float fill_value);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default;

2753 4 fill 0 4 3600 25 UnalignedLVecBase4f::fill 0 1 878 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
56
inline void UnalignedLVecBase4f::fill(float fill_value);

2754 3 set 0 4 3600 24 UnalignedLVecBase4f::set 0 1 879 10
/**
 *
 */
73
inline void UnalignedLVecBase4f::set(float x, float y, float z, float w);

2755 11 operator [] 0 4 3600 32 UnalignedLVecBase4f::operator [] 0 2 880 881 10
/**
 *
 */
114
inline float UnalignedLVecBase4f::operator [](int i) const;
inline float &UnalignedLVecBase4f::operator [](int i);

2756 4 size 0 4 3600 25 UnalignedLVecBase4f::size 0 1 882 0
53
static constexpr int UnalignedLVecBase4f::size(void);

2757 8 get_data 0 4 3600 29 UnalignedLVecBase4f::get_data 0 1 883 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
62
inline float const *UnalignedLVecBase4f::get_data(void) const;

2758 18 get_num_components 0 4 3600 39 UnalignedLVecBase4f::get_num_components 0 1 884 0
67
static constexpr int UnalignedLVecBase4f::get_num_components(void);

2759 11 operator == 0 4 3600 32 UnalignedLVecBase4f::operator == 0 1 885 0
85
inline bool UnalignedLVecBase4f::operator ==(UnalignedLVecBase4f const &other) const;

2760 11 operator != 0 4 3600 32 UnalignedLVecBase4f::operator != 0 1 886 0
85
inline bool UnalignedLVecBase4f::operator !=(UnalignedLVecBase4f const &other) const;

2761 14 get_class_type 0 4 3600 35 UnalignedLVecBase4f::get_class_type 0 1 887 0
60
static TypeHandle UnalignedLVecBase4f::get_class_type(void);

2762 20 ~UnalignedLVecBase4f 0 4 3600 41 UnalignedLVecBase4f::~UnalignedLVecBase4f 0 0 0
48
UnalignedLVecBase4f::~UnalignedLVecBase4f(void);

2763 10 LVecBase4d 0 4 3602 22 LVecBase4d::LVecBase4d 0 8 888 889 890 891 892 893 894 895 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
467
inline LVecBase4d::LVecBase4d(void) = default;
inline LVecBase4d::LVecBase4d(double fill_value);
inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);
inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy);
inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w);
inline LVecBase4d::LVecBase4d(LPoint3d const &point);
inline LVecBase4d::LVecBase4d(LVector3d const &vector);
inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default;

2764 12 operator new 0 4 3602 24 LVecBase4d::operator new 0 1 896 0
124
inline void *LVecBase4d::operator new(std::size_t size);
inline void *LVecBase4d::operator new(std::size_t size, void *ptr);

2765 15 operator delete 0 4 3602 27 LVecBase4d::operator delete 0 0 0
108
inline void LVecBase4d::operator delete(void *ptr);
inline void LVecBase4d::operator delete(void *, void *);

2766 12 validate_ptr 0 4 3602 24 LVecBase4d::validate_ptr 0 0 0
61
static inline bool LVecBase4d::validate_ptr(void const *ptr);

2767 10 operator = 0 4 3602 22 LVecBase4d::operator = 0 2 897 898 0
120
void LVecBase4d::operator =(LVecBase4d const &copy) = default;
void LVecBase4d::operator =(double fill_value) = default;

2768 4 zero 0 4 3602 16 LVecBase4d::zero 0 1 899 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4d const &LVecBase4d::zero(void);

2769 6 unit_x 0 4 3602 18 LVecBase4d::unit_x 0 1 900 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_x(void);

2770 6 unit_y 0 4 3602 18 LVecBase4d::unit_y 0 1 901 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_y(void);

2771 6 unit_z 0 4 3602 18 LVecBase4d::unit_z 0 1 902 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_z(void);

2772 6 unit_w 0 4 3602 18 LVecBase4d::unit_w 0 1 903 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_w(void);

2773 10 __reduce__ 0 4 3602 22 LVecBase4d::__reduce__ 0 1 904 0
62
inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;

2774 11 __getattr__ 0 4 3602 23 LVecBase4d::__getattr__ 0 1 905 0
93
inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2775 11 __setattr__ 0 4 3602 23 LVecBase4d::__setattr__ 0 1 906 0
99
inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2776 11 operator [] 0 4 3602 23 LVecBase4d::operator [] 0 2 907 908 10
/**
 *
 */
98
inline double LVecBase4d::operator [](int i) const;
inline double &LVecBase4d::operator [](int i);

2777 4 size 0 4 3602 16 LVecBase4d::size 0 1 909 0
44
static constexpr int LVecBase4d::size(void);

2778 6 is_nan 0 4 3602 18 LVecBase4d::is_nan 0 1 910 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4d::is_nan(void) const;

2779 8 get_cell 0 4 3602 20 LVecBase4d::get_cell 0 1 911 10
/**
 *
 */
48
inline double LVecBase4d::get_cell(int i) const;

2780 8 set_cell 0 4 3602 20 LVecBase4d::set_cell 0 1 912 10
/**
 *
 */
54
inline void LVecBase4d::set_cell(int i, double value);

2781 5 get_x 0 4 3602 17 LVecBase4d::get_x 0 1 913 10
/**
 *
 */
44
inline double LVecBase4d::get_x(void) const;

2782 5 get_y 0 4 3602 17 LVecBase4d::get_y 0 1 914 10
/**
 *
 */
44
inline double LVecBase4d::get_y(void) const;

2783 5 get_z 0 4 3602 17 LVecBase4d::get_z 0 1 915 10
/**
 *
 */
44
inline double LVecBase4d::get_z(void) const;

2784 5 get_w 0 4 3602 17 LVecBase4d::get_w 0 1 916 10
/**
 *
 */
44
inline double LVecBase4d::get_w(void) const;

2785 7 get_xyz 0 4 3602 19 LVecBase4d::get_xyz 0 1 917 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3d LVecBase4d::get_xyz(void) const;

2786 6 get_xy 0 4 3602 18 LVecBase4d::get_xy 0 1 918 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2d LVecBase4d::get_xy(void) const;

2787 5 set_x 0 4 3602 17 LVecBase4d::set_x 0 1 919 10
/**
 *
 */
44
inline void LVecBase4d::set_x(double value);

2788 5 set_y 0 4 3602 17 LVecBase4d::set_y 0 1 920 10
/**
 *
 */
44
inline void LVecBase4d::set_y(double value);

2789 5 set_z 0 4 3602 17 LVecBase4d::set_z 0 1 921 10
/**
 *
 */
44
inline void LVecBase4d::set_z(double value);

2790 5 set_w 0 4 3602 17 LVecBase4d::set_w 0 1 922 10
/**
 *
 */
44
inline void LVecBase4d::set_w(double value);

2791 11 add_to_cell 0 4 3602 23 LVecBase4d::add_to_cell 0 1 923 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase4d::add_to_cell(int i, double value);

2792 5 add_x 0 4 3602 17 LVecBase4d::add_x 0 1 924 10
/**
 *
 */
44
inline void LVecBase4d::add_x(double value);

2793 5 add_y 0 4 3602 17 LVecBase4d::add_y 0 1 925 10
/**
 *
 */
44
inline void LVecBase4d::add_y(double value);

2794 5 add_z 0 4 3602 17 LVecBase4d::add_z 0 1 926 10
/**
 *
 */
44
inline void LVecBase4d::add_z(double value);

2795 5 add_w 0 4 3602 17 LVecBase4d::add_w 0 1 927 10
/**
 *
 */
44
inline void LVecBase4d::add_w(double value);

2796 8 get_data 0 4 3602 20 LVecBase4d::get_data 0 1 928 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase4d::get_data(void) const;

2797 18 get_num_components 0 4 3602 30 LVecBase4d::get_num_components 0 1 929 0
58
static constexpr int LVecBase4d::get_num_components(void);

2798 12 extract_data 0 4 3602 24 LVecBase4d::extract_data 0 0 0
46
inline void LVecBase4d::extract_data(float *);

2799 4 fill 0 4 3602 16 LVecBase4d::fill 0 1 930 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase4d::fill(double fill_value);

2800 3 set 0 4 3602 15 LVecBase4d::set 0 1 931 10
/**
 *
 */
68
inline void LVecBase4d::set(double x, double y, double z, double w);

2801 3 dot 0 4 3602 15 LVecBase4d::dot 0 1 932 10
/**
 *
 */
61
inline double LVecBase4d::dot(LVecBase4d const &other) const;

2802 14 length_squared 0 4 3602 26 LVecBase4d::length_squared 0 1 933 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase4d::length_squared(void) const;

2803 6 length 0 4 3602 18 LVecBase4d::length 0 1 934 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase4d::length(void) const;

2804 9 normalize 0 4 3602 21 LVecBase4d::normalize 0 1 935 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4d::normalize(void);

2805 10 normalized 0 4 3602 22 LVecBase4d::normalized 0 1 936 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4d LVecBase4d::normalized(void) const;

2806 7 project 0 4 3602 19 LVecBase4d::project 0 1 937 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const;

2807 10 operator < 0 4 3602 22 LVecBase4d::operator < 0 1 938 0
66
inline bool LVecBase4d::operator <(LVecBase4d const &other) const;

2808 11 operator == 0 4 3602 23 LVecBase4d::operator == 0 1 939 0
67
inline bool LVecBase4d::operator ==(LVecBase4d const &other) const;

2809 11 operator != 0 4 3602 23 LVecBase4d::operator != 0 1 940 0
67
inline bool LVecBase4d::operator !=(LVecBase4d const &other) const;

2810 10 compare_to 0 4 3602 22 LVecBase4d::compare_to 0 2 941 942 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase4d::compare_to(LVecBase4d const &other) const;
inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const;

2811 8 get_hash 0 4 3602 20 LVecBase4d::get_hash 0 2 943 944 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase4d::get_hash(void) const;
inline std::size_t LVecBase4d::get_hash(double threshold) const;

2812 8 add_hash 0 4 3602 20 LVecBase4d::add_hash 0 2 945 946 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;

2813 13 generate_hash 0 4 3602 25 LVecBase4d::generate_hash 0 2 947 948 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2814 10 operator - 0 68 3602 22 LVecBase4d::operator - 0 1 949 0
53
inline LVecBase4d LVecBase4d::operator -(void) const;

2815 10 operator + 0 4 3602 22 LVecBase4d::operator + 0 1 950 0
72
inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const;

2816 10 operator - 0 4 3602 22 LVecBase4d::operator - 0 1 951 0
72
inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const;

2817 10 operator * 0 4 3602 22 LVecBase4d::operator * 0 1 952 0
62
inline LVecBase4d LVecBase4d::operator *(double scalar) const;

2818 10 operator / 0 4 3602 22 LVecBase4d::operator / 0 1 953 0
62
inline LVecBase4d LVecBase4d::operator /(double scalar) const;

2819 11 operator += 0 4 3602 23 LVecBase4d::operator += 0 1 954 0
61
inline void LVecBase4d::operator +=(LVecBase4d const &other);

2820 11 operator -= 0 4 3602 23 LVecBase4d::operator -= 0 1 955 0
61
inline void LVecBase4d::operator -=(LVecBase4d const &other);

2821 11 operator *= 0 4 3602 23 LVecBase4d::operator *= 0 1 956 0
51
inline void LVecBase4d::operator *=(double scalar);

2822 11 operator /= 0 4 3602 23 LVecBase4d::operator /= 0 1 957 0
51
inline void LVecBase4d::operator /=(double scalar);

2823 18 componentwise_mult 0 4 3602 30 LVecBase4d::componentwise_mult 0 1 958 10
/**
 *
 */
68
inline void LVecBase4d::componentwise_mult(LVecBase4d const &other);

2824 7 __pow__ 0 4 3602 19 LVecBase4d::__pow__ 0 1 959 0
61
inline LVecBase4d LVecBase4d::__pow__(double exponent) const;

2825 8 __ipow__ 0 4 3602 20 LVecBase4d::__ipow__ 0 1 960 0
71
inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);

2826 9 __round__ 0 4 3602 21 LVecBase4d::__round__ 0 1 961 0
55
inline PyObject *LVecBase4d::__round__(PyObject *self);

2827 9 __floor__ 0 4 3602 21 LVecBase4d::__floor__ 0 1 962 0
55
inline PyObject *LVecBase4d::__floor__(PyObject *self);

2828 8 __ceil__ 0 4 3602 20 LVecBase4d::__ceil__ 0 1 963 0
54
inline PyObject *LVecBase4d::__ceil__(PyObject *self);

2829 4 fmax 0 4 3602 16 LVecBase4d::fmax 0 1 964 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const;

2830 4 fmin 0 4 3602 16 LVecBase4d::fmin 0 1 965 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const;

2831 12 almost_equal 0 4 3602 24 LVecBase4d::almost_equal 0 2 966 967 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const;
inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const;

2832 6 output 0 4 3602 18 LVecBase4d::output 0 1 968 10
/**
 *
 */
56
inline void LVecBase4d::output(std::ostream &out) const;

2833 8 __repr__ 0 4 3602 20 LVecBase4d::__repr__ 0 1 969 0
52
inline std::string LVecBase4d::__repr__(void) const;

2834 20 write_datagram_fixed 0 4 3602 32 LVecBase4d::write_datagram_fixed 0 1 970 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const;

2835 19 read_datagram_fixed 0 4 3602 31 LVecBase4d::read_datagram_fixed 0 1 971 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source);

2836 14 write_datagram 0 4 3602 26 LVecBase4d::write_datagram 0 1 972 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4d::write_datagram(Datagram &destination) const;

2837 13 read_datagram 0 4 3602 25 LVecBase4d::read_datagram 0 1 973 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4d::read_datagram(DatagramIterator &source);

2838 14 get_class_type 0 4 3602 26 LVecBase4d::get_class_type 0 1 974 0
51
static TypeHandle LVecBase4d::get_class_type(void);

2839 11 ~LVecBase4d 0 4 3602 23 LVecBase4d::~LVecBase4d 0 0 0
30
LVecBase4d::~LVecBase4d(void);

2840 19 UnalignedLVecBase4d 0 4 3604 40 UnalignedLVecBase4d::UnalignedLVecBase4d 0 5 975 976 977 978 979 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
382
inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default;
inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double fill_value);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default;

2841 4 fill 0 4 3604 25 UnalignedLVecBase4d::fill 0 1 980 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
57
inline void UnalignedLVecBase4d::fill(double fill_value);

2842 3 set 0 4 3604 24 UnalignedLVecBase4d::set 0 1 981 10
/**
 *
 */
77
inline void UnalignedLVecBase4d::set(double x, double y, double z, double w);

2843 11 operator [] 0 4 3604 32 UnalignedLVecBase4d::operator [] 0 2 982 983 10
/**
 *
 */
116
inline double UnalignedLVecBase4d::operator [](int i) const;
inline double &UnalignedLVecBase4d::operator [](int i);

2844 4 size 0 4 3604 25 UnalignedLVecBase4d::size 0 1 984 0
53
static constexpr int UnalignedLVecBase4d::size(void);

2845 8 get_data 0 4 3604 29 UnalignedLVecBase4d::get_data 0 1 985 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
63
inline double const *UnalignedLVecBase4d::get_data(void) const;

2846 18 get_num_components 0 4 3604 39 UnalignedLVecBase4d::get_num_components 0 1 986 0
67
static constexpr int UnalignedLVecBase4d::get_num_components(void);

2847 11 operator == 0 4 3604 32 UnalignedLVecBase4d::operator == 0 1 987 0
85
inline bool UnalignedLVecBase4d::operator ==(UnalignedLVecBase4d const &other) const;

2848 11 operator != 0 4 3604 32 UnalignedLVecBase4d::operator != 0 1 988 0
85
inline bool UnalignedLVecBase4d::operator !=(UnalignedLVecBase4d const &other) const;

2849 14 get_class_type 0 4 3604 35 UnalignedLVecBase4d::get_class_type 0 1 989 0
60
static TypeHandle UnalignedLVecBase4d::get_class_type(void);

2850 20 ~UnalignedLVecBase4d 0 4 3604 41 UnalignedLVecBase4d::~UnalignedLVecBase4d 0 0 0
48
UnalignedLVecBase4d::~UnalignedLVecBase4d(void);

2851 10 LVecBase4i 0 4 3606 22 LVecBase4i::LVecBase4i 0 8 990 991 992 993 994 995 996 997 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
449
inline LVecBase4i::LVecBase4i(void) = default;
inline LVecBase4i::LVecBase4i(int fill_value);
inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);
inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy);
inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w);
inline LVecBase4i::LVecBase4i(LPoint3i const &point);
inline LVecBase4i::LVecBase4i(LVector3i const &vector);
inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default;

2852 12 operator new 0 4 3606 24 LVecBase4i::operator new 0 1 998 0
124
inline void *LVecBase4i::operator new(std::size_t size);
inline void *LVecBase4i::operator new(std::size_t size, void *ptr);

2853 15 operator delete 0 4 3606 27 LVecBase4i::operator delete 0 0 0
108
inline void LVecBase4i::operator delete(void *ptr);
inline void LVecBase4i::operator delete(void *, void *);

2854 12 validate_ptr 0 4 3606 24 LVecBase4i::validate_ptr 0 0 0
61
static inline bool LVecBase4i::validate_ptr(void const *ptr);

2855 10 operator = 0 4 3606 22 LVecBase4i::operator = 0 2 999 1000 0
117
void LVecBase4i::operator =(LVecBase4i const &copy) = default;
void LVecBase4i::operator =(int fill_value) = default;

2856 4 zero 0 4 3606 16 LVecBase4i::zero 0 1 1001 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4i const &LVecBase4i::zero(void);

2857 6 unit_x 0 4 3606 18 LVecBase4i::unit_x 0 1 1002 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_x(void);

2858 6 unit_y 0 4 3606 18 LVecBase4i::unit_y 0 1 1003 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_y(void);

2859 6 unit_z 0 4 3606 18 LVecBase4i::unit_z 0 1 1004 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_z(void);

2860 6 unit_w 0 4 3606 18 LVecBase4i::unit_w 0 1 1005 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_w(void);

2861 10 __reduce__ 0 4 3606 22 LVecBase4i::__reduce__ 0 1 1006 0
62
inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;

2862 11 __getattr__ 0 4 3606 23 LVecBase4i::__getattr__ 0 1 1007 0
93
inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2863 11 __setattr__ 0 4 3606 23 LVecBase4i::__setattr__ 0 1 1008 0
99
inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2864 11 operator [] 0 4 3606 23 LVecBase4i::operator [] 0 2 1009 1010 10
/**
 *
 */
92
inline int LVecBase4i::operator [](int i) const;
inline int &LVecBase4i::operator [](int i);

2865 4 size 0 4 3606 16 LVecBase4i::size 0 1 1011 0
44
static constexpr int LVecBase4i::size(void);

2866 6 is_nan 0 4 3606 18 LVecBase4i::is_nan 0 1 1012 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4i::is_nan(void) const;

2867 8 get_cell 0 4 3606 20 LVecBase4i::get_cell 0 1 1013 10
/**
 *
 */
45
inline int LVecBase4i::get_cell(int i) const;

2868 8 set_cell 0 4 3606 20 LVecBase4i::set_cell 0 1 1014 10
/**
 *
 */
51
inline void LVecBase4i::set_cell(int i, int value);

2869 5 get_x 0 4 3606 17 LVecBase4i::get_x 0 1 1015 10
/**
 *
 */
41
inline int LVecBase4i::get_x(void) const;

2870 5 get_y 0 4 3606 17 LVecBase4i::get_y 0 1 1016 10
/**
 *
 */
41
inline int LVecBase4i::get_y(void) const;

2871 5 get_z 0 4 3606 17 LVecBase4i::get_z 0 1 1017 10
/**
 *
 */
41
inline int LVecBase4i::get_z(void) const;

2872 5 get_w 0 4 3606 17 LVecBase4i::get_w 0 1 1018 10
/**
 *
 */
41
inline int LVecBase4i::get_w(void) const;

2873 7 get_xyz 0 4 3606 19 LVecBase4i::get_xyz 0 1 1019 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3i LVecBase4i::get_xyz(void) const;

2874 6 get_xy 0 4 3606 18 LVecBase4i::get_xy 0 1 1020 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2i LVecBase4i::get_xy(void) const;

2875 5 set_x 0 4 3606 17 LVecBase4i::set_x 0 1 1021 10
/**
 *
 */
41
inline void LVecBase4i::set_x(int value);

2876 5 set_y 0 4 3606 17 LVecBase4i::set_y 0 1 1022 10
/**
 *
 */
41
inline void LVecBase4i::set_y(int value);

2877 5 set_z 0 4 3606 17 LVecBase4i::set_z 0 1 1023 10
/**
 *
 */
41
inline void LVecBase4i::set_z(int value);

2878 5 set_w 0 4 3606 17 LVecBase4i::set_w 0 1 1024 10
/**
 *
 */
41
inline void LVecBase4i::set_w(int value);

2879 11 add_to_cell 0 4 3606 23 LVecBase4i::add_to_cell 0 1 1025 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase4i::add_to_cell(int i, int value);

2880 5 add_x 0 4 3606 17 LVecBase4i::add_x 0 1 1026 10
/**
 *
 */
41
inline void LVecBase4i::add_x(int value);

2881 5 add_y 0 4 3606 17 LVecBase4i::add_y 0 1 1027 10
/**
 *
 */
41
inline void LVecBase4i::add_y(int value);

2882 5 add_z 0 4 3606 17 LVecBase4i::add_z 0 1 1028 10
/**
 *
 */
41
inline void LVecBase4i::add_z(int value);

2883 5 add_w 0 4 3606 17 LVecBase4i::add_w 0 1 1029 10
/**
 *
 */
41
inline void LVecBase4i::add_w(int value);

2884 8 get_data 0 4 3606 20 LVecBase4i::get_data 0 1 1030 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase4i::get_data(void) const;

2885 18 get_num_components 0 4 3606 30 LVecBase4i::get_num_components 0 1 1031 0
58
static constexpr int LVecBase4i::get_num_components(void);

2886 12 extract_data 0 4 3606 24 LVecBase4i::extract_data 0 0 0
46
inline void LVecBase4i::extract_data(float *);

2887 4 fill 0 4 3606 16 LVecBase4i::fill 0 1 1032 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase4i::fill(int fill_value);

2888 3 set 0 4 3606 15 LVecBase4i::set 0 1 1033 10
/**
 *
 */
56
inline void LVecBase4i::set(int x, int y, int z, int w);

2889 3 dot 0 4 3606 15 LVecBase4i::dot 0 1 1034 10
/**
 *
 */
58
inline int LVecBase4i::dot(LVecBase4i const &other) const;

2890 14 length_squared 0 4 3606 26 LVecBase4i::length_squared 0 1 1035 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase4i::length_squared(void) const;

2891 10 operator < 0 4 3606 22 LVecBase4i::operator < 0 1 1036 0
66
inline bool LVecBase4i::operator <(LVecBase4i const &other) const;

2892 11 operator == 0 4 3606 23 LVecBase4i::operator == 0 1 1037 0
67
inline bool LVecBase4i::operator ==(LVecBase4i const &other) const;

2893 11 operator != 0 4 3606 23 LVecBase4i::operator != 0 1 1038 0
67
inline bool LVecBase4i::operator !=(LVecBase4i const &other) const;

2894 10 compare_to 0 4 3606 22 LVecBase4i::compare_to 0 1 1039 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase4i::compare_to(LVecBase4i const &other) const;

2895 8 get_hash 0 4 3606 20 LVecBase4i::get_hash 0 1 1040 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase4i::get_hash(void) const;

2896 8 add_hash 0 4 3606 20 LVecBase4i::add_hash 0 1 1041 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;

2897 13 generate_hash 0 4 3606 25 LVecBase4i::generate_hash 0 1 1042 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase4i::generate_hash(ChecksumHashGenerator &hashgen) const;

2898 10 operator - 0 68 3606 22 LVecBase4i::operator - 0 1 1043 0
53
inline LVecBase4i LVecBase4i::operator -(void) const;

2899 10 operator + 0 4 3606 22 LVecBase4i::operator + 0 1 1044 0
72
inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const;

2900 10 operator - 0 4 3606 22 LVecBase4i::operator - 0 1 1045 0
72
inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const;

2901 10 operator * 0 4 3606 22 LVecBase4i::operator * 0 1 1046 0
59
inline LVecBase4i LVecBase4i::operator *(int scalar) const;

2902 10 operator / 0 4 3606 22 LVecBase4i::operator / 0 1 1047 0
59
inline LVecBase4i LVecBase4i::operator /(int scalar) const;

2903 11 operator += 0 4 3606 23 LVecBase4i::operator += 0 1 1048 0
61
inline void LVecBase4i::operator +=(LVecBase4i const &other);

2904 11 operator -= 0 4 3606 23 LVecBase4i::operator -= 0 1 1049 0
61
inline void LVecBase4i::operator -=(LVecBase4i const &other);

2905 11 operator *= 0 4 3606 23 LVecBase4i::operator *= 0 1 1050 0
48
inline void LVecBase4i::operator *=(int scalar);

2906 11 operator /= 0 4 3606 23 LVecBase4i::operator /= 0 1 1051 0
48
inline void LVecBase4i::operator /=(int scalar);

2907 18 componentwise_mult 0 4 3606 30 LVecBase4i::componentwise_mult 0 1 1052 10
/**
 *
 */
68
inline void LVecBase4i::componentwise_mult(LVecBase4i const &other);

2908 7 __pow__ 0 4 3606 19 LVecBase4i::__pow__ 0 1 1053 0
58
inline LVecBase4i LVecBase4i::__pow__(int exponent) const;

2909 8 __ipow__ 0 4 3606 20 LVecBase4i::__ipow__ 0 1 1054 0
68
inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);

2910 9 __round__ 0 4 3606 21 LVecBase4i::__round__ 0 1 1055 0
55
inline PyObject *LVecBase4i::__round__(PyObject *self);

2911 9 __floor__ 0 4 3606 21 LVecBase4i::__floor__ 0 1 1056 0
55
inline PyObject *LVecBase4i::__floor__(PyObject *self);

2912 8 __ceil__ 0 4 3606 20 LVecBase4i::__ceil__ 0 1 1057 0
54
inline PyObject *LVecBase4i::__ceil__(PyObject *self);

2913 4 fmax 0 4 3606 16 LVecBase4i::fmax 0 1 1058 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const;

2914 4 fmin 0 4 3606 16 LVecBase4i::fmin 0 1 1059 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const;

2915 12 almost_equal 0 4 3606 24 LVecBase4i::almost_equal 0 2 1060 1061 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const;
inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const;

2916 6 output 0 4 3606 18 LVecBase4i::output 0 1 1062 10
/**
 *
 */
56
inline void LVecBase4i::output(std::ostream &out) const;

2917 8 __repr__ 0 4 3606 20 LVecBase4i::__repr__ 0 1 1063 0
52
inline std::string LVecBase4i::__repr__(void) const;

2918 20 write_datagram_fixed 0 4 3606 32 LVecBase4i::write_datagram_fixed 0 1 1064 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const;

2919 19 read_datagram_fixed 0 4 3606 31 LVecBase4i::read_datagram_fixed 0 1 1065 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source);

2920 14 write_datagram 0 4 3606 26 LVecBase4i::write_datagram 0 1 1066 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4i::write_datagram(Datagram &destination) const;

2921 13 read_datagram 0 4 3606 25 LVecBase4i::read_datagram 0 1 1067 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4i::read_datagram(DatagramIterator &source);

2922 14 get_class_type 0 4 3606 26 LVecBase4i::get_class_type 0 1 1068 0
51
static TypeHandle LVecBase4i::get_class_type(void);

2923 11 ~LVecBase4i 0 4 3606 23 LVecBase4i::~LVecBase4i 0 0 0
30
LVecBase4i::~LVecBase4i(void);

2924 19 UnalignedLVecBase4i 0 4 3608 40 UnalignedLVecBase4i::UnalignedLVecBase4i 0 5 1069 1070 1071 1072 1073 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
367
inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default;
inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int fill_value);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default;

2925 4 fill 0 4 3608 25 UnalignedLVecBase4i::fill 0 1 1074 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
54
inline void UnalignedLVecBase4i::fill(int fill_value);

2926 3 set 0 4 3608 24 UnalignedLVecBase4i::set 0 1 1075 10
/**
 *
 */
65
inline void UnalignedLVecBase4i::set(int x, int y, int z, int w);

2927 11 operator [] 0 4 3608 32 UnalignedLVecBase4i::operator [] 0 2 1076 1077 10
/**
 *
 */
110
inline int UnalignedLVecBase4i::operator [](int i) const;
inline int &UnalignedLVecBase4i::operator [](int i);

2928 4 size 0 4 3608 25 UnalignedLVecBase4i::size 0 1 1078 0
53
static constexpr int UnalignedLVecBase4i::size(void);

2929 8 get_data 0 4 3608 29 UnalignedLVecBase4i::get_data 0 1 1079 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
60
inline int const *UnalignedLVecBase4i::get_data(void) const;

2930 18 get_num_components 0 4 3608 39 UnalignedLVecBase4i::get_num_components 0 1 1080 0
67
static constexpr int UnalignedLVecBase4i::get_num_components(void);

2931 11 operator == 0 4 3608 32 UnalignedLVecBase4i::operator == 0 1 1081 0
85
inline bool UnalignedLVecBase4i::operator ==(UnalignedLVecBase4i const &other) const;

2932 11 operator != 0 4 3608 32 UnalignedLVecBase4i::operator != 0 1 1082 0
85
inline bool UnalignedLVecBase4i::operator !=(UnalignedLVecBase4i const &other) const;

2933 14 get_class_type 0 4 3608 35 UnalignedLVecBase4i::get_class_type 0 1 1083 0
60
static TypeHandle UnalignedLVecBase4i::get_class_type(void);

2934 20 ~UnalignedLVecBase4i 0 4 3608 41 UnalignedLVecBase4i::~UnalignedLVecBase4i 0 0 0
48
UnalignedLVecBase4i::~UnalignedLVecBase4i(void);

2935 9 LVector4f 0 4 3610 20 LVector4f::LVector4f 0 6 1084 1085 1086 1087 1088 1089 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
329
inline LVector4f::LVector4f(void) = default;
inline LVector4f::LVector4f(LVecBase4f const &copy);
inline LVector4f::LVector4f(float fill_value);
inline LVector4f::LVector4f(float x, float y, float z, float w);
inline LVector4f::LVector4f(LVecBase3f const &copy, float w);
inline LVector4f::LVector4f(LVector4f const &) = default;

2936 11 __getattr__ 0 4 3610 22 LVector4f::__getattr__ 0 1 1090 0
92
inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2937 11 __setattr__ 0 4 3610 22 LVector4f::__setattr__ 0 1 1091 0
98
inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2938 4 zero 0 4 3610 15 LVector4f::zero 0 1 1092 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4f const &LVector4f::zero(void);

2939 6 unit_x 0 4 3610 17 LVector4f::unit_x 0 1 1093 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4f const &LVector4f::unit_x(void);

2940 6 unit_y 0 4 3610 17 LVector4f::unit_y 0 1 1094 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4f const &LVector4f::unit_y(void);

2941 6 unit_z 0 4 3610 17 LVector4f::unit_z 0 1 1095 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4f const &LVector4f::unit_z(void);

2942 6 unit_w 0 4 3610 17 LVector4f::unit_w 0 1 1096 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4f const &LVector4f::unit_w(void);

2943 7 get_xyz 0 4 3610 18 LVector4f::get_xyz 0 1 1097 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3f LVector4f::get_xyz(void) const;

2944 6 get_xy 0 4 3610 17 LVector4f::get_xy 0 1 1098 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2f LVector4f::get_xy(void) const;

2945 10 operator - 0 68 3610 21 LVector4f::operator - 0 1 1099 0
51
inline LVector4f LVector4f::operator -(void) const;

2946 10 operator + 0 4 3610 21 LVector4f::operator + 0 2 1100 1101 0
141
inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator +(LVector4f const &other) const;

2947 10 operator - 0 4 3610 21 LVector4f::operator - 0 2 1102 1103 0
141
inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator -(LVector4f const &other) const;

2948 10 operator * 0 4 3610 21 LVector4f::operator * 0 1 1104 0
59
inline LVector4f LVector4f::operator *(float scalar) const;

2949 10 operator / 0 4 3610 21 LVector4f::operator / 0 1 1105 0
59
inline LVector4f LVector4f::operator /(float scalar) const;

2950 10 normalized 0 4 3610 21 LVector4f::normalized 0 1 1106 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4f LVector4f::normalized(void) const;

2951 7 project 0 4 3610 18 LVector4f::project 0 1 1107 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4f LVector4f::project(LVecBase4f const &onto) const;

2952 8 __repr__ 0 4 3610 19 LVector4f::__repr__ 0 1 1108 0
51
inline std::string LVector4f::__repr__(void) const;

2953 14 get_class_type 0 4 3610 25 LVector4f::get_class_type 0 1 1109 0
50
static TypeHandle LVector4f::get_class_type(void);

2954 10 ~LVector4f 0 4 3610 21 LVector4f::~LVector4f 0 0 0
28
LVector4f::~LVector4f(void);

2955 9 LVector4d 0 4 3611 20 LVector4d::LVector4d 0 6 1110 1111 1112 1113 1114 1115 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
335
inline LVector4d::LVector4d(void) = default;
inline LVector4d::LVector4d(LVecBase4d const &copy);
inline LVector4d::LVector4d(double fill_value);
inline LVector4d::LVector4d(double x, double y, double z, double w);
inline LVector4d::LVector4d(LVecBase3d const &copy, double w);
inline LVector4d::LVector4d(LVector4d const &) = default;

2956 11 __getattr__ 0 4 3611 22 LVector4d::__getattr__ 0 1 1116 0
92
inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2957 11 __setattr__ 0 4 3611 22 LVector4d::__setattr__ 0 1 1117 0
98
inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2958 4 zero 0 4 3611 15 LVector4d::zero 0 1 1118 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4d const &LVector4d::zero(void);

2959 6 unit_x 0 4 3611 17 LVector4d::unit_x 0 1 1119 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4d const &LVector4d::unit_x(void);

2960 6 unit_y 0 4 3611 17 LVector4d::unit_y 0 1 1120 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4d const &LVector4d::unit_y(void);

2961 6 unit_z 0 4 3611 17 LVector4d::unit_z 0 1 1121 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4d const &LVector4d::unit_z(void);

2962 6 unit_w 0 4 3611 17 LVector4d::unit_w 0 1 1122 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4d const &LVector4d::unit_w(void);

2963 7 get_xyz 0 4 3611 18 LVector4d::get_xyz 0 1 1123 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3d LVector4d::get_xyz(void) const;

2964 6 get_xy 0 4 3611 17 LVector4d::get_xy 0 1 1124 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2d LVector4d::get_xy(void) const;

2965 10 operator - 0 68 3611 21 LVector4d::operator - 0 1 1125 0
51
inline LVector4d LVector4d::operator -(void) const;

2966 10 operator + 0 4 3611 21 LVector4d::operator + 0 2 1126 1127 0
141
inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator +(LVector4d const &other) const;

2967 10 operator - 0 4 3611 21 LVector4d::operator - 0 2 1128 1129 0
141
inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator -(LVector4d const &other) const;

2968 10 operator * 0 4 3611 21 LVector4d::operator * 0 1 1130 0
60
inline LVector4d LVector4d::operator *(double scalar) const;

2969 10 operator / 0 4 3611 21 LVector4d::operator / 0 1 1131 0
60
inline LVector4d LVector4d::operator /(double scalar) const;

2970 10 normalized 0 4 3611 21 LVector4d::normalized 0 1 1132 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4d LVector4d::normalized(void) const;

2971 7 project 0 4 3611 18 LVector4d::project 0 1 1133 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4d LVector4d::project(LVecBase4d const &onto) const;

2972 8 __repr__ 0 4 3611 19 LVector4d::__repr__ 0 1 1134 0
51
inline std::string LVector4d::__repr__(void) const;

2973 14 get_class_type 0 4 3611 25 LVector4d::get_class_type 0 1 1135 0
50
static TypeHandle LVector4d::get_class_type(void);

2974 10 ~LVector4d 0 4 3611 21 LVector4d::~LVector4d 0 0 0
28
LVector4d::~LVector4d(void);

2975 9 LVector4i 0 4 3612 20 LVector4i::LVector4i 0 6 1136 1137 1138 1139 1140 1141 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
317
inline LVector4i::LVector4i(void) = default;
inline LVector4i::LVector4i(LVecBase4i const &copy);
inline LVector4i::LVector4i(int fill_value);
inline LVector4i::LVector4i(int x, int y, int z, int w);
inline LVector4i::LVector4i(LVecBase3i const &copy, int w);
inline LVector4i::LVector4i(LVector4i const &) = default;

2976 11 __getattr__ 0 4 3612 22 LVector4i::__getattr__ 0 1 1142 0
92
inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2977 11 __setattr__ 0 4 3612 22 LVector4i::__setattr__ 0 1 1143 0
98
inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2978 4 zero 0 4 3612 15 LVector4i::zero 0 1 1144 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4i const &LVector4i::zero(void);

2979 6 unit_x 0 4 3612 17 LVector4i::unit_x 0 1 1145 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4i const &LVector4i::unit_x(void);

2980 6 unit_y 0 4 3612 17 LVector4i::unit_y 0 1 1146 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4i const &LVector4i::unit_y(void);

2981 6 unit_z 0 4 3612 17 LVector4i::unit_z 0 1 1147 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4i const &LVector4i::unit_z(void);

2982 6 unit_w 0 4 3612 17 LVector4i::unit_w 0 1 1148 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4i const &LVector4i::unit_w(void);

2983 7 get_xyz 0 4 3612 18 LVector4i::get_xyz 0 1 1149 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3i LVector4i::get_xyz(void) const;

2984 6 get_xy 0 4 3612 17 LVector4i::get_xy 0 1 1150 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2i LVector4i::get_xy(void) const;

2985 10 operator - 0 68 3612 21 LVector4i::operator - 0 1 1151 0
51
inline LVector4i LVector4i::operator -(void) const;

2986 10 operator + 0 4 3612 21 LVector4i::operator + 0 2 1152 1153 0
141
inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator +(LVector4i const &other) const;

2987 10 operator - 0 4 3612 21 LVector4i::operator - 0 2 1154 1155 0
141
inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator -(LVector4i const &other) const;

2988 10 operator * 0 4 3612 21 LVector4i::operator * 0 1 1156 0
57
inline LVector4i LVector4i::operator *(int scalar) const;

2989 10 operator / 0 4 3612 21 LVector4i::operator / 0 1 1157 0
57
inline LVector4i LVector4i::operator /(int scalar) const;

2990 8 __repr__ 0 4 3612 19 LVector4i::__repr__ 0 1 1158 0
51
inline std::string LVector4i::__repr__(void) const;

2991 14 get_class_type 0 4 3612 25 LVector4i::get_class_type 0 1 1159 0
50
static TypeHandle LVector4i::get_class_type(void);

2992 10 ~LVector4i 0 4 3612 21 LVector4i::~LVector4i 0 0 0
28
LVector4i::~LVector4i(void);

2993 8 LPoint4f 0 4 3613 18 LPoint4f::LPoint4f 0 6 1160 1161 1162 1163 1164 1165 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
316
inline LPoint4f::LPoint4f(void) = default;
inline LPoint4f::LPoint4f(LVecBase4f const &copy);
inline LPoint4f::LPoint4f(float fill_value);
inline LPoint4f::LPoint4f(float x, float y, float z, float w);
inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w);
inline LPoint4f::LPoint4f(LPoint4f const &) = default;

2994 11 __getattr__ 0 4 3613 21 LPoint4f::__getattr__ 0 1 1166 0
91
inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2995 11 __setattr__ 0 4 3613 21 LPoint4f::__setattr__ 0 1 1167 0
97
inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2996 4 zero 0 4 3613 14 LPoint4f::zero 0 1 1168 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4f const &LPoint4f::zero(void);

2997 6 unit_x 0 4 3613 16 LPoint4f::unit_x 0 1 1169 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4f const &LPoint4f::unit_x(void);

2998 6 unit_y 0 4 3613 16 LPoint4f::unit_y 0 1 1170 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4f const &LPoint4f::unit_y(void);

2999 6 unit_z 0 4 3613 16 LPoint4f::unit_z 0 1 1171 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4f const &LPoint4f::unit_z(void);

3000 6 unit_w 0 4 3613 16 LPoint4f::unit_w 0 1 1172 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4f const &LPoint4f::unit_w(void);

3001 7 get_xyz 0 4 3613 17 LPoint4f::get_xyz 0 1 1173 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3f LPoint4f::get_xyz(void) const;

3002 6 get_xy 0 4 3613 16 LPoint4f::get_xy 0 1 1174 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2f LPoint4f::get_xy(void) const;

3003 10 operator - 0 68 3613 20 LPoint4f::operator - 0 1 1175 0
49
inline LPoint4f LPoint4f::operator -(void) const;

3004 10 operator + 0 4 3613 20 LPoint4f::operator + 0 2 1176 1177 0
138
inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const;
inline LPoint4f LPoint4f::operator +(LVector4f const &other) const;

3005 10 operator - 0 4 3613 20 LPoint4f::operator - 0 3 1178 1179 1180 0
206
inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const;
inline LVector4f LPoint4f::operator -(LPoint4f const &other) const;
inline LPoint4f LPoint4f::operator -(LVector4f const &other) const;

3006 10 operator * 0 4 3613 20 LPoint4f::operator * 0 1 1181 0
57
inline LPoint4f LPoint4f::operator *(float scalar) const;

3007 10 operator / 0 4 3613 20 LPoint4f::operator / 0 1 1182 0
57
inline LPoint4f LPoint4f::operator /(float scalar) const;

3008 10 normalized 0 4 3613 20 LPoint4f::normalized 0 1 1183 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4f LPoint4f::normalized(void) const;

3009 7 project 0 4 3613 17 LPoint4f::project 0 1 1184 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const;

3010 8 __repr__ 0 4 3613 18 LPoint4f::__repr__ 0 1 1185 0
50
inline std::string LPoint4f::__repr__(void) const;

3011 14 get_class_type 0 4 3613 24 LPoint4f::get_class_type 0 1 1186 0
49
static TypeHandle LPoint4f::get_class_type(void);

3012 9 ~LPoint4f 0 4 3613 19 LPoint4f::~LPoint4f 0 0 0
26
LPoint4f::~LPoint4f(void);

3013 8 LPoint4d 0 4 3614 18 LPoint4d::LPoint4d 0 6 1187 1188 1189 1190 1191 1192 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
322
inline LPoint4d::LPoint4d(void) = default;
inline LPoint4d::LPoint4d(LVecBase4d const &copy);
inline LPoint4d::LPoint4d(double fill_value);
inline LPoint4d::LPoint4d(double x, double y, double z, double w);
inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w);
inline LPoint4d::LPoint4d(LPoint4d const &) = default;

3014 11 __getattr__ 0 4 3614 21 LPoint4d::__getattr__ 0 1 1193 0
91
inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const;

3015 11 __setattr__ 0 4 3614 21 LPoint4d::__setattr__ 0 1 1194 0
97
inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3016 4 zero 0 4 3614 14 LPoint4d::zero 0 1 1195 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4d const &LPoint4d::zero(void);

3017 6 unit_x 0 4 3614 16 LPoint4d::unit_x 0 1 1196 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4d const &LPoint4d::unit_x(void);

3018 6 unit_y 0 4 3614 16 LPoint4d::unit_y 0 1 1197 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4d const &LPoint4d::unit_y(void);

3019 6 unit_z 0 4 3614 16 LPoint4d::unit_z 0 1 1198 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4d const &LPoint4d::unit_z(void);

3020 6 unit_w 0 4 3614 16 LPoint4d::unit_w 0 1 1199 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4d const &LPoint4d::unit_w(void);

3021 7 get_xyz 0 4 3614 17 LPoint4d::get_xyz 0 1 1200 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3d LPoint4d::get_xyz(void) const;

3022 6 get_xy 0 4 3614 16 LPoint4d::get_xy 0 1 1201 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2d LPoint4d::get_xy(void) const;

3023 10 operator - 0 68 3614 20 LPoint4d::operator - 0 1 1202 0
49
inline LPoint4d LPoint4d::operator -(void) const;

3024 10 operator + 0 4 3614 20 LPoint4d::operator + 0 2 1203 1204 0
138
inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const;
inline LPoint4d LPoint4d::operator +(LVector4d const &other) const;

3025 10 operator - 0 4 3614 20 LPoint4d::operator - 0 3 1205 1206 1207 0
206
inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const;
inline LVector4d LPoint4d::operator -(LPoint4d const &other) const;
inline LPoint4d LPoint4d::operator -(LVector4d const &other) const;

3026 10 operator * 0 4 3614 20 LPoint4d::operator * 0 1 1208 0
58
inline LPoint4d LPoint4d::operator *(double scalar) const;

3027 10 operator / 0 4 3614 20 LPoint4d::operator / 0 1 1209 0
58
inline LPoint4d LPoint4d::operator /(double scalar) const;

3028 10 normalized 0 4 3614 20 LPoint4d::normalized 0 1 1210 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4d LPoint4d::normalized(void) const;

3029 7 project 0 4 3614 17 LPoint4d::project 0 1 1211 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const;

3030 8 __repr__ 0 4 3614 18 LPoint4d::__repr__ 0 1 1212 0
50
inline std::string LPoint4d::__repr__(void) const;

3031 14 get_class_type 0 4 3614 24 LPoint4d::get_class_type 0 1 1213 0
49
static TypeHandle LPoint4d::get_class_type(void);

3032 9 ~LPoint4d 0 4 3614 19 LPoint4d::~LPoint4d 0 0 0
26
LPoint4d::~LPoint4d(void);

3033 8 LPoint4i 0 4 3615 18 LPoint4i::LPoint4i 0 6 1214 1215 1216 1217 1218 1219 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
304
inline LPoint4i::LPoint4i(void) = default;
inline LPoint4i::LPoint4i(LVecBase4i const &copy);
inline LPoint4i::LPoint4i(int fill_value);
inline LPoint4i::LPoint4i(int x, int y, int z, int w);
inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w);
inline LPoint4i::LPoint4i(LPoint4i const &) = default;

3034 11 __getattr__ 0 4 3615 21 LPoint4i::__getattr__ 0 1 1220 0
91
inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const;

3035 11 __setattr__ 0 4 3615 21 LPoint4i::__setattr__ 0 1 1221 0
97
inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3036 4 zero 0 4 3615 14 LPoint4i::zero 0 1 1222 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4i const &LPoint4i::zero(void);

3037 6 unit_x 0 4 3615 16 LPoint4i::unit_x 0 1 1223 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4i const &LPoint4i::unit_x(void);

3038 6 unit_y 0 4 3615 16 LPoint4i::unit_y 0 1 1224 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4i const &LPoint4i::unit_y(void);

3039 6 unit_z 0 4 3615 16 LPoint4i::unit_z 0 1 1225 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4i const &LPoint4i::unit_z(void);

3040 6 unit_w 0 4 3615 16 LPoint4i::unit_w 0 1 1226 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4i const &LPoint4i::unit_w(void);

3041 7 get_xyz 0 4 3615 17 LPoint4i::get_xyz 0 1 1227 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3i LPoint4i::get_xyz(void) const;

3042 6 get_xy 0 4 3615 16 LPoint4i::get_xy 0 1 1228 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2i LPoint4i::get_xy(void) const;

3043 10 operator - 0 68 3615 20 LPoint4i::operator - 0 1 1229 0
49
inline LPoint4i LPoint4i::operator -(void) const;

3044 10 operator + 0 4 3615 20 LPoint4i::operator + 0 2 1230 1231 0
138
inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const;
inline LPoint4i LPoint4i::operator +(LVector4i const &other) const;

3045 10 operator - 0 4 3615 20 LPoint4i::operator - 0 3 1232 1233 1234 0
206
inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const;
inline LVector4i LPoint4i::operator -(LPoint4i const &other) const;
inline LPoint4i LPoint4i::operator -(LVector4i const &other) const;

3046 10 operator * 0 4 3615 20 LPoint4i::operator * 0 1 1235 0
55
inline LPoint4i LPoint4i::operator *(int scalar) const;

3047 10 operator / 0 4 3615 20 LPoint4i::operator / 0 1 1236 0
55
inline LPoint4i LPoint4i::operator /(int scalar) const;

3048 8 __repr__ 0 4 3615 18 LPoint4i::__repr__ 0 1 1237 0
50
inline std::string LPoint4i::__repr__(void) const;

3049 14 get_class_type 0 4 3615 24 LPoint4i::get_class_type 0 1 1238 0
49
static TypeHandle LPoint4i::get_class_type(void);

3050 9 ~LPoint4i 0 4 3615 19 LPoint4i::~LPoint4i 0 0 0
26
LPoint4i::~LPoint4i(void);

3051 11 operator [] 0 4 3618 27 LMatrix3f::Row::operator [] 0 2 1341 1342 10
/**
 *
 */
104
inline float LMatrix3f::Row::operator [](int i) const;
inline float &LMatrix3f::Row::operator [](int i);

3052 4 size 0 4 3618 20 LMatrix3f::Row::size 0 1 1343 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3f::Row::size(void);

3053 17 operator typecast 0 132 3618 33 LMatrix3f::Row::operator typecast 0 1 1344 0
47
inline operator LVecBase3f const &(void) const;

3054 3 Row 0 4 3618 19 LMatrix3f::Row::Row 0 1 1340 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default;

3055 4 ~Row 0 4 3618 20 LMatrix3f::Row::~Row 0 0 0
27
LMatrix3f::Row::~Row(void);

3056 11 operator [] 0 4 3619 28 LMatrix3f::CRow::operator [] 0 1 1346 0
55
inline float LMatrix3f::CRow::operator [](int i) const;

3057 4 size 0 4 3619 21 LMatrix3f::CRow::size 0 1 1347 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3f::CRow::size(void);

3058 17 operator typecast 0 132 3619 34 LMatrix3f::CRow::operator typecast 0 1 1348 0
47
inline operator LVecBase3f const &(void) const;

3059 4 CRow 0 4 3619 21 LMatrix3f::CRow::CRow 0 1 1345 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default;

3060 5 ~CRow 0 4 3619 22 LMatrix3f::CRow::~CRow 0 0 0
29
LMatrix3f::CRow::~CRow(void);

3061 9 LMatrix3f 0 4 3616 20 LMatrix3f::LMatrix3f 0 4 1239 1240 1241 1242 72
/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
297
inline LMatrix3f::LMatrix3f(void) = default;
inline LMatrix3f::LMatrix3f(LMatrix3f const &other) = default;
inline LMatrix3f::LMatrix3f(float , float , float , float , float , float , float , float , float );
inline LMatrix3f::LMatrix3f(LVecBase3f const &, LVecBase3f const &, LVecBase3f const &);

3062 10 operator = 0 4 3616 21 LMatrix3f::operator = 0 2 1243 1244 10
/**
 *
 */
121
inline void LMatrix3f::operator =(LMatrix3f const &other) = default;
inline void LMatrix3f::operator =(float fill_value);

3063 12 operator new 0 4 3616 23 LMatrix3f::operator new 0 1 1245 0
122
inline void *LMatrix3f::operator new(std::size_t size);
inline void *LMatrix3f::operator new(std::size_t size, void *ptr);

3064 15 operator delete 0 4 3616 26 LMatrix3f::operator delete 0 0 0
106
inline void LMatrix3f::operator delete(void *ptr);
inline void LMatrix3f::operator delete(void *, void *);

3065 12 validate_ptr 0 4 3616 23 LMatrix3f::validate_ptr 0 0 0
60
static inline bool LMatrix3f::validate_ptr(void const *ptr);

3066 10 __reduce__ 0 4 3616 21 LMatrix3f::__reduce__ 0 1 1246 0
61
inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;

3067 4 fill 0 4 3616 15 LMatrix3f::fill 0 1 1247 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
39
void LMatrix3f::fill(float fill_value);

3068 3 set 0 4 3616 14 LMatrix3f::set 0 1 1248 10
/**
 *
 */
126
inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

3069 11 operator [] 0 4 3616 22 LMatrix3f::operator [] 0 2 1249 1250 0
112
inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;
inline LMatrix3f::Row LMatrix3f::operator [](int i);

3070 4 size 0 4 3616 15 LMatrix3f::size 0 1 1251 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3f::size(void);

3071 7 set_row 0 4 3616 18 LMatrix3f::set_row 0 2 1252 1253 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3f::set_row(int row, LVecBase3f const &v);
inline void LMatrix3f::set_row(int row, LVecBase2f const &v);

3072 7 set_col 0 4 3616 18 LMatrix3f::set_col 0 2 1254 1255 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3f::set_col(int col, LVecBase3f const &v);
inline void LMatrix3f::set_col(int col, LVecBase2f const &v);

3073 7 get_row 0 4 3616 18 LMatrix3f::get_row 0 2 1256 1257 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3f LMatrix3f::get_row(int row) const;
inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const;

3074 7 get_col 0 4 3616 18 LMatrix3f::get_col 0 1 1258 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3f LMatrix3f::get_col(int col) const;

3075 8 get_row2 0 4 3616 19 LMatrix3f::get_row2 0 1 1259 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2f LMatrix3f::get_row2(int row) const;

3076 8 get_col2 0 4 3616 19 LMatrix3f::get_col2 0 1 1260 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2f LMatrix3f::get_col2(int col) const;

3077 11 operator () 0 4 3616 22 LMatrix3f::operator () 0 2 1261 1262 10
/**
 *
 */
116
inline float &LMatrix3f::operator ()(int row, int col);
inline float LMatrix3f::operator ()(int row, int col) const;

3078 6 is_nan 0 4 3616 17 LMatrix3f::is_nan 0 1 1263 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3f::is_nan(void) const;

3079 11 is_identity 0 4 3616 22 LMatrix3f::is_identity 0 1 1264 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3f::is_identity(void) const;

3080 8 get_cell 0 4 3616 19 LMatrix3f::get_cell 0 1 1265 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix3f::get_cell(int row, int col) const;

3081 8 set_cell 0 4 3616 19 LMatrix3f::set_cell 0 1 1266 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix3f::set_cell(int row, int col, float value);

3082 8 get_data 0 4 3616 19 LMatrix3f::get_data 0 1 1267 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix3f::get_data(void) const;

3083 18 get_num_components 0 4 3616 29 LMatrix3f::get_num_components 0 1 1268 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3f::get_num_components(void) const;

3084 10 operator < 0 4 3616 21 LMatrix3f::operator < 0 1 1269 0
64
inline bool LMatrix3f::operator <(LMatrix3f const &other) const;

3085 11 operator == 0 4 3616 22 LMatrix3f::operator == 0 1 1270 0
65
inline bool LMatrix3f::operator ==(LMatrix3f const &other) const;

3086 11 operator != 0 4 3616 22 LMatrix3f::operator != 0 1 1271 0
65
inline bool LMatrix3f::operator !=(LMatrix3f const &other) const;

3087 10 compare_to 0 4 3616 21 LMatrix3f::compare_to 0 2 1272 1273 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix3f::compare_to(LMatrix3f const &other) const;
int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const;

3088 8 get_hash 0 4 3616 19 LMatrix3f::get_hash 0 2 1274 1275 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix3f::get_hash(void) const;
inline std::size_t LMatrix3f::get_hash(float threshold) const;

3089 8 add_hash 0 4 3616 19 LMatrix3f::add_hash 0 2 1276 1277 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;

3090 5 xform 0 4 3616 16 LMatrix3f::xform 0 1 1278 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const;

3091 11 xform_point 0 4 3616 22 LMatrix3f::xform_point 0 1 1279 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const;

3092 9 xform_vec 0 4 3616 20 LMatrix3f::xform_vec 0 2 1280 1281 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const;
inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const;

3093 17 xform_vec_general 0 4 3616 28 LMatrix3f::xform_vec_general 0 1 1282 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const;

3094 14 xform_in_place 0 4 3616 25 LMatrix3f::xform_in_place 0 1 1283 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3f::xform_in_place(LVecBase3f &v) const;

3095 20 xform_point_in_place 0 4 3616 31 LMatrix3f::xform_point_in_place 0 1 1284 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const;

3096 18 xform_vec_in_place 0 4 3616 29 LMatrix3f::xform_vec_in_place 0 2 1285 1286 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const;
inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const;

3097 26 xform_vec_general_in_place 0 4 3616 37 LMatrix3f::xform_vec_general_in_place 0 1 1287 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const;

3098 8 multiply 0 4 3616 19 LMatrix3f::multiply 0 1 1288 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2);

3099 10 operator * 0 4 3616 21 LMatrix3f::operator * 0 2 1289 1290 0
129
inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const;
inline LMatrix3f LMatrix3f::operator *(float scalar) const;

3100 10 operator / 0 4 3616 21 LMatrix3f::operator / 0 1 1291 0
59
inline LMatrix3f LMatrix3f::operator /(float scalar) const;

3101 11 operator += 0 4 3616 22 LMatrix3f::operator += 0 1 1292 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other);

3102 11 operator -= 0 4 3616 22 LMatrix3f::operator -= 0 1 1293 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other);

3103 11 operator *= 0 4 3616 22 LMatrix3f::operator *= 0 2 1294 1295 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
121
inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator *=(float scalar);

3104 11 operator /= 0 4 3616 22 LMatrix3f::operator /= 0 1 1296 39
/**
 * Performs a memberwise scale.
 */
55
inline LMatrix3f &LMatrix3f::operator /=(float scalar);

3105 18 componentwise_mult 0 4 3616 29 LMatrix3f::componentwise_mult 0 1 1297 10
/**
 *
 */
66
inline void LMatrix3f::componentwise_mult(LMatrix3f const &other);

3106 11 determinant 0 4 3616 22 LMatrix3f::determinant 0 1 1298 49
/**
 * Returns the determinant of the matrix.
 */
48
inline float LMatrix3f::determinant(void) const;

3107 14 transpose_from 0 4 3616 25 LMatrix3f::transpose_from 0 1 1299 10
/**
 *
 */
62
inline void LMatrix3f::transpose_from(LMatrix3f const &other);

3108 18 transpose_in_place 0 4 3616 29 LMatrix3f::transpose_in_place 0 1 1300 10
/**
 *
 */
48
inline void LMatrix3f::transpose_in_place(void);

3109 11 invert_from 0 4 3616 22 LMatrix3f::invert_from 0 1 1301 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3f::invert_from(LMatrix3f const &other);

3110 15 invert_in_place 0 4 3616 26 LMatrix3f::invert_in_place 0 1 1302 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3f::invert_in_place(void);

3111 21 invert_transpose_from 0 4 3616 32 LMatrix3f::invert_transpose_from 0 2 1303 1304 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other);
inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other);

3112 9 ident_mat 0 4 3616 20 LMatrix3f::ident_mat 0 1 1305 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3f const &LMatrix3f::ident_mat(void);

3113 17 set_translate_mat 0 4 3616 28 LMatrix3f::set_translate_mat 0 1 1306 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans);

3114 14 set_rotate_mat 0 4 3616 25 LMatrix3f::set_rotate_mat 0 2 1307 1308 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
156
inline void LMatrix3f::set_rotate_mat(float angle);
void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3115 13 set_scale_mat 0 4 3616 24 LMatrix3f::set_scale_mat 0 2 1309 1310 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale);
inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale);

3116 13 translate_mat 0 4 3616 24 LMatrix3f::translate_mat 0 2 1311 1312 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
144
static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans);
static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);

3117 10 rotate_mat 0 4 3616 21 LMatrix3f::rotate_mat 0 2 1313 1314 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
179
static inline LMatrix3f LMatrix3f::rotate_mat(float angle);
static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3118 9 scale_mat 0 4 3616 20 LMatrix3f::scale_mat 0 4 1315 1316 1317 1318 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
283
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);

3119 23 set_rotate_mat_normaxis 0 4 3616 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1319 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
113
void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3120 19 rotate_mat_normaxis 0 4 3616 30 LMatrix3f::rotate_mat_normaxis 0 1 1320 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
128
static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3121 13 set_shear_mat 0 4 3616 24 LMatrix3f::set_shear_mat 0 1 1321 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3122 9 shear_mat 0 4 3616 20 LMatrix3f::shear_mat 0 2 1322 1323 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3123 19 set_scale_shear_mat 0 4 3616 30 LMatrix3f::set_scale_shear_mat 0 1 1324 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3124 15 scale_shear_mat 0 4 3616 26 LMatrix3f::scale_shear_mat 0 2 1325 1326 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3125 11 convert_mat 0 4 3616 22 LMatrix3f::convert_mat 0 1 1327 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3126 12 almost_equal 0 4 3616 23 LMatrix3f::almost_equal 0 2 1328 1329 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
143
bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const;
inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const;

3127 6 output 0 4 3616 17 LMatrix3f::output 0 1 1330 10
/**
 *
 */
48
void LMatrix3f::output(std::ostream &out) const;

3128 5 write 0 4 3616 16 LMatrix3f::write 0 1 1331 10
/**
 *
 */
69
void LMatrix3f::write(std::ostream &out, int indent_level = 0) const;

3129 8 __repr__ 0 4 3616 19 LMatrix3f::__repr__ 0 1 1332 0
51
inline std::string LMatrix3f::__repr__(void) const;

3130 13 generate_hash 0 4 3616 24 LMatrix3f::generate_hash 0 2 1333 1334 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
161
inline void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

3131 20 write_datagram_fixed 0 4 3616 31 LMatrix3f::write_datagram_fixed 0 1 1335 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3f::write_datagram_fixed(Datagram &destination) const;

3132 19 read_datagram_fixed 0 4 3616 30 LMatrix3f::read_datagram_fixed 0 1 1336 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3f::read_datagram_fixed(DatagramIterator &scan);

3133 14 write_datagram 0 4 3616 25 LMatrix3f::write_datagram 0 1 1337 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3f::write_datagram(Datagram &destination) const;

3134 13 read_datagram 0 4 3616 24 LMatrix3f::read_datagram 0 1 1338 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3f::read_datagram(DatagramIterator &source);

3135 14 get_class_type 0 4 3616 25 LMatrix3f::get_class_type 0 1 1339 0
50
static TypeHandle LMatrix3f::get_class_type(void);

3136 10 ~LMatrix3f 0 4 3616 21 LMatrix3f::~LMatrix3f 0 0 0
28
LMatrix3f::~LMatrix3f(void);

3137 9 transpose 0 1 0 9 transpose 0 4 1911 1912 1913 1914 0
191
inline LMatrix3f transpose(LMatrix3f const &a);
inline LMatrix4f transpose(LMatrix4f const &a);
inline LMatrix3d transpose(LMatrix3d const &a);
inline LMatrix4d transpose(LMatrix4d const &a);

3138 6 invert 0 1 0 6 invert 0 6 1915 1916 1917 1918 1919 1920 0
281
inline LMatrix3f invert(LMatrix3f const &a);
inline LMatrix4f invert(LMatrix4f const &a);
inline LMatrix3d invert(LMatrix3d const &a);
inline LMatrix4d invert(LMatrix4d const &a);
inline LQuaternionf invert(LQuaternionf const &a);
inline LQuaterniond invert(LQuaterniond const &a);

3139 11 operator [] 0 4 3622 27 LMatrix4f::Row::operator [] 0 2 1461 1462 10
/**
 *
 */
104
inline float LMatrix4f::Row::operator [](int i) const;
inline float &LMatrix4f::Row::operator [](int i);

3140 4 size 0 4 3622 20 LMatrix4f::Row::size 0 1 1463 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4f::Row::size(void);

3141 17 operator typecast 0 132 3622 33 LMatrix4f::Row::operator typecast 0 1 1464 0
47
inline operator LVecBase4f const &(void) const;

3142 3 Row 0 4 3622 19 LMatrix4f::Row::Row 0 1 1460 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default;

3143 4 ~Row 0 4 3622 20 LMatrix4f::Row::~Row 0 0 0
27
LMatrix4f::Row::~Row(void);

3144 11 operator [] 0 4 3623 28 LMatrix4f::CRow::operator [] 0 1 1466 0
55
inline float LMatrix4f::CRow::operator [](int i) const;

3145 4 size 0 4 3623 21 LMatrix4f::CRow::size 0 1 1467 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4f::CRow::size(void);

3146 17 operator typecast 0 132 3623 34 LMatrix4f::CRow::operator typecast 0 1 1468 0
47
inline operator LVecBase4f const &(void) const;

3147 4 CRow 0 4 3623 21 LMatrix4f::CRow::CRow 0 1 1465 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default;

3148 5 ~CRow 0 4 3623 22 LMatrix4f::CRow::~CRow 0 0 0
29
LMatrix4f::CRow::~CRow(void);

3149 9 LMatrix4f 0 4 3620 20 LMatrix4f::LMatrix4f 0 7 1349 1350 1351 1352 1353 1354 1355 204
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
568
inline LMatrix4f::LMatrix4f(void) = default;
inline LMatrix4f::LMatrix4f(LMatrix4f const &other) = default;
inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other);
inline LMatrix4f::LMatrix4f(float , float , float , float , float , float , float , float , float , float , float , float , float , float , float , float );
inline LMatrix4f::LMatrix4f(LVecBase4f const &, LVecBase4f const &, LVecBase4f const &, LVecBase4f const &);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans);

3150 10 operator = 0 4 3620 21 LMatrix4f::operator = 0 3 1356 1357 1358 22
/**
 *
 */

/**
 *
 */
189
inline void LMatrix4f::operator =(LMatrix4f const &other) = default;
inline void LMatrix4f::operator =(UnalignedLMatrix4f const &other);
inline void LMatrix4f::operator =(float fill_value);

3151 12 operator new 0 4 3620 23 LMatrix4f::operator new 0 1 1359 0
122
inline void *LMatrix4f::operator new(std::size_t size);
inline void *LMatrix4f::operator new(std::size_t size, void *ptr);

3152 15 operator delete 0 4 3620 26 LMatrix4f::operator delete 0 0 0
106
inline void LMatrix4f::operator delete(void *ptr);
inline void LMatrix4f::operator delete(void *, void *);

3153 12 validate_ptr 0 4 3620 23 LMatrix4f::validate_ptr 0 0 0
60
static inline bool LMatrix4f::validate_ptr(void const *ptr);

3154 10 __reduce__ 0 4 3620 21 LMatrix4f::__reduce__ 0 1 1360 0
61
inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;

3155 4 fill 0 4 3620 15 LMatrix4f::fill 0 1 1361 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
46
inline void LMatrix4f::fill(float fill_value);

3156 3 set 0 4 3620 14 LMatrix4f::set 0 1 1362 10
/**
 *
 */
203
inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3157 11 set_upper_3 0 4 3620 22 LMatrix4f::set_upper_3 0 1 1363 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3);

3158 11 get_upper_3 0 4 3620 22 LMatrix4f::get_upper_3 0 1 1364 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3f LMatrix4f::get_upper_3(void) const;

3159 11 operator [] 0 4 3620 22 LMatrix4f::operator [] 0 2 1365 1366 0
112
inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;
inline LMatrix4f::Row LMatrix4f::operator [](int i);

3160 4 size 0 4 3620 15 LMatrix4f::size 0 1 1367 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4f::size(void);

3161 7 set_row 0 4 3620 18 LMatrix4f::set_row 0 2 1368 1369 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4f::set_row(int row, LVecBase4f const &v);
inline void LMatrix4f::set_row(int row, LVecBase3f const &v);

3162 7 set_col 0 4 3620 18 LMatrix4f::set_col 0 2 1370 1371 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4f::set_col(int col, LVecBase4f const &v);
inline void LMatrix4f::set_col(int col, LVecBase3f const &v);

3163 7 get_row 0 4 3620 18 LMatrix4f::get_row 0 2 1372 1373 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4f LMatrix4f::get_row(int row) const;
inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const;

3164 7 get_col 0 4 3620 18 LMatrix4f::get_col 0 1 1374 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4f LMatrix4f::get_col(int col) const;

3165 8 get_row3 0 4 3620 19 LMatrix4f::get_row3 0 2 1375 1376 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3f LMatrix4f::get_row3(int row) const;
inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const;

3166 8 get_col3 0 4 3620 19 LMatrix4f::get_col3 0 1 1377 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3f LMatrix4f::get_col3(int col) const;

3167 11 operator () 0 4 3620 22 LMatrix4f::operator () 0 2 1378 1379 10
/**
 *
 */
116
inline float &LMatrix4f::operator ()(int row, int col);
inline float LMatrix4f::operator ()(int row, int col) const;

3168 6 is_nan 0 4 3620 17 LMatrix4f::is_nan 0 1 1380 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4f::is_nan(void) const;

3169 11 is_identity 0 4 3620 22 LMatrix4f::is_identity 0 1 1381 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4f::is_identity(void) const;

3170 8 get_cell 0 4 3620 19 LMatrix4f::get_cell 0 1 1382 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix4f::get_cell(int row, int col) const;

3171 8 set_cell 0 4 3620 19 LMatrix4f::set_cell 0 1 1383 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix4f::set_cell(int row, int col, float value);

3172 8 get_data 0 4 3620 19 LMatrix4f::get_data 0 1 1384 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix4f::get_data(void) const;

3173 18 get_num_components 0 4 3620 29 LMatrix4f::get_num_components 0 1 1385 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4f::get_num_components(void) const;

3174 5 begin 0 4 3620 16 LMatrix4f::begin 0 2 1386 1387 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4f::iterator LMatrix4f::begin(void);
inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;

3175 3 end 0 4 3620 14 LMatrix4f::end 0 2 1388 1389 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4f::iterator LMatrix4f::end(void);
inline LMatrix4f::const_iterator LMatrix4f::end(void) const;

3176 10 operator < 0 4 3620 21 LMatrix4f::operator < 0 1 1390 0
64
inline bool LMatrix4f::operator <(LMatrix4f const &other) const;

3177 11 operator == 0 4 3620 22 LMatrix4f::operator == 0 1 1391 0
65
inline bool LMatrix4f::operator ==(LMatrix4f const &other) const;

3178 11 operator != 0 4 3620 22 LMatrix4f::operator != 0 1 1392 0
65
inline bool LMatrix4f::operator !=(LMatrix4f const &other) const;

3179 10 compare_to 0 4 3620 21 LMatrix4f::compare_to 0 2 1393 1394 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix4f::compare_to(LMatrix4f const &other) const;
int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const;

3180 8 get_hash 0 4 3620 19 LMatrix4f::get_hash 0 2 1395 1396 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix4f::get_hash(void) const;
inline std::size_t LMatrix4f::get_hash(float threshold) const;

3181 8 add_hash 0 4 3620 19 LMatrix4f::add_hash 0 2 1397 1398 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;

3182 5 xform 0 4 3620 16 LMatrix4f::xform 0 1 1399 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const;

3183 11 xform_point 0 4 3620 22 LMatrix4f::xform_point 0 1 1400 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const;

3184 19 xform_point_general 0 4 3620 30 LMatrix4f::xform_point_general 0 1 1401 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const;

3185 9 xform_vec 0 4 3620 20 LMatrix4f::xform_vec 0 1 1402 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const;

3186 17 xform_vec_general 0 4 3620 28 LMatrix4f::xform_vec_general 0 1 1403 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const;

3187 14 xform_in_place 0 4 3620 25 LMatrix4f::xform_in_place 0 1 1404 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4f::xform_in_place(LVecBase4f &v) const;

3188 20 xform_point_in_place 0 4 3620 31 LMatrix4f::xform_point_in_place 0 1 1405 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const;

3189 28 xform_point_general_in_place 0 4 3620 39 LMatrix4f::xform_point_general_in_place 0 1 1406 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const;

3190 18 xform_vec_in_place 0 4 3620 29 LMatrix4f::xform_vec_in_place 0 1 1407 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const;

3191 26 xform_vec_general_in_place 0 4 3620 37 LMatrix4f::xform_vec_general_in_place 0 1 1408 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const;

3192 8 multiply 0 4 3620 19 LMatrix4f::multiply 0 1 1409 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2);

3193 10 operator * 0 4 3620 21 LMatrix4f::operator * 0 2 1410 1411 0
129
inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const;
inline LMatrix4f LMatrix4f::operator *(float scalar) const;

3194 10 operator / 0 4 3620 21 LMatrix4f::operator / 0 1 1412 0
59
inline LMatrix4f LMatrix4f::operator /(float scalar) const;

3195 11 operator += 0 4 3620 22 LMatrix4f::operator += 0 1 1413 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other);

3196 11 operator -= 0 4 3620 22 LMatrix4f::operator -= 0 1 1414 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other);

3197 11 operator *= 0 4 3620 22 LMatrix4f::operator *= 0 2 1415 1416 22
/**
 *
 */

/**
 *
 */
121
inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator *=(float scalar);

3198 11 operator /= 0 4 3620 22 LMatrix4f::operator /= 0 1 1417 10
/**
 *
 */
55
inline LMatrix4f &LMatrix4f::operator /=(float scalar);

3199 18 componentwise_mult 0 4 3620 29 LMatrix4f::componentwise_mult 0 1 1418 10
/**
 *
 */
66
inline void LMatrix4f::componentwise_mult(LMatrix4f const &other);

3200 14 transpose_from 0 4 3620 25 LMatrix4f::transpose_from 0 1 1419 10
/**
 *
 */
62
inline void LMatrix4f::transpose_from(LMatrix4f const &other);

3201 18 transpose_in_place 0 4 3620 29 LMatrix4f::transpose_in_place 0 1 1420 10
/**
 *
 */
48
inline void LMatrix4f::transpose_in_place(void);

3202 11 invert_from 0 4 3620 22 LMatrix4f::invert_from 0 1 1421 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4f::invert_from(LMatrix4f const &other);

3203 18 invert_affine_from 0 4 3620 29 LMatrix4f::invert_affine_from 0 1 1422 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other);

3204 15 invert_in_place 0 4 3620 26 LMatrix4f::invert_in_place 0 1 1423 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4f::invert_in_place(void);

3205 10 accumulate 0 4 3620 21 LMatrix4f::accumulate 0 1 1424 48
/**
 * Computes `(*this) += other * weight`.
 */
72
inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight);

3206 9 ident_mat 0 4 3620 20 LMatrix4f::ident_mat 0 1 1425 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4f const &LMatrix4f::ident_mat(void);

3207 8 ones_mat 0 4 3620 19 LMatrix4f::ones_mat 0 1 1426 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4f const &LMatrix4f::ones_mat(void);

3208 9 zeros_mat 0 4 3620 20 LMatrix4f::zeros_mat 0 1 1427 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4f const &LMatrix4f::zeros_mat(void);

3209 17 set_translate_mat 0 4 3620 28 LMatrix4f::set_translate_mat 0 1 1428 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans);

3210 14 set_rotate_mat 0 4 3620 25 LMatrix4f::set_rotate_mat 0 1 1429 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
104
void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3211 23 set_rotate_mat_normaxis 0 4 3620 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1430 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
113
void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3212 13 set_scale_mat 0 4 3620 24 LMatrix4f::set_scale_mat 0 1 1431 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale);

3213 13 set_shear_mat 0 4 3620 24 LMatrix4f::set_shear_mat 0 1 1432 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3214 19 set_scale_shear_mat 0 4 3620 30 LMatrix4f::set_scale_shear_mat 0 1 1433 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3215 13 translate_mat 0 4 3620 24 LMatrix4f::translate_mat 0 2 1434 1435 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
154
static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans);
static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);

3216 10 rotate_mat 0 4 3620 21 LMatrix4f::rotate_mat 0 1 1436 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
119
static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3217 19 rotate_mat_normaxis 0 4 3620 30 LMatrix4f::rotate_mat_normaxis 0 1 1437 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
128
static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3218 9 scale_mat 0 4 3620 20 LMatrix4f::scale_mat 0 3 1438 1439 1440 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
205
static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale);
static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);
static inline LMatrix4f LMatrix4f::scale_mat(float scale);

3219 9 shear_mat 0 4 3620 20 LMatrix4f::shear_mat 0 2 1441 1442 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3220 15 scale_shear_mat 0 4 3620 26 LMatrix4f::scale_shear_mat 0 2 1443 1444 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3221 13 y_to_z_up_mat 0 4 3620 24 LMatrix4f::y_to_z_up_mat 0 1 1445 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void);

3222 13 z_to_y_up_mat 0 4 3620 24 LMatrix4f::z_to_y_up_mat 0 1 1446 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void);

3223 11 convert_mat 0 4 3620 22 LMatrix4f::convert_mat 0 1 1447 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3224 12 almost_equal 0 4 3620 23 LMatrix4f::almost_equal 0 2 1448 1449 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
143
bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const;
inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const;

3225 6 output 0 4 3620 17 LMatrix4f::output 0 1 1450 10
/**
 *
 */
48
void LMatrix4f::output(std::ostream &out) const;

3226 5 write 0 4 3620 16 LMatrix4f::write 0 1 1451 10
/**
 *
 */
69
void LMatrix4f::write(std::ostream &out, int indent_level = 0) const;

3227 8 __repr__ 0 4 3620 19 LMatrix4f::__repr__ 0 1 1452 0
51
inline std::string LMatrix4f::__repr__(void) const;

3228 13 generate_hash 0 4 3620 24 LMatrix4f::generate_hash 0 2 1453 1454 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
157
inline void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen, float scale) const;

3229 20 write_datagram_fixed 0 4 3620 31 LMatrix4f::write_datagram_fixed 0 1 1455 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4f::write_datagram_fixed(Datagram &destination) const;

3230 19 read_datagram_fixed 0 4 3620 30 LMatrix4f::read_datagram_fixed 0 1 1456 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4f::read_datagram_fixed(DatagramIterator &scan);

3231 14 write_datagram 0 4 3620 25 LMatrix4f::write_datagram 0 1 1457 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4f::write_datagram(Datagram &destination) const;

3232 13 read_datagram 0 4 3620 24 LMatrix4f::read_datagram 0 1 1458 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4f::read_datagram(DatagramIterator &source);

3233 14 get_class_type 0 4 3620 25 LMatrix4f::get_class_type 0 1 1459 0
50
static TypeHandle LMatrix4f::get_class_type(void);

3234 10 ~LMatrix4f 0 4 3620 21 LMatrix4f::~LMatrix4f 0 0 0
28
LMatrix4f::~LMatrix4f(void);

3235 18 UnalignedLMatrix4f 0 4 3624 38 UnalignedLMatrix4f::UnalignedLMatrix4f 0 4 1469 1470 1471 1472 22
/**
 *
 */

/**
 *
 */
444
inline UnalignedLMatrix4f::UnalignedLMatrix4f(void) = default;
inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy) = default;
inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3236 10 operator = 0 4 3624 30 UnalignedLMatrix4f::operator = 0 2 1473 1474 10
/**
 *
 */
152
inline void UnalignedLMatrix4f::operator =(LMatrix4f const &copy);
inline void UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy) = default;

3237 3 set 0 4 3624 23 UnalignedLMatrix4f::set 0 1 1475 10
/**
 *
 */
212
inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3238 11 operator () 0 4 3624 31 UnalignedLMatrix4f::operator () 0 2 1476 1477 10
/**
 *
 */
134
inline float &UnalignedLMatrix4f::operator ()(int row, int col);
inline float UnalignedLMatrix4f::operator ()(int row, int col) const;

3239 8 get_data 0 4 3624 28 UnalignedLMatrix4f::get_data 0 1 1478 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
61
inline float const *UnalignedLMatrix4f::get_data(void) const;

3240 18 get_num_components 0 4 3624 38 UnalignedLMatrix4f::get_num_components 0 1 1479 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4f::get_num_components(void) const;

3241 11 operator == 0 4 3624 31 UnalignedLMatrix4f::operator == 0 1 1480 0
83
inline bool UnalignedLMatrix4f::operator ==(UnalignedLMatrix4f const &other) const;

3242 11 operator != 0 4 3624 31 UnalignedLMatrix4f::operator != 0 1 1481 0
83
inline bool UnalignedLMatrix4f::operator !=(UnalignedLMatrix4f const &other) const;

3243 14 get_class_type 0 4 3624 34 UnalignedLMatrix4f::get_class_type 0 1 1482 0
59
static TypeHandle UnalignedLMatrix4f::get_class_type(void);

3244 19 ~UnalignedLMatrix4f 0 4 3624 39 UnalignedLMatrix4f::~UnalignedLMatrix4f 0 0 0
46
UnalignedLMatrix4f::~UnalignedLMatrix4f(void);

3245 11 operator [] 0 4 3628 27 LMatrix3d::Row::operator [] 0 2 1585 1586 10
/**
 *
 */
106
inline double LMatrix3d::Row::operator [](int i) const;
inline double &LMatrix3d::Row::operator [](int i);

3246 4 size 0 4 3628 20 LMatrix3d::Row::size 0 1 1587 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3d::Row::size(void);

3247 17 operator typecast 0 132 3628 33 LMatrix3d::Row::operator typecast 0 1 1588 0
47
inline operator LVecBase3d const &(void) const;

3248 3 Row 0 4 3628 19 LMatrix3d::Row::Row 0 1 1584 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default;

3249 4 ~Row 0 4 3628 20 LMatrix3d::Row::~Row 0 0 0
27
LMatrix3d::Row::~Row(void);

3250 11 operator [] 0 4 3629 28 LMatrix3d::CRow::operator [] 0 1 1590 0
56
inline double LMatrix3d::CRow::operator [](int i) const;

3251 4 size 0 4 3629 21 LMatrix3d::CRow::size 0 1 1591 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3d::CRow::size(void);

3252 17 operator typecast 0 132 3629 34 LMatrix3d::CRow::operator typecast 0 1 1592 0
47
inline operator LVecBase3d const &(void) const;

3253 4 CRow 0 4 3629 21 LMatrix3d::CRow::CRow 0 1 1589 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default;

3254 5 ~CRow 0 4 3629 22 LMatrix3d::CRow::~CRow 0 0 0
29
LMatrix3d::CRow::~CRow(void);

3255 9 LMatrix3d 0 4 3626 20 LMatrix3d::LMatrix3d 0 4 1483 1484 1485 1486 72
/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
306
inline LMatrix3d::LMatrix3d(void) = default;
inline LMatrix3d::LMatrix3d(LMatrix3d const &other) = default;
inline LMatrix3d::LMatrix3d(double , double , double , double , double , double , double , double , double );
inline LMatrix3d::LMatrix3d(LVecBase3d const &, LVecBase3d const &, LVecBase3d const &);

3256 10 operator = 0 4 3626 21 LMatrix3d::operator = 0 2 1487 1488 10
/**
 *
 */
122
inline void LMatrix3d::operator =(LMatrix3d const &other) = default;
inline void LMatrix3d::operator =(double fill_value);

3257 12 operator new 0 4 3626 23 LMatrix3d::operator new 0 1 1489 0
122
inline void *LMatrix3d::operator new(std::size_t size);
inline void *LMatrix3d::operator new(std::size_t size, void *ptr);

3258 15 operator delete 0 4 3626 26 LMatrix3d::operator delete 0 0 0
106
inline void LMatrix3d::operator delete(void *ptr);
inline void LMatrix3d::operator delete(void *, void *);

3259 12 validate_ptr 0 4 3626 23 LMatrix3d::validate_ptr 0 0 0
60
static inline bool LMatrix3d::validate_ptr(void const *ptr);

3260 10 __reduce__ 0 4 3626 21 LMatrix3d::__reduce__ 0 1 1490 0
61
inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;

3261 4 fill 0 4 3626 15 LMatrix3d::fill 0 1 1491 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
40
void LMatrix3d::fill(double fill_value);

3262 3 set 0 4 3626 14 LMatrix3d::set 0 1 1492 10
/**
 *
 */
135
inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3263 11 operator [] 0 4 3626 22 LMatrix3d::operator [] 0 2 1493 1494 0
112
inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;
inline LMatrix3d::Row LMatrix3d::operator [](int i);

3264 4 size 0 4 3626 15 LMatrix3d::size 0 1 1495 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3d::size(void);

3265 7 set_row 0 4 3626 18 LMatrix3d::set_row 0 2 1496 1497 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3d::set_row(int row, LVecBase3d const &v);
inline void LMatrix3d::set_row(int row, LVecBase2d const &v);

3266 7 set_col 0 4 3626 18 LMatrix3d::set_col 0 2 1498 1499 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3d::set_col(int col, LVecBase3d const &v);
inline void LMatrix3d::set_col(int col, LVecBase2d const &v);

3267 7 get_row 0 4 3626 18 LMatrix3d::get_row 0 2 1500 1501 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3d LMatrix3d::get_row(int row) const;
inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const;

3268 7 get_col 0 4 3626 18 LMatrix3d::get_col 0 1 1502 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3d LMatrix3d::get_col(int col) const;

3269 8 get_row2 0 4 3626 19 LMatrix3d::get_row2 0 1 1503 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2d LMatrix3d::get_row2(int row) const;

3270 8 get_col2 0 4 3626 19 LMatrix3d::get_col2 0 1 1504 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2d LMatrix3d::get_col2(int col) const;

3271 11 operator () 0 4 3626 22 LMatrix3d::operator () 0 2 1505 1506 10
/**
 *
 */
118
inline double &LMatrix3d::operator ()(int row, int col);
inline double LMatrix3d::operator ()(int row, int col) const;

3272 6 is_nan 0 4 3626 17 LMatrix3d::is_nan 0 1 1507 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3d::is_nan(void) const;

3273 11 is_identity 0 4 3626 22 LMatrix3d::is_identity 0 1 1508 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3d::is_identity(void) const;

3274 8 get_cell 0 4 3626 19 LMatrix3d::get_cell 0 1 1509 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix3d::get_cell(int row, int col) const;

3275 8 set_cell 0 4 3626 19 LMatrix3d::set_cell 0 1 1510 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix3d::set_cell(int row, int col, double value);

3276 8 get_data 0 4 3626 19 LMatrix3d::get_data 0 1 1511 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix3d::get_data(void) const;

3277 18 get_num_components 0 4 3626 29 LMatrix3d::get_num_components 0 1 1512 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3d::get_num_components(void) const;

3278 10 operator < 0 4 3626 21 LMatrix3d::operator < 0 1 1513 0
64
inline bool LMatrix3d::operator <(LMatrix3d const &other) const;

3279 11 operator == 0 4 3626 22 LMatrix3d::operator == 0 1 1514 0
65
inline bool LMatrix3d::operator ==(LMatrix3d const &other) const;

3280 11 operator != 0 4 3626 22 LMatrix3d::operator != 0 1 1515 0
65
inline bool LMatrix3d::operator !=(LMatrix3d const &other) const;

3281 10 compare_to 0 4 3626 21 LMatrix3d::compare_to 0 2 1516 1517 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix3d::compare_to(LMatrix3d const &other) const;
int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const;

3282 8 get_hash 0 4 3626 19 LMatrix3d::get_hash 0 2 1518 1519 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix3d::get_hash(void) const;
inline std::size_t LMatrix3d::get_hash(double threshold) const;

3283 8 add_hash 0 4 3626 19 LMatrix3d::add_hash 0 2 1520 1521 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;

3284 5 xform 0 4 3626 16 LMatrix3d::xform 0 1 1522 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const;

3285 11 xform_point 0 4 3626 22 LMatrix3d::xform_point 0 1 1523 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const;

3286 9 xform_vec 0 4 3626 20 LMatrix3d::xform_vec 0 2 1524 1525 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const;
inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const;

3287 17 xform_vec_general 0 4 3626 28 LMatrix3d::xform_vec_general 0 1 1526 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const;

3288 14 xform_in_place 0 4 3626 25 LMatrix3d::xform_in_place 0 1 1527 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3d::xform_in_place(LVecBase3d &v) const;

3289 20 xform_point_in_place 0 4 3626 31 LMatrix3d::xform_point_in_place 0 1 1528 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const;

3290 18 xform_vec_in_place 0 4 3626 29 LMatrix3d::xform_vec_in_place 0 2 1529 1530 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const;
inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const;

3291 26 xform_vec_general_in_place 0 4 3626 37 LMatrix3d::xform_vec_general_in_place 0 1 1531 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const;

3292 8 multiply 0 4 3626 19 LMatrix3d::multiply 0 1 1532 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2);

3293 10 operator * 0 4 3626 21 LMatrix3d::operator * 0 2 1533 1534 0
130
inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const;
inline LMatrix3d LMatrix3d::operator *(double scalar) const;

3294 10 operator / 0 4 3626 21 LMatrix3d::operator / 0 1 1535 0
60
inline LMatrix3d LMatrix3d::operator /(double scalar) const;

3295 11 operator += 0 4 3626 22 LMatrix3d::operator += 0 1 1536 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other);

3296 11 operator -= 0 4 3626 22 LMatrix3d::operator -= 0 1 1537 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other);

3297 11 operator *= 0 4 3626 22 LMatrix3d::operator *= 0 2 1538 1539 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
122
inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator *=(double scalar);

3298 11 operator /= 0 4 3626 22 LMatrix3d::operator /= 0 1 1540 39
/**
 * Performs a memberwise scale.
 */
56
inline LMatrix3d &LMatrix3d::operator /=(double scalar);

3299 18 componentwise_mult 0 4 3626 29 LMatrix3d::componentwise_mult 0 1 1541 10
/**
 *
 */
66
inline void LMatrix3d::componentwise_mult(LMatrix3d const &other);

3300 11 determinant 0 4 3626 22 LMatrix3d::determinant 0 1 1542 49
/**
 * Returns the determinant of the matrix.
 */
49
inline double LMatrix3d::determinant(void) const;

3301 14 transpose_from 0 4 3626 25 LMatrix3d::transpose_from 0 1 1543 10
/**
 *
 */
62
inline void LMatrix3d::transpose_from(LMatrix3d const &other);

3302 18 transpose_in_place 0 4 3626 29 LMatrix3d::transpose_in_place 0 1 1544 10
/**
 *
 */
48
inline void LMatrix3d::transpose_in_place(void);

3303 11 invert_from 0 4 3626 22 LMatrix3d::invert_from 0 1 1545 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3d::invert_from(LMatrix3d const &other);

3304 15 invert_in_place 0 4 3626 26 LMatrix3d::invert_in_place 0 1 1546 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3d::invert_in_place(void);

3305 21 invert_transpose_from 0 4 3626 32 LMatrix3d::invert_transpose_from 0 2 1547 1548 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other);
inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other);

3306 9 ident_mat 0 4 3626 20 LMatrix3d::ident_mat 0 1 1549 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3d const &LMatrix3d::ident_mat(void);

3307 17 set_translate_mat 0 4 3626 28 LMatrix3d::set_translate_mat 0 1 1550 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans);

3308 14 set_rotate_mat 0 4 3626 25 LMatrix3d::set_rotate_mat 0 2 1551 1552 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
158
inline void LMatrix3d::set_rotate_mat(double angle);
void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3309 13 set_scale_mat 0 4 3626 24 LMatrix3d::set_scale_mat 0 2 1553 1554 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale);
inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale);

3310 13 translate_mat 0 4 3626 24 LMatrix3d::translate_mat 0 2 1555 1556 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
146
static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans);
static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);

3311 10 rotate_mat 0 4 3626 21 LMatrix3d::rotate_mat 0 2 1557 1558 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
181
static inline LMatrix3d LMatrix3d::rotate_mat(double angle);
static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3312 9 scale_mat 0 4 3626 20 LMatrix3d::scale_mat 0 4 1559 1560 1561 1562 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
288
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);

3313 23 set_rotate_mat_normaxis 0 4 3626 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1563 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
114
void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3314 19 rotate_mat_normaxis 0 4 3626 30 LMatrix3d::rotate_mat_normaxis 0 1 1564 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
129
static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3315 13 set_shear_mat 0 4 3626 24 LMatrix3d::set_shear_mat 0 1 1565 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3316 9 shear_mat 0 4 3626 20 LMatrix3d::shear_mat 0 2 1566 1567 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3317 19 set_scale_shear_mat 0 4 3626 30 LMatrix3d::set_scale_shear_mat 0 1 1568 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3318 15 scale_shear_mat 0 4 3626 26 LMatrix3d::scale_shear_mat 0 2 1569 1570 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3319 11 convert_mat 0 4 3626 22 LMatrix3d::convert_mat 0 1 1571 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3320 12 almost_equal 0 4 3626 23 LMatrix3d::almost_equal 0 2 1572 1573 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
144
bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const;
inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const;

3321 6 output 0 4 3626 17 LMatrix3d::output 0 1 1574 10
/**
 *
 */
48
void LMatrix3d::output(std::ostream &out) const;

3322 5 write 0 4 3626 16 LMatrix3d::write 0 1 1575 10
/**
 *
 */
69
void LMatrix3d::write(std::ostream &out, int indent_level = 0) const;

3323 8 __repr__ 0 4 3626 19 LMatrix3d::__repr__ 0 1 1576 0
51
inline std::string LMatrix3d::__repr__(void) const;

3324 13 generate_hash 0 4 3626 24 LMatrix3d::generate_hash 0 2 1577 1578 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
162
inline void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

3325 20 write_datagram_fixed 0 4 3626 31 LMatrix3d::write_datagram_fixed 0 1 1579 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3d::write_datagram_fixed(Datagram &destination) const;

3326 19 read_datagram_fixed 0 4 3626 30 LMatrix3d::read_datagram_fixed 0 1 1580 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3d::read_datagram_fixed(DatagramIterator &scan);

3327 14 write_datagram 0 4 3626 25 LMatrix3d::write_datagram 0 1 1581 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3d::write_datagram(Datagram &destination) const;

3328 13 read_datagram 0 4 3626 24 LMatrix3d::read_datagram 0 1 1582 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3d::read_datagram(DatagramIterator &source);

3329 14 get_class_type 0 4 3626 25 LMatrix3d::get_class_type 0 1 1583 0
50
static TypeHandle LMatrix3d::get_class_type(void);

3330 10 ~LMatrix3d 0 4 3626 21 LMatrix3d::~LMatrix3d 0 0 0
28
LMatrix3d::~LMatrix3d(void);

3331 11 operator [] 0 4 3632 27 LMatrix4d::Row::operator [] 0 2 1705 1706 10
/**
 *
 */
106
inline double LMatrix4d::Row::operator [](int i) const;
inline double &LMatrix4d::Row::operator [](int i);

3332 4 size 0 4 3632 20 LMatrix4d::Row::size 0 1 1707 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4d::Row::size(void);

3333 17 operator typecast 0 132 3632 33 LMatrix4d::Row::operator typecast 0 1 1708 0
47
inline operator LVecBase4d const &(void) const;

3334 3 Row 0 4 3632 19 LMatrix4d::Row::Row 0 1 1704 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default;

3335 4 ~Row 0 4 3632 20 LMatrix4d::Row::~Row 0 0 0
27
LMatrix4d::Row::~Row(void);

3336 11 operator [] 0 4 3633 28 LMatrix4d::CRow::operator [] 0 1 1710 0
56
inline double LMatrix4d::CRow::operator [](int i) const;

3337 4 size 0 4 3633 21 LMatrix4d::CRow::size 0 1 1711 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4d::CRow::size(void);

3338 17 operator typecast 0 132 3633 34 LMatrix4d::CRow::operator typecast 0 1 1712 0
47
inline operator LVecBase4d const &(void) const;

3339 4 CRow 0 4 3633 21 LMatrix4d::CRow::CRow 0 1 1709 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default;

3340 5 ~CRow 0 4 3633 22 LMatrix4d::CRow::~CRow 0 0 0
29
LMatrix4d::CRow::~CRow(void);

3341 9 LMatrix4d 0 4 3630 20 LMatrix4d::LMatrix4d 0 7 1593 1594 1595 1596 1597 1598 1599 204
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
584
inline LMatrix4d::LMatrix4d(void) = default;
inline LMatrix4d::LMatrix4d(LMatrix4d const &other) = default;
inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other);
inline LMatrix4d::LMatrix4d(double , double , double , double , double , double , double , double , double , double , double , double , double , double , double , double );
inline LMatrix4d::LMatrix4d(LVecBase4d const &, LVecBase4d const &, LVecBase4d const &, LVecBase4d const &);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans);

3342 10 operator = 0 4 3630 21 LMatrix4d::operator = 0 3 1600 1601 1602 22
/**
 *
 */

/**
 *
 */
190
inline void LMatrix4d::operator =(LMatrix4d const &other) = default;
inline void LMatrix4d::operator =(UnalignedLMatrix4d const &other);
inline void LMatrix4d::operator =(double fill_value);

3343 12 operator new 0 4 3630 23 LMatrix4d::operator new 0 1 1603 0
122
inline void *LMatrix4d::operator new(std::size_t size);
inline void *LMatrix4d::operator new(std::size_t size, void *ptr);

3344 15 operator delete 0 4 3630 26 LMatrix4d::operator delete 0 0 0
106
inline void LMatrix4d::operator delete(void *ptr);
inline void LMatrix4d::operator delete(void *, void *);

3345 12 validate_ptr 0 4 3630 23 LMatrix4d::validate_ptr 0 0 0
60
static inline bool LMatrix4d::validate_ptr(void const *ptr);

3346 10 __reduce__ 0 4 3630 21 LMatrix4d::__reduce__ 0 1 1604 0
61
inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;

3347 4 fill 0 4 3630 15 LMatrix4d::fill 0 1 1605 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
47
inline void LMatrix4d::fill(double fill_value);

3348 3 set 0 4 3630 14 LMatrix4d::set 0 1 1606 10
/**
 *
 */
219
inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3349 11 set_upper_3 0 4 3630 22 LMatrix4d::set_upper_3 0 1 1607 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3);

3350 11 get_upper_3 0 4 3630 22 LMatrix4d::get_upper_3 0 1 1608 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3d LMatrix4d::get_upper_3(void) const;

3351 11 operator [] 0 4 3630 22 LMatrix4d::operator [] 0 2 1609 1610 0
112
inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;
inline LMatrix4d::Row LMatrix4d::operator [](int i);

3352 4 size 0 4 3630 15 LMatrix4d::size 0 1 1611 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4d::size(void);

3353 7 set_row 0 4 3630 18 LMatrix4d::set_row 0 2 1612 1613 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4d::set_row(int row, LVecBase4d const &v);
inline void LMatrix4d::set_row(int row, LVecBase3d const &v);

3354 7 set_col 0 4 3630 18 LMatrix4d::set_col 0 2 1614 1615 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4d::set_col(int col, LVecBase4d const &v);
inline void LMatrix4d::set_col(int col, LVecBase3d const &v);

3355 7 get_row 0 4 3630 18 LMatrix4d::get_row 0 2 1616 1617 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4d LMatrix4d::get_row(int row) const;
inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const;

3356 7 get_col 0 4 3630 18 LMatrix4d::get_col 0 1 1618 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4d LMatrix4d::get_col(int col) const;

3357 8 get_row3 0 4 3630 19 LMatrix4d::get_row3 0 2 1619 1620 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3d LMatrix4d::get_row3(int row) const;
inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const;

3358 8 get_col3 0 4 3630 19 LMatrix4d::get_col3 0 1 1621 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3d LMatrix4d::get_col3(int col) const;

3359 11 operator () 0 4 3630 22 LMatrix4d::operator () 0 2 1622 1623 10
/**
 *
 */
118
inline double &LMatrix4d::operator ()(int row, int col);
inline double LMatrix4d::operator ()(int row, int col) const;

3360 6 is_nan 0 4 3630 17 LMatrix4d::is_nan 0 1 1624 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4d::is_nan(void) const;

3361 11 is_identity 0 4 3630 22 LMatrix4d::is_identity 0 1 1625 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4d::is_identity(void) const;

3362 8 get_cell 0 4 3630 19 LMatrix4d::get_cell 0 1 1626 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix4d::get_cell(int row, int col) const;

3363 8 set_cell 0 4 3630 19 LMatrix4d::set_cell 0 1 1627 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix4d::set_cell(int row, int col, double value);

3364 8 get_data 0 4 3630 19 LMatrix4d::get_data 0 1 1628 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix4d::get_data(void) const;

3365 18 get_num_components 0 4 3630 29 LMatrix4d::get_num_components 0 1 1629 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4d::get_num_components(void) const;

3366 5 begin 0 4 3630 16 LMatrix4d::begin 0 2 1630 1631 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4d::iterator LMatrix4d::begin(void);
inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;

3367 3 end 0 4 3630 14 LMatrix4d::end 0 2 1632 1633 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4d::iterator LMatrix4d::end(void);
inline LMatrix4d::const_iterator LMatrix4d::end(void) const;

3368 10 operator < 0 4 3630 21 LMatrix4d::operator < 0 1 1634 0
64
inline bool LMatrix4d::operator <(LMatrix4d const &other) const;

3369 11 operator == 0 4 3630 22 LMatrix4d::operator == 0 1 1635 0
65
inline bool LMatrix4d::operator ==(LMatrix4d const &other) const;

3370 11 operator != 0 4 3630 22 LMatrix4d::operator != 0 1 1636 0
65
inline bool LMatrix4d::operator !=(LMatrix4d const &other) const;

3371 10 compare_to 0 4 3630 21 LMatrix4d::compare_to 0 2 1637 1638 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix4d::compare_to(LMatrix4d const &other) const;
int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const;

3372 8 get_hash 0 4 3630 19 LMatrix4d::get_hash 0 2 1639 1640 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix4d::get_hash(void) const;
inline std::size_t LMatrix4d::get_hash(double threshold) const;

3373 8 add_hash 0 4 3630 19 LMatrix4d::add_hash 0 2 1641 1642 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;

3374 5 xform 0 4 3630 16 LMatrix4d::xform 0 1 1643 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const;

3375 11 xform_point 0 4 3630 22 LMatrix4d::xform_point 0 1 1644 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const;

3376 19 xform_point_general 0 4 3630 30 LMatrix4d::xform_point_general 0 1 1645 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const;

3377 9 xform_vec 0 4 3630 20 LMatrix4d::xform_vec 0 1 1646 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const;

3378 17 xform_vec_general 0 4 3630 28 LMatrix4d::xform_vec_general 0 1 1647 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const;

3379 14 xform_in_place 0 4 3630 25 LMatrix4d::xform_in_place 0 1 1648 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4d::xform_in_place(LVecBase4d &v) const;

3380 20 xform_point_in_place 0 4 3630 31 LMatrix4d::xform_point_in_place 0 1 1649 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const;

3381 28 xform_point_general_in_place 0 4 3630 39 LMatrix4d::xform_point_general_in_place 0 1 1650 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const;

3382 18 xform_vec_in_place 0 4 3630 29 LMatrix4d::xform_vec_in_place 0 1 1651 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const;

3383 26 xform_vec_general_in_place 0 4 3630 37 LMatrix4d::xform_vec_general_in_place 0 1 1652 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const;

3384 8 multiply 0 4 3630 19 LMatrix4d::multiply 0 1 1653 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2);

3385 10 operator * 0 4 3630 21 LMatrix4d::operator * 0 2 1654 1655 0
130
inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const;
inline LMatrix4d LMatrix4d::operator *(double scalar) const;

3386 10 operator / 0 4 3630 21 LMatrix4d::operator / 0 1 1656 0
60
inline LMatrix4d LMatrix4d::operator /(double scalar) const;

3387 11 operator += 0 4 3630 22 LMatrix4d::operator += 0 1 1657 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other);

3388 11 operator -= 0 4 3630 22 LMatrix4d::operator -= 0 1 1658 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other);

3389 11 operator *= 0 4 3630 22 LMatrix4d::operator *= 0 2 1659 1660 22
/**
 *
 */

/**
 *
 */
122
inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator *=(double scalar);

3390 11 operator /= 0 4 3630 22 LMatrix4d::operator /= 0 1 1661 10
/**
 *
 */
56
inline LMatrix4d &LMatrix4d::operator /=(double scalar);

3391 18 componentwise_mult 0 4 3630 29 LMatrix4d::componentwise_mult 0 1 1662 10
/**
 *
 */
66
inline void LMatrix4d::componentwise_mult(LMatrix4d const &other);

3392 14 transpose_from 0 4 3630 25 LMatrix4d::transpose_from 0 1 1663 10
/**
 *
 */
62
inline void LMatrix4d::transpose_from(LMatrix4d const &other);

3393 18 transpose_in_place 0 4 3630 29 LMatrix4d::transpose_in_place 0 1 1664 10
/**
 *
 */
48
inline void LMatrix4d::transpose_in_place(void);

3394 11 invert_from 0 4 3630 22 LMatrix4d::invert_from 0 1 1665 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4d::invert_from(LMatrix4d const &other);

3395 18 invert_affine_from 0 4 3630 29 LMatrix4d::invert_affine_from 0 1 1666 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other);

3396 15 invert_in_place 0 4 3630 26 LMatrix4d::invert_in_place 0 1 1667 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4d::invert_in_place(void);

3397 10 accumulate 0 4 3630 21 LMatrix4d::accumulate 0 1 1668 48
/**
 * Computes `(*this) += other * weight`.
 */
73
inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight);

3398 9 ident_mat 0 4 3630 20 LMatrix4d::ident_mat 0 1 1669 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4d const &LMatrix4d::ident_mat(void);

3399 8 ones_mat 0 4 3630 19 LMatrix4d::ones_mat 0 1 1670 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4d const &LMatrix4d::ones_mat(void);

3400 9 zeros_mat 0 4 3630 20 LMatrix4d::zeros_mat 0 1 1671 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4d const &LMatrix4d::zeros_mat(void);

3401 17 set_translate_mat 0 4 3630 28 LMatrix4d::set_translate_mat 0 1 1672 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans);

3402 14 set_rotate_mat 0 4 3630 25 LMatrix4d::set_rotate_mat 0 1 1673 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
105
void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3403 23 set_rotate_mat_normaxis 0 4 3630 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1674 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
114
void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3404 13 set_scale_mat 0 4 3630 24 LMatrix4d::set_scale_mat 0 1 1675 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale);

3405 13 set_shear_mat 0 4 3630 24 LMatrix4d::set_shear_mat 0 1 1676 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3406 19 set_scale_shear_mat 0 4 3630 30 LMatrix4d::set_scale_shear_mat 0 1 1677 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3407 13 translate_mat 0 4 3630 24 LMatrix4d::translate_mat 0 2 1678 1679 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
157
static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans);
static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);

3408 10 rotate_mat 0 4 3630 21 LMatrix4d::rotate_mat 0 1 1680 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
120
static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3409 19 rotate_mat_normaxis 0 4 3630 30 LMatrix4d::rotate_mat_normaxis 0 1 1681 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
129
static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3410 9 scale_mat 0 4 3630 20 LMatrix4d::scale_mat 0 3 1682 1683 1684 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
209
static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale);
static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);
static inline LMatrix4d LMatrix4d::scale_mat(double scale);

3411 9 shear_mat 0 4 3630 20 LMatrix4d::shear_mat 0 2 1685 1686 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3412 15 scale_shear_mat 0 4 3630 26 LMatrix4d::scale_shear_mat 0 2 1687 1688 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3413 13 y_to_z_up_mat 0 4 3630 24 LMatrix4d::y_to_z_up_mat 0 1 1689 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void);

3414 13 z_to_y_up_mat 0 4 3630 24 LMatrix4d::z_to_y_up_mat 0 1 1690 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void);

3415 11 convert_mat 0 4 3630 22 LMatrix4d::convert_mat 0 1 1691 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3416 12 almost_equal 0 4 3630 23 LMatrix4d::almost_equal 0 2 1692 1693 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
144
bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const;
inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const;

3417 6 output 0 4 3630 17 LMatrix4d::output 0 1 1694 10
/**
 *
 */
48
void LMatrix4d::output(std::ostream &out) const;

3418 5 write 0 4 3630 16 LMatrix4d::write 0 1 1695 10
/**
 *
 */
69
void LMatrix4d::write(std::ostream &out, int indent_level = 0) const;

3419 8 __repr__ 0 4 3630 19 LMatrix4d::__repr__ 0 1 1696 0
51
inline std::string LMatrix4d::__repr__(void) const;

3420 13 generate_hash 0 4 3630 24 LMatrix4d::generate_hash 0 2 1697 1698 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
158
inline void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen, double scale) const;

3421 20 write_datagram_fixed 0 4 3630 31 LMatrix4d::write_datagram_fixed 0 1 1699 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4d::write_datagram_fixed(Datagram &destination) const;

3422 19 read_datagram_fixed 0 4 3630 30 LMatrix4d::read_datagram_fixed 0 1 1700 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4d::read_datagram_fixed(DatagramIterator &scan);

3423 14 write_datagram 0 4 3630 25 LMatrix4d::write_datagram 0 1 1701 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4d::write_datagram(Datagram &destination) const;

3424 13 read_datagram 0 4 3630 24 LMatrix4d::read_datagram 0 1 1702 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4d::read_datagram(DatagramIterator &source);

3425 14 get_class_type 0 4 3630 25 LMatrix4d::get_class_type 0 1 1703 0
50
static TypeHandle LMatrix4d::get_class_type(void);

3426 10 ~LMatrix4d 0 4 3630 21 LMatrix4d::~LMatrix4d 0 0 0
28
LMatrix4d::~LMatrix4d(void);

3427 18 UnalignedLMatrix4d 0 4 3634 38 UnalignedLMatrix4d::UnalignedLMatrix4d 0 4 1713 1714 1715 1716 22
/**
 *
 */

/**
 *
 */
460
inline UnalignedLMatrix4d::UnalignedLMatrix4d(void) = default;
inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy) = default;
inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3428 10 operator = 0 4 3634 30 UnalignedLMatrix4d::operator = 0 2 1717 1718 10
/**
 *
 */
152
inline void UnalignedLMatrix4d::operator =(LMatrix4d const &copy);
inline void UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy) = default;

3429 3 set 0 4 3634 23 UnalignedLMatrix4d::set 0 1 1719 10
/**
 *
 */
228
inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3430 11 operator () 0 4 3634 31 UnalignedLMatrix4d::operator () 0 2 1720 1721 10
/**
 *
 */
136
inline double &UnalignedLMatrix4d::operator ()(int row, int col);
inline double UnalignedLMatrix4d::operator ()(int row, int col) const;

3431 8 get_data 0 4 3634 28 UnalignedLMatrix4d::get_data 0 1 1722 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
62
inline double const *UnalignedLMatrix4d::get_data(void) const;

3432 18 get_num_components 0 4 3634 38 UnalignedLMatrix4d::get_num_components 0 1 1723 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4d::get_num_components(void) const;

3433 11 operator == 0 4 3634 31 UnalignedLMatrix4d::operator == 0 1 1724 0
83
inline bool UnalignedLMatrix4d::operator ==(UnalignedLMatrix4d const &other) const;

3434 11 operator != 0 4 3634 31 UnalignedLMatrix4d::operator != 0 1 1725 0
83
inline bool UnalignedLMatrix4d::operator !=(UnalignedLMatrix4d const &other) const;

3435 14 get_class_type 0 4 3634 34 UnalignedLMatrix4d::get_class_type 0 1 1726 0
59
static TypeHandle UnalignedLMatrix4d::get_class_type(void);

3436 19 ~UnalignedLMatrix4d 0 4 3634 39 UnalignedLMatrix4d::~UnalignedLMatrix4d 0 0 0
46
UnalignedLMatrix4d::~UnalignedLMatrix4d(void);

3437 10 operator * 0 1 0 10 operator * 0 24 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 0
1659
inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m);
inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m);
inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m);
inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m);
inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m);
inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m);
inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m);
inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m);
inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m);
inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m);
inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m);
inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m);
inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q);
inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q);
inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q);
inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q);

3438 11 operator *= 0 1 0 11 operator *= 0 16 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 0
941
inline void operator *=(LVecBase3f &v, LMatrix3f const &m);
inline void operator *=(LVector3f &v, LMatrix3f const &m);
inline void operator *=(LPoint3f &v, LMatrix3f const &m);
inline void operator *=(LVector2f &v, LMatrix3f const &m);
inline void operator *=(LPoint2f &v, LMatrix3f const &m);
inline void operator *=(LVecBase4f &v, LMatrix4f const &m);
inline void operator *=(LVector3f &v, LMatrix4f const &m);
inline void operator *=(LPoint3f &v, LMatrix4f const &m);
inline void operator *=(LVecBase3d &v, LMatrix3d const &m);
inline void operator *=(LVector3d &v, LMatrix3d const &m);
inline void operator *=(LPoint3d &v, LMatrix3d const &m);
inline void operator *=(LVector2d &v, LMatrix3d const &m);
inline void operator *=(LPoint2d &v, LMatrix3d const &m);
inline void operator *=(LVecBase4d &v, LMatrix4d const &m);
inline void operator *=(LVector3d &v, LMatrix4d const &m);
inline void operator *=(LPoint3d &v, LMatrix4d const &m);

3439 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 1961 1962 1963 1964 0
303
inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value);

3440 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 1965 1966 1967 1968 0
319
inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source);

3441 14 compose_matrix 0 1 0 14 compose_matrix 0 10 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 0
1484
void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);

3442 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 0
1408
bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);

3443 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 1989 1990 0
287
bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);

3444 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 1991 1992 0
107
LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr);
LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr);

3445 12 LQuaternionf 0 4 3636 26 LQuaternionf::LQuaternionf 0 5 1727 1728 1729 1730 1731 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
305
inline LQuaternionf::LQuaternionf(void);
inline LQuaternionf::LQuaternionf(LVecBase4f const &copy);
inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy);
inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);
inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default;

3446 14 pure_imaginary 0 4 3636 28 LQuaternionf::pure_imaginary 0 1 1732 10
/**
 *
 */
69
static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v);

3447 9 conjugate 0 4 3636 23 LQuaternionf::conjugate 0 1 1733 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaternionf LQuaternionf::conjugate(void) const;

3448 5 xform 0 4 3636 19 LQuaternionf::xform 0 2 1734 1735 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const;
inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const;

3449 8 multiply 0 4 3636 22 LQuaternionf::multiply 0 1 1736 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const;

3450 10 operator - 0 68 3636 24 LQuaternionf::operator - 0 1 1737 0
57
inline LQuaternionf LQuaternionf::operator -(void) const;

3451 10 operator + 0 4 3636 24 LQuaternionf::operator + 0 1 1738 0
78
inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const;

3452 10 operator - 0 4 3636 24 LQuaternionf::operator - 0 1 1739 0
78
inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const;

3453 9 angle_rad 0 4 3636 23 LQuaternionf::angle_rad 0 1 1740 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
70
inline float LQuaternionf::angle_rad(LQuaternionf const &other) const;

3454 9 angle_deg 0 4 3636 23 LQuaternionf::angle_deg 0 1 1741 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
70
inline float LQuaternionf::angle_deg(LQuaternionf const &other) const;

3455 10 operator * 0 4 3636 24 LQuaternionf::operator * 0 4 1742 1743 1744 1745 0
263
inline LQuaternionf LQuaternionf::operator *(float scalar) const;
inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const;
inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &);
inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &);

3456 10 operator / 0 4 3636 24 LQuaternionf::operator / 0 1 1746 0
65
inline LQuaternionf LQuaternionf::operator /(float scalar) const;

3457 11 operator *= 0 4 3636 25 LQuaternionf::operator *= 0 1 1747 10
/**
 *
 */
69
inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &);

3458 7 __pow__ 0 4 3636 21 LQuaternionf::__pow__ 0 1 1748 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
49
LQuaternionf LQuaternionf::__pow__(float ) const;

3459 12 almost_equal 0 4 3636 26 LQuaternionf::almost_equal 0 2 1749 1750 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
162
inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const;
inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const;

3460 17 is_same_direction 0 4 3636 31 LQuaternionf::is_same_direction 0 1 1751 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const;

3461 21 almost_same_direction 0 4 3636 35 LQuaternionf::almost_same_direction 0 1 1752 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
98
inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const;

3462 6 output 0 4 3636 20 LQuaternionf::output 0 1 1753 10
/**
 *
 */
55
inline void LQuaternionf::output(std::ostream &) const;

3463 17 extract_to_matrix 0 4 3636 31 LQuaternionf::extract_to_matrix 0 2 1754 1755 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaternionf::extract_to_matrix(LMatrix3f &m) const;
void LQuaternionf::extract_to_matrix(LMatrix4f &m) const;

3464 15 set_from_matrix 0 4 3636 29 LQuaternionf::set_from_matrix 0 2 1756 1757 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaternionf::set_from_matrix(LMatrix3f const &m);
inline void LQuaternionf::set_from_matrix(LMatrix4f const &m);

3465 7 set_hpr 0 4 3636 21 LQuaternionf::set_hpr 0 1 1758 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);

3466 7 get_hpr 0 4 3636 21 LQuaternionf::get_hpr 0 1 1759 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;

3467 8 get_axis 0 4 3636 22 LQuaternionf::get_axis 0 1 1760 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3f LQuaternionf::get_axis(void) const;

3468 19 get_axis_normalized 0 4 3636 33 LQuaternionf::get_axis_normalized 0 1 1761 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3f LQuaternionf::get_axis_normalized(void) const;

3469 13 get_angle_rad 0 4 3636 27 LQuaternionf::get_angle_rad 0 1 1762 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
53
inline float LQuaternionf::get_angle_rad(void) const;

3470 9 get_angle 0 4 3636 23 LQuaternionf::get_angle 0 1 1763 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
49
inline float LQuaternionf::get_angle(void) const;

3471 23 set_from_axis_angle_rad 0 4 3636 37 LQuaternionf::set_from_axis_angle_rad 0 1 1764 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
90
inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis);

3472 19 set_from_axis_angle 0 4 3636 33 LQuaternionf::set_from_axis_angle 0 1 1765 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
86
inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis);

3473 6 get_up 0 4 3636 20 LQuaternionf::get_up 0 1 1766 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;

3474 9 get_right 0 4 3636 23 LQuaternionf::get_right 0 1 1767 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;

3475 11 get_forward 0 4 3636 25 LQuaternionf::get_forward 0 1 1768 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;

3476 5 get_r 0 4 3636 19 LQuaternionf::get_r 0 1 1769 10
/**
 *
 */
45
inline float LQuaternionf::get_r(void) const;

3477 5 get_i 0 4 3636 19 LQuaternionf::get_i 0 1 1770 10
/**
 *
 */
45
inline float LQuaternionf::get_i(void) const;

3478 5 get_j 0 4 3636 19 LQuaternionf::get_j 0 1 1771 10
/**
 *
 */
45
inline float LQuaternionf::get_j(void) const;

3479 5 get_k 0 4 3636 19 LQuaternionf::get_k 0 1 1772 10
/**
 *
 */
45
inline float LQuaternionf::get_k(void) const;

3480 5 set_r 0 4 3636 19 LQuaternionf::set_r 0 1 1773 10
/**
 *
 */
41
inline void LQuaternionf::set_r(float r);

3481 5 set_i 0 4 3636 19 LQuaternionf::set_i 0 1 1774 10
/**
 *
 */
41
inline void LQuaternionf::set_i(float i);

3482 5 set_j 0 4 3636 19 LQuaternionf::set_j 0 1 1775 10
/**
 *
 */
41
inline void LQuaternionf::set_j(float j);

3483 5 set_k 0 4 3636 19 LQuaternionf::set_k 0 1 1776 10
/**
 *
 */
41
inline void LQuaternionf::set_k(float k);

3484 9 normalize 0 4 3636 23 LQuaternionf::normalize 0 1 1777 10
/**
 *
 */
42
inline bool LQuaternionf::normalize(void);

3485 14 conjugate_from 0 4 3636 28 LQuaternionf::conjugate_from 0 1 1778 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaternionf::conjugate_from(LQuaternionf const &other);

3486 18 conjugate_in_place 0 4 3636 32 LQuaternionf::conjugate_in_place 0 1 1779 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaternionf::conjugate_in_place(void);

3487 11 invert_from 0 4 3636 25 LQuaternionf::invert_from 0 1 1780 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaternionf::invert_from(LQuaternionf const &other);

3488 15 invert_in_place 0 4 3636 29 LQuaternionf::invert_in_place 0 1 1781 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaternionf::invert_in_place(void);

3489 11 is_identity 0 4 3636 25 LQuaternionf::is_identity 0 1 1782 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaternionf::is_identity(void) const;

3490 18 is_almost_identity 0 4 3636 32 LQuaternionf::is_almost_identity 0 1 1783 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
68
inline bool LQuaternionf::is_almost_identity(float tolerance) const;

3491 10 ident_quat 0 4 3636 24 LQuaternionf::ident_quat 0 1 1784 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaternionf const &LQuaternionf::ident_quat(void);

3492 14 get_class_type 0 4 3636 28 LQuaternionf::get_class_type 0 1 1785 0
53
static TypeHandle LQuaternionf::get_class_type(void);

3493 13 ~LQuaternionf 0 4 3636 27 LQuaternionf::~LQuaternionf 0 0 0
34
LQuaternionf::~LQuaternionf(void);

3494 12 LQuaterniond 0 4 3637 26 LQuaterniond::LQuaterniond 0 5 1786 1787 1788 1789 1790 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LQuaterniond::LQuaterniond(void);
inline LQuaterniond::LQuaterniond(LVecBase4d const &copy);
inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy);
inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);
inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default;

3495 14 pure_imaginary 0 4 3637 28 LQuaterniond::pure_imaginary 0 1 1791 10
/**
 *
 */
69
static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v);

3496 9 conjugate 0 4 3637 23 LQuaterniond::conjugate 0 1 1792 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaterniond LQuaterniond::conjugate(void) const;

3497 5 xform 0 4 3637 19 LQuaterniond::xform 0 2 1793 1794 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const;
inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const;

3498 8 multiply 0 4 3637 22 LQuaterniond::multiply 0 1 1795 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const;

3499 10 operator - 0 68 3637 24 LQuaterniond::operator - 0 1 1796 0
57
inline LQuaterniond LQuaterniond::operator -(void) const;

3500 10 operator + 0 4 3637 24 LQuaterniond::operator + 0 1 1797 0
78
inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const;

3501 10 operator - 0 4 3637 24 LQuaterniond::operator - 0 1 1798 0
78
inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const;

3502 9 angle_rad 0 4 3637 23 LQuaterniond::angle_rad 0 1 1799 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
71
inline double LQuaterniond::angle_rad(LQuaterniond const &other) const;

3503 9 angle_deg 0 4 3637 23 LQuaterniond::angle_deg 0 1 1800 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
71
inline double LQuaterniond::angle_deg(LQuaterniond const &other) const;

3504 10 operator * 0 4 3637 24 LQuaterniond::operator * 0 4 1801 1802 1803 1804 0
264
inline LQuaterniond LQuaterniond::operator *(double scalar) const;
inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const;
inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &);
inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &);

3505 10 operator / 0 4 3637 24 LQuaterniond::operator / 0 1 1805 0
66
inline LQuaterniond LQuaterniond::operator /(double scalar) const;

3506 11 operator *= 0 4 3637 25 LQuaterniond::operator *= 0 1 1806 10
/**
 *
 */
69
inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &);

3507 7 __pow__ 0 4 3637 21 LQuaterniond::__pow__ 0 1 1807 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
50
LQuaterniond LQuaterniond::__pow__(double ) const;

3508 12 almost_equal 0 4 3637 26 LQuaterniond::almost_equal 0 2 1808 1809 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
163
inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const;
inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const;

3509 17 is_same_direction 0 4 3637 31 LQuaterniond::is_same_direction 0 1 1810 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const;

3510 21 almost_same_direction 0 4 3637 35 LQuaterniond::almost_same_direction 0 1 1811 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
99
inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const;

3511 6 output 0 4 3637 20 LQuaterniond::output 0 1 1812 10
/**
 *
 */
55
inline void LQuaterniond::output(std::ostream &) const;

3512 17 extract_to_matrix 0 4 3637 31 LQuaterniond::extract_to_matrix 0 2 1813 1814 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaterniond::extract_to_matrix(LMatrix3d &m) const;
void LQuaterniond::extract_to_matrix(LMatrix4d &m) const;

3513 15 set_from_matrix 0 4 3637 29 LQuaterniond::set_from_matrix 0 2 1815 1816 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaterniond::set_from_matrix(LMatrix3d const &m);
inline void LQuaterniond::set_from_matrix(LMatrix4d const &m);

3514 7 set_hpr 0 4 3637 21 LQuaterniond::set_hpr 0 1 1817 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);

3515 7 get_hpr 0 4 3637 21 LQuaterniond::get_hpr 0 1 1818 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;

3516 8 get_axis 0 4 3637 22 LQuaterniond::get_axis 0 1 1819 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3d LQuaterniond::get_axis(void) const;

3517 19 get_axis_normalized 0 4 3637 33 LQuaterniond::get_axis_normalized 0 1 1820 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3d LQuaterniond::get_axis_normalized(void) const;

3518 13 get_angle_rad 0 4 3637 27 LQuaterniond::get_angle_rad 0 1 1821 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
54
inline double LQuaterniond::get_angle_rad(void) const;

3519 9 get_angle 0 4 3637 23 LQuaterniond::get_angle 0 1 1822 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
50
inline double LQuaterniond::get_angle(void) const;

3520 23 set_from_axis_angle_rad 0 4 3637 37 LQuaterniond::set_from_axis_angle_rad 0 1 1823 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
91
inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis);

3521 19 set_from_axis_angle 0 4 3637 33 LQuaterniond::set_from_axis_angle 0 1 1824 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
87
inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis);

3522 6 get_up 0 4 3637 20 LQuaterniond::get_up 0 1 1825 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;

3523 9 get_right 0 4 3637 23 LQuaterniond::get_right 0 1 1826 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;

3524 11 get_forward 0 4 3637 25 LQuaterniond::get_forward 0 1 1827 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;

3525 5 get_r 0 4 3637 19 LQuaterniond::get_r 0 1 1828 10
/**
 *
 */
46
inline double LQuaterniond::get_r(void) const;

3526 5 get_i 0 4 3637 19 LQuaterniond::get_i 0 1 1829 10
/**
 *
 */
46
inline double LQuaterniond::get_i(void) const;

3527 5 get_j 0 4 3637 19 LQuaterniond::get_j 0 1 1830 10
/**
 *
 */
46
inline double LQuaterniond::get_j(void) const;

3528 5 get_k 0 4 3637 19 LQuaterniond::get_k 0 1 1831 10
/**
 *
 */
46
inline double LQuaterniond::get_k(void) const;

3529 5 set_r 0 4 3637 19 LQuaterniond::set_r 0 1 1832 10
/**
 *
 */
42
inline void LQuaterniond::set_r(double r);

3530 5 set_i 0 4 3637 19 LQuaterniond::set_i 0 1 1833 10
/**
 *
 */
42
inline void LQuaterniond::set_i(double i);

3531 5 set_j 0 4 3637 19 LQuaterniond::set_j 0 1 1834 10
/**
 *
 */
42
inline void LQuaterniond::set_j(double j);

3532 5 set_k 0 4 3637 19 LQuaterniond::set_k 0 1 1835 10
/**
 *
 */
42
inline void LQuaterniond::set_k(double k);

3533 9 normalize 0 4 3637 23 LQuaterniond::normalize 0 1 1836 10
/**
 *
 */
42
inline bool LQuaterniond::normalize(void);

3534 14 conjugate_from 0 4 3637 28 LQuaterniond::conjugate_from 0 1 1837 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaterniond::conjugate_from(LQuaterniond const &other);

3535 18 conjugate_in_place 0 4 3637 32 LQuaterniond::conjugate_in_place 0 1 1838 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaterniond::conjugate_in_place(void);

3536 11 invert_from 0 4 3637 25 LQuaterniond::invert_from 0 1 1839 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaterniond::invert_from(LQuaterniond const &other);

3537 15 invert_in_place 0 4 3637 29 LQuaterniond::invert_in_place 0 1 1840 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaterniond::invert_in_place(void);

3538 11 is_identity 0 4 3637 25 LQuaterniond::is_identity 0 1 1841 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaterniond::is_identity(void) const;

3539 18 is_almost_identity 0 4 3637 32 LQuaterniond::is_almost_identity 0 1 1842 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
69
inline bool LQuaterniond::is_almost_identity(double tolerance) const;

3540 10 ident_quat 0 4 3637 24 LQuaterniond::ident_quat 0 1 1843 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaterniond const &LQuaterniond::ident_quat(void);

3541 14 get_class_type 0 4 3637 28 LQuaterniond::get_class_type 0 1 1844 0
53
static TypeHandle LQuaterniond::get_class_type(void);

3542 13 ~LQuaterniond 0 4 3637 27 LQuaterniond::~LQuaterniond 0 0 0
34
LQuaterniond::~LQuaterniond(void);

3543 10 LRotationf 0 4 3638 22 LRotationf::LRotationf 0 9 1845 1846 1847 1848 1849 1850 1851 1852 1853 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
500
inline LRotationf::LRotationf(void);
inline LRotationf::LRotationf(LQuaternionf const &c);
inline LRotationf::LRotationf(LVecBase4f const &copy);
inline LRotationf::LRotationf(float r, float i, float j, float k);
inline LRotationf::LRotationf(LVector3f const &axis, float angle);
inline LRotationf::LRotationf(LMatrix3f const &m);
inline LRotationf::LRotationf(LMatrix4f const &m);
inline LRotationf::LRotationf(float h, float p, float r);
inline LRotationf::LRotationf(LRotationf const &) = default;

3544 10 operator * 0 4 3638 22 LRotationf::operator * 0 3 1854 1855 1856 0
211
inline LRotationf LRotationf::operator *(float scalar) const;
inline LRotationf LRotationf::operator *(LRotationf const &other) const;
inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const;

3545 10 operator / 0 4 3638 22 LRotationf::operator / 0 1 1857 0
61
inline LRotationf LRotationf::operator /(float scalar) const;

3546 14 get_class_type 0 4 3638 26 LRotationf::get_class_type 0 1 1858 0
51
static TypeHandle LRotationf::get_class_type(void);

3547 11 ~LRotationf 0 4 3638 23 LRotationf::~LRotationf 0 0 0
30
LRotationf::~LRotationf(void);

3548 10 LRotationd 0 4 3639 22 LRotationd::LRotationd 0 9 1859 1860 1861 1862 1863 1864 1865 1866 1867 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
508
inline LRotationd::LRotationd(void);
inline LRotationd::LRotationd(LQuaterniond const &c);
inline LRotationd::LRotationd(LVecBase4d const &copy);
inline LRotationd::LRotationd(double r, double i, double j, double k);
inline LRotationd::LRotationd(LVector3d const &axis, double angle);
inline LRotationd::LRotationd(LMatrix3d const &m);
inline LRotationd::LRotationd(LMatrix4d const &m);
inline LRotationd::LRotationd(double h, double p, double r);
inline LRotationd::LRotationd(LRotationd const &) = default;

3549 10 operator * 0 4 3639 22 LRotationd::operator * 0 3 1868 1869 1870 0
212
inline LRotationd LRotationd::operator *(double scalar) const;
inline LRotationd LRotationd::operator *(LRotationd const &other) const;
inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const;

3550 10 operator / 0 4 3639 22 LRotationd::operator / 0 1 1871 0
62
inline LRotationd LRotationd::operator /(double scalar) const;

3551 14 get_class_type 0 4 3639 26 LRotationd::get_class_type 0 1 1872 0
51
static TypeHandle LRotationd::get_class_type(void);

3552 11 ~LRotationd 0 4 3639 23 LRotationd::~LRotationd 0 0 0
30
LRotationd::~LRotationd(void);

3553 13 LOrientationf 0 4 3640 28 LOrientationf::LOrientationf 0 7 1873 1874 1875 1876 1877 1878 1879 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
436
inline LOrientationf::LOrientationf(void);
inline LOrientationf::LOrientationf(LQuaternionf const &c);
inline LOrientationf::LOrientationf(float r, float i, float j, float k);
inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist);
inline LOrientationf::LOrientationf(LMatrix3f const &m);
inline LOrientationf::LOrientationf(LMatrix4f const &m);
inline LOrientationf::LOrientationf(LOrientationf const &) = default;

3554 10 operator * 0 4 3640 25 LOrientationf::operator * 0 2 1880 1881 0
159
inline LOrientationf LOrientationf::operator *(LRotationf const &other) const;
inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const;

3555 14 get_class_type 0 4 3640 29 LOrientationf::get_class_type 0 1 1882 0
54
static TypeHandle LOrientationf::get_class_type(void);

3556 14 ~LOrientationf 0 4 3640 29 LOrientationf::~LOrientationf 0 0 0
36
LOrientationf::~LOrientationf(void);

3557 13 LOrientationd 0 4 3641 28 LOrientationd::LOrientationd 0 7 1883 1884 1885 1886 1887 1888 1889 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
441
inline LOrientationd::LOrientationd(void);
inline LOrientationd::LOrientationd(LQuaterniond const &c);
inline LOrientationd::LOrientationd(double r, double i, double j, double k);
inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist);
inline LOrientationd::LOrientationd(LMatrix3d const &m);
inline LOrientationd::LOrientationd(LMatrix4d const &m);
inline LOrientationd::LOrientationd(LOrientationd const &) = default;

3558 10 operator * 0 4 3641 25 LOrientationd::operator * 0 2 1890 1891 0
159
inline LOrientationd LOrientationd::operator *(LRotationd const &other) const;
inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const;

3559 14 get_class_type 0 4 3641 29 LOrientationd::get_class_type 0 1 1892 0
54
static TypeHandle LOrientationd::get_class_type(void);

3560 14 ~LOrientationd 0 4 3641 29 LOrientationd::~LOrientationd 0 0 0
36
LOrientationd::~LOrientationd(void);

3561 19 ConfigVariableColor 0 4 3712 40 ConfigVariableColor::ConfigVariableColor 0 4 1893 1894 1895 1896 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
488
inline ConfigVariableColor::ConfigVariableColor(std::string const &name);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default;

3562 10 operator = 0 4 3712 31 ConfigVariableColor::operator = 0 1 1897 0
65
inline void ConfigVariableColor::operator =(LColor const &value);

3563 17 operator typecast 0 132 3712 38 ConfigVariableColor::operator typecast 0 1 1902 0
43
inline operator LColor const &(void) const;

3564 11 operator [] 0 4 3712 32 ConfigVariableColor::operator [] 0 1 1898 0
65
inline PN_stdfloat ConfigVariableColor::operator [](int n) const;

3565 9 set_value 0 4 3712 30 ConfigVariableColor::set_value 0 1 1899 48
/**
 * Reassigns the variable's local value.
 */
64
inline void ConfigVariableColor::set_value(LColor const &value);

3566 9 get_value 0 4 3712 30 ConfigVariableColor::get_value 0 1 1900 40
/**
 * Returns the variable's value.
 */
64
inline LColor const &ConfigVariableColor::get_value(void) const;

3567 17 get_default_value 0 4 3712 38 ConfigVariableColor::get_default_value 0 1 1901 48
/**
 * Returns the variable's default value.
 */
65
inline LColor ConfigVariableColor::get_default_value(void) const;

3568 20 ~ConfigVariableColor 0 4 3712 41 ConfigVariableColor::~ConfigVariableColor 0 0 0
48
ConfigVariableColor::~ConfigVariableColor(void);

1992
1 0 0 7 2 3714 1994 0 0 0 
2 0 0 7 2 3714 1994 0 0 1 6 param0 0 3715  
3 0 0 7 8 3717 2062 0 0 0 
4 0 0 7 8 3717 2062 0 0 1 6 param0 0 3718  
5 0 0 7 8 3717 2062 0 10 /**
 *
 */ 1 10 fill_value 1 3572  
6 0 0 7 8 3717 2062 0 10 /**
 *
 */ 2 1 x 1 3572  1 y 1 3572  
7 0 0 4 9 3722 0 0 0 2 4 this 3 3717  4 size 1 3720  
8 0 0 6 12 3717 0 0 0 2 4 this 3 3717  4 copy 1 3718  
9 0 0 6 12 3717 0 0 0 2 4 this 3 3717  10 fill_value 1 3572  
10 0 0 6 13 3718 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
11 0 0 6 14 3718 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
12 0 0 6 15 3718 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
13 0 0 6 16 3723 0 0 0 1 4 this 3 3718  
14 0 0 6 17 3723 0 0 0 2 4 this 3 3718  9 attr_name 1 3726  
15 0 0 6 18 3578 0 0 0 3 4 this 3 3717  9 attr_name 1 3726  6 assign 1 3723  
16 0 0 4 19 3722 0 0 10 /**
 *
 */ 3 4 this 3 3717  1 i 1 3578  10 assign_val 1 3572  
17 0 0 6 19 3572 0 0 0 2 4 this 3 3718  1 i 1 3578  
18 0 0 6 20 3578 0 0 0 0 
19 0 0 6 21 3727 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3718  
20 0 0 6 22 3572 0 0 10 /**
 *
 */ 2 4 this 3 3718  1 i 1 3578  
21 0 0 4 23 3722 0 0 10 /**
 *
 */ 3 4 this 3 3717  1 i 1 3578  5 value 1 3572  
22 0 0 6 24 3572 0 0 10 /**
 *
 */ 1 4 this 3 3718  
23 0 0 6 25 3572 0 0 10 /**
 *
 */ 1 4 this 3 3718  
24 0 0 4 26 3722 0 0 10 /**
 *
 */ 2 4 this 3 3717  5 value 1 3572  
25 0 0 4 27 3722 0 0 10 /**
 *
 */ 2 4 this 3 3717  5 value 1 3572  
26 0 0 4 31 3722 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3717  1 i 1 3578  5 value 1 3572  
27 0 0 4 32 3722 0 0 10 /**
 *
 */ 2 4 this 3 3717  5 value 1 3572  
28 0 0 4 33 3722 0 0 10 /**
 *
 */ 2 4 this 3 3717  5 value 1 3572  
29 0 0 4 34 3722 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3718  
30 0 0 6 35 3578 0 0 0 0 
31 0 0 4 36 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3717  10 fill_value 1 3572  
32 0 0 4 37 3722 0 0 10 /**
 *
 */ 3 4 this 3 3717  1 x 1 3572  1 y 1 3572  
33 0 0 6 38 3572 0 0 10 /**
 *
 */ 2 4 this 3 3718  5 other 1 3718  
34 0 0 6 39 3572 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3718  
35 0 0 6 40 3572 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3718  
36 0 0 6 41 3727 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3717  
37 0 0 7 42 3717 2062 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3718  
38 0 0 7 43 3717 2062 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3718  4 onto 1 3718  
39 0 0 6 44 3727 0 0 0 2 4 this 3 3718  5 other 1 3718  
40 0 0 6 45 3727 0 0 0 2 4 this 3 3718  5 other 1 3718  
41 0 0 6 46 3727 0 0 0 2 4 this 3 3718  5 other 1 3718  
42 0 0 6 47 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3718  5 other 1 3718  
43 0 0 6 47 3578 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3718  5 other 1 3718  9 threshold 1 3572  
44 0 0 6 48 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3718  
45 0 0 6 48 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3718  9 threshold 1 3572  
46 0 0 6 49 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3718  4 hash 1 3720  
47 0 0 6 49 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3718  4 hash 1 3720  9 threshold 1 3572  
48 0 0 4 50 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3718  7 hashgen 1 3728  
49 0 0 4 50 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3718  7 hashgen 1 3728  9 threshold 1 3572  
50 0 0 7 51 3717 2062 0 0 1 4 this 3 3718  
51 0 0 7 52 3717 2062 0 0 2 4 this 3 3718  5 other 1 3718  
52 0 0 7 53 3717 2062 0 0 2 4 this 3 3718  5 other 1 3718  
53 0 0 7 54 3717 2062 0 0 2 4 this 3 3718  6 scalar 1 3572  
54 0 0 7 55 3717 2062 0 0 2 4 this 3 3718  6 scalar 1 3572  
55 0 0 6 56 3717 0 0 0 2 4 this 3 3717  5 other 1 3718  
56 0 0 6 57 3717 0 0 0 2 4 this 3 3717  5 other 1 3718  
57 0 0 6 58 3717 0 0 0 2 4 this 3 3717  6 scalar 1 3572  
58 0 0 6 59 3717 0 0 0 2 4 this 3 3717  6 scalar 1 3572  
59 0 0 4 60 3722 0 0 10 /**
 *
 */ 2 4 this 3 3717  5 other 1 3718  
60 0 0 7 61 3717 2062 0 0 2 4 this 3 3718  8 exponent 1 3572  
61 0 0 6 62 3723 0 0 0 2 4 this 3 3717  8 exponent 1 3572  
62 0 0 6 63 3723 0 0 0 1 4 this 3 3717  
63 0 0 6 64 3723 0 0 0 1 4 this 3 3717  
64 0 0 6 65 3723 0 0 0 1 4 this 3 3717  
65 0 0 7 66 3717 2062 0 10 /**
 *
 */ 2 4 this 3 3718  5 other 1 3718  
66 0 0 7 67 3717 2062 0 10 /**
 *
 */ 2 4 this 3 3718  5 other 1 3718  
67 0 0 6 68 3727 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3718  5 other 1 3718  
68 0 0 6 68 3727 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3718  5 other 1 3718  9 threshold 1 3572  
69 0 0 4 69 3722 0 0 10 /**
 *
 */ 2 4 this 3 3718  3 out 1 3730  
70 0 0 6 70 3726 0 0 0 1 4 this 3 3718  
71 0 0 4 71 3722 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3718  11 destination 1 3732  
72 0 0 4 72 3722 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3717  6 source 1 3734  
73 0 0 4 73 3722 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3718  11 destination 1 3732  
74 0 0 4 74 3722 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3717  6 source 1 3734  
75 0 0 7 75 3737 0 0 0 0 
76 0 0 7 79 3738 2128 0 0 0 
77 0 0 7 79 3738 2128 0 0 1 6 param0 0 3739  
78 0 0 7 79 3738 2128 0 10 /**
 *
 */ 1 10 fill_value 1 3575  
79 0 0 7 79 3738 2128 0 10 /**
 *
 */ 2 1 x 1 3575  1 y 1 3575  
80 0 0 4 80 3722 0 0 0 2 4 this 3 3738  4 size 1 3720  
81 0 0 6 83 3738 0 0 0 2 4 this 3 3738  4 copy 1 3739  
82 0 0 6 83 3738 0 0 0 2 4 this 3 3738  10 fill_value 1 3575  
83 0 0 6 84 3739 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
84 0 0 6 85 3739 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
85 0 0 6 86 3739 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
86 0 0 6 87 3723 0 0 0 1 4 this 3 3739  
87 0 0 6 88 3723 0 0 0 2 4 this 3 3739  9 attr_name 1 3726  
88 0 0 6 89 3578 0 0 0 3 4 this 3 3738  9 attr_name 1 3726  6 assign 1 3723  
89 0 0 4 90 3722 0 0 10 /**
 *
 */ 3 4 this 3 3738  1 i 1 3578  10 assign_val 1 3575  
90 0 0 6 90 3575 0 0 0 2 4 this 3 3739  1 i 1 3578  
91 0 0 6 91 3578 0 0 0 0 
92 0 0 6 92 3727 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3739  
93 0 0 6 93 3575 0 0 10 /**
 *
 */ 2 4 this 3 3739  1 i 1 3578  
94 0 0 4 94 3722 0 0 10 /**
 *
 */ 3 4 this 3 3738  1 i 1 3578  5 value 1 3575  
95 0 0 6 95 3575 0 0 10 /**
 *
 */ 1 4 this 3 3739  
96 0 0 6 96 3575 0 0 10 /**
 *
 */ 1 4 this 3 3739  
97 0 0 4 97 3722 0 0 10 /**
 *
 */ 2 4 this 3 3738  5 value 1 3575  
98 0 0 4 98 3722 0 0 10 /**
 *
 */ 2 4 this 3 3738  5 value 1 3575  
99 0 0 4 102 3722 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3738  1 i 1 3578  5 value 1 3575  
100 0 0 4 103 3722 0 0 10 /**
 *
 */ 2 4 this 3 3738  5 value 1 3575  
101 0 0 4 104 3722 0 0 10 /**
 *
 */ 2 4 this 3 3738  5 value 1 3575  
102 0 0 4 105 3722 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3739  
103 0 0 6 106 3578 0 0 0 0 
104 0 0 4 107 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3738  10 fill_value 1 3575  
105 0 0 4 108 3722 0 0 10 /**
 *
 */ 3 4 this 3 3738  1 x 1 3575  1 y 1 3575  
106 0 0 6 109 3575 0 0 10 /**
 *
 */ 2 4 this 3 3739  5 other 1 3739  
107 0 0 6 110 3575 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3739  
108 0 0 6 111 3575 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3739  
109 0 0 6 112 3727 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3738  
110 0 0 7 113 3738 2128 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3739  
111 0 0 7 114 3738 2128 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3739  4 onto 1 3739  
112 0 0 6 115 3727 0 0 0 2 4 this 3 3739  5 other 1 3739  
113 0 0 6 116 3727 0 0 0 2 4 this 3 3739  5 other 1 3739  
114 0 0 6 117 3727 0 0 0 2 4 this 3 3739  5 other 1 3739  
115 0 0 6 118 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3739  5 other 1 3739  
116 0 0 6 118 3578 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3739  5 other 1 3739  9 threshold 1 3575  
117 0 0 6 119 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3739  
118 0 0 6 119 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3739  9 threshold 1 3575  
119 0 0 6 120 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3739  4 hash 1 3720  
120 0 0 6 120 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3739  4 hash 1 3720  9 threshold 1 3575  
121 0 0 4 121 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3739  7 hashgen 1 3728  
122 0 0 4 121 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3739  7 hashgen 1 3728  9 threshold 1 3575  
123 0 0 7 122 3738 2128 0 0 1 4 this 3 3739  
124 0 0 7 123 3738 2128 0 0 2 4 this 3 3739  5 other 1 3739  
125 0 0 7 124 3738 2128 0 0 2 4 this 3 3739  5 other 1 3739  
126 0 0 7 125 3738 2128 0 0 2 4 this 3 3739  6 scalar 1 3575  
127 0 0 7 126 3738 2128 0 0 2 4 this 3 3739  6 scalar 1 3575  
128 0 0 6 127 3738 0 0 0 2 4 this 3 3738  5 other 1 3739  
129 0 0 6 128 3738 0 0 0 2 4 this 3 3738  5 other 1 3739  
130 0 0 6 129 3738 0 0 0 2 4 this 3 3738  6 scalar 1 3575  
131 0 0 6 130 3738 0 0 0 2 4 this 3 3738  6 scalar 1 3575  
132 0 0 4 131 3722 0 0 10 /**
 *
 */ 2 4 this 3 3738  5 other 1 3739  
133 0 0 7 132 3738 2128 0 0 2 4 this 3 3739  8 exponent 1 3575  
134 0 0 6 133 3723 0 0 0 2 4 this 3 3738  8 exponent 1 3575  
135 0 0 6 134 3723 0 0 0 1 4 this 3 3738  
136 0 0 6 135 3723 0 0 0 1 4 this 3 3738  
137 0 0 6 136 3723 0 0 0 1 4 this 3 3738  
138 0 0 7 137 3738 2128 0 10 /**
 *
 */ 2 4 this 3 3739  5 other 1 3739  
139 0 0 7 138 3738 2128 0 10 /**
 *
 */ 2 4 this 3 3739  5 other 1 3739  
140 0 0 6 139 3727 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3739  5 other 1 3739  
141 0 0 6 139 3727 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3739  5 other 1 3739  9 threshold 1 3575  
142 0 0 4 140 3722 0 0 10 /**
 *
 */ 2 4 this 3 3739  3 out 1 3730  
143 0 0 6 141 3726 0 0 0 1 4 this 3 3739  
144 0 0 4 142 3722 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3739  11 destination 1 3732  
145 0 0 4 143 3722 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3738  6 source 1 3734  
146 0 0 4 144 3722 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3739  11 destination 1 3732  
147 0 0 4 145 3722 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3738  6 source 1 3734  
148 0 0 7 146 3737 0 0 0 0 
149 0 0 7 150 3741 2190 0 0 0 
150 0 0 7 150 3741 2190 0 0 1 6 param0 0 3742  
151 0 0 7 150 3741 2190 0 10 /**
 *
 */ 1 10 fill_value 1 3578  
152 0 0 7 150 3741 2190 0 10 /**
 *
 */ 2 1 x 1 3578  1 y 1 3578  
153 0 0 4 151 3722 0 0 0 2 4 this 3 3741  4 size 1 3720  
154 0 0 6 154 3741 0 0 0 2 4 this 3 3741  4 copy 1 3742  
155 0 0 6 154 3741 0 0 0 2 4 this 3 3741  10 fill_value 1 3578  
156 0 0 6 155 3742 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
157 0 0 6 156 3742 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
158 0 0 6 157 3742 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
159 0 0 6 158 3723 0 0 0 1 4 this 3 3742  
160 0 0 6 159 3723 0 0 0 2 4 this 3 3742  9 attr_name 1 3726  
161 0 0 6 160 3578 0 0 0 3 4 this 3 3741  9 attr_name 1 3726  6 assign 1 3723  
162 0 0 4 161 3722 0 0 10 /**
 *
 */ 3 4 this 3 3741  1 i 1 3578  10 assign_val 1 3578  
163 0 0 6 161 3578 0 0 0 2 4 this 3 3742  1 i 1 3578  
164 0 0 6 162 3578 0 0 0 0 
165 0 0 6 163 3727 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3742  
166 0 0 6 164 3578 0 0 10 /**
 *
 */ 2 4 this 3 3742  1 i 1 3578  
167 0 0 4 165 3722 0 0 10 /**
 *
 */ 3 4 this 3 3741  1 i 1 3578  5 value 1 3578  
168 0 0 6 166 3578 0 0 10 /**
 *
 */ 1 4 this 3 3742  
169 0 0 6 167 3578 0 0 10 /**
 *
 */ 1 4 this 3 3742  
170 0 0 4 168 3722 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3578  
171 0 0 4 169 3722 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3578  
172 0 0 4 173 3722 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3741  1 i 1 3578  5 value 1 3578  
173 0 0 4 174 3722 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3578  
174 0 0 4 175 3722 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 value 1 3578  
175 0 0 4 176 3722 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3742  
176 0 0 6 177 3578 0 0 0 0 
177 0 0 4 178 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3741  10 fill_value 1 3578  
178 0 0 4 179 3722 0 0 10 /**
 *
 */ 3 4 this 3 3741  1 x 1 3578  1 y 1 3578  
179 0 0 6 180 3578 0 0 10 /**
 *
 */ 2 4 this 3 3742  5 other 1 3742  
180 0 0 6 181 3578 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3742  
181 0 0 6 182 3727 0 0 0 2 4 this 3 3742  5 other 1 3742  
182 0 0 6 183 3727 0 0 0 2 4 this 3 3742  5 other 1 3742  
183 0 0 6 184 3727 0 0 0 2 4 this 3 3742  5 other 1 3742  
184 0 0 6 185 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3742  5 other 1 3742  
185 0 0 6 186 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3742  
186 0 0 6 187 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3742  4 hash 1 3720  
187 0 0 4 188 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3742  7 hashgen 1 3728  
188 0 0 7 189 3741 2190 0 0 1 4 this 3 3742  
189 0 0 7 190 3741 2190 0 0 2 4 this 3 3742  5 other 1 3742  
190 0 0 7 191 3741 2190 0 0 2 4 this 3 3742  5 other 1 3742  
191 0 0 7 192 3741 2190 0 0 2 4 this 3 3742  6 scalar 1 3578  
192 0 0 7 193 3741 2190 0 0 2 4 this 3 3742  6 scalar 1 3578  
193 0 0 6 194 3741 0 0 0 2 4 this 3 3741  5 other 1 3742  
194 0 0 6 195 3741 0 0 0 2 4 this 3 3741  5 other 1 3742  
195 0 0 6 196 3741 0 0 0 2 4 this 3 3741  6 scalar 1 3578  
196 0 0 6 197 3741 0 0 0 2 4 this 3 3741  6 scalar 1 3578  
197 0 0 4 198 3722 0 0 10 /**
 *
 */ 2 4 this 3 3741  5 other 1 3742  
198 0 0 7 199 3741 2190 0 0 2 4 this 3 3742  8 exponent 1 3578  
199 0 0 6 200 3723 0 0 0 2 4 this 3 3741  8 exponent 1 3578  
200 0 0 6 201 3723 0 0 0 1 4 this 3 3741  
201 0 0 6 202 3723 0 0 0 1 4 this 3 3741  
202 0 0 6 203 3723 0 0 0 1 4 this 3 3741  
203 0 0 7 204 3741 2190 0 10 /**
 *
 */ 2 4 this 3 3742  5 other 1 3742  
204 0 0 7 205 3741 2190 0 10 /**
 *
 */ 2 4 this 3 3742  5 other 1 3742  
205 0 0 6 206 3727 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3742  5 other 1 3742  
206 0 0 6 206 3727 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3742  5 other 1 3742  9 threshold 1 3578  
207 0 0 4 207 3722 0 0 10 /**
 *
 */ 2 4 this 3 3742  3 out 1 3730  
208 0 0 6 208 3726 0 0 0 1 4 this 3 3742  
209 0 0 4 209 3722 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3742  11 destination 1 3732  
210 0 0 4 210 3722 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3741  6 source 1 3734  
211 0 0 4 211 3722 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3742  11 destination 1 3732  
212 0 0 4 212 3722 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3741  6 source 1 3734  
213 0 0 7 213 3737 0 0 0 0 
214 0 0 7 216 3744 2208 0 0 0 
215 0 0 7 216 3744 2208 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3718  
216 0 0 7 216 3744 2208 0 0 1 6 param0 0 3745  
217 0 0 7 216 3744 2208 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3572  
218 0 0 7 216 3744 2208 0 10 /**
 *
 */ 2 1 x 1 3572  1 y 1 3572  
219 0 0 6 217 3723 0 0 0 2 4 this 3 3745  9 attr_name 1 3726  
220 0 0 6 218 3578 0 0 0 3 4 this 3 3744  9 attr_name 1 3726  6 assign 1 3723  
221 0 0 6 219 3745 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
222 0 0 6 220 3745 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
223 0 0 6 221 3745 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
224 0 0 7 222 3744 2208 0 0 1 4 this 3 3745  
225 0 0 7 223 3717 2062 0 0 2 4 this 3 3745  5 other 1 3718  
226 0 0 7 223 3744 2208 0 0 2 4 this 3 3745  5 other 1 3745  
227 0 0 7 224 3717 2062 0 0 2 4 this 3 3745  5 other 1 3718  
228 0 0 7 224 3744 2208 0 0 2 4 this 3 3745  5 other 1 3745  
229 0 0 7 225 3744 2208 0 0 2 4 this 3 3745  6 scalar 1 3572  
230 0 0 7 226 3744 2208 0 0 2 4 this 3 3745  6 scalar 1 3572  
231 0 0 7 227 3744 2208 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3745  
232 0 0 7 228 3744 2208 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3745  4 onto 1 3718  
233 0 0 6 229 3572 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3745  5 other 1 3745  
234 0 0 6 230 3572 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3745  5 other 1 3745  
235 0 0 6 231 3726 0 0 0 1 4 this 3 3745  
236 0 0 7 232 3737 0 0 0 0 
237 0 0 7 235 3747 2226 0 0 0 
238 0 0 7 235 3747 2226 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3739  
239 0 0 7 235 3747 2226 0 0 1 6 param0 0 3748  
240 0 0 7 235 3747 2226 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3575  
241 0 0 7 235 3747 2226 0 10 /**
 *
 */ 2 1 x 1 3575  1 y 1 3575  
242 0 0 6 236 3723 0 0 0 2 4 this 3 3748  9 attr_name 1 3726  
243 0 0 6 237 3578 0 0 0 3 4 this 3 3747  9 attr_name 1 3726  6 assign 1 3723  
244 0 0 6 238 3748 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
245 0 0 6 239 3748 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
246 0 0 6 240 3748 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
247 0 0 7 241 3747 2226 0 0 1 4 this 3 3748  
248 0 0 7 242 3738 2128 0 0 2 4 this 3 3748  5 other 1 3739  
249 0 0 7 242 3747 2226 0 0 2 4 this 3 3748  5 other 1 3748  
250 0 0 7 243 3738 2128 0 0 2 4 this 3 3748  5 other 1 3739  
251 0 0 7 243 3747 2226 0 0 2 4 this 3 3748  5 other 1 3748  
252 0 0 7 244 3747 2226 0 0 2 4 this 3 3748  6 scalar 1 3575  
253 0 0 7 245 3747 2226 0 0 2 4 this 3 3748  6 scalar 1 3575  
254 0 0 7 246 3747 2226 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3748  
255 0 0 7 247 3747 2226 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3748  4 onto 1 3739  
256 0 0 6 248 3575 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3748  5 other 1 3748  
257 0 0 6 249 3575 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3748  5 other 1 3748  
258 0 0 6 250 3726 0 0 0 1 4 this 3 3748  
259 0 0 7 251 3737 0 0 0 0 
260 0 0 7 254 3750 2240 0 0 0 
261 0 0 7 254 3750 2240 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3742  
262 0 0 7 254 3750 2240 0 0 1 6 param0 0 3751  
263 0 0 7 254 3750 2240 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3578  
264 0 0 7 254 3750 2240 0 10 /**
 *
 */ 2 1 x 1 3578  1 y 1 3578  
265 0 0 6 255 3723 0 0 0 2 4 this 3 3751  9 attr_name 1 3726  
266 0 0 6 256 3578 0 0 0 3 4 this 3 3750  9 attr_name 1 3726  6 assign 1 3723  
267 0 0 6 257 3751 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
268 0 0 6 258 3751 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
269 0 0 6 259 3751 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
270 0 0 7 260 3750 2240 0 0 1 4 this 3 3751  
271 0 0 7 261 3741 2190 0 0 2 4 this 3 3751  5 other 1 3742  
272 0 0 7 261 3750 2240 0 0 2 4 this 3 3751  5 other 1 3751  
273 0 0 7 262 3741 2190 0 0 2 4 this 3 3751  5 other 1 3742  
274 0 0 7 262 3750 2240 0 0 2 4 this 3 3751  5 other 1 3751  
275 0 0 7 263 3750 2240 0 0 2 4 this 3 3751  6 scalar 1 3578  
276 0 0 7 264 3750 2240 0 0 2 4 this 3 3751  6 scalar 1 3578  
277 0 0 6 265 3726 0 0 0 1 4 this 3 3751  
278 0 0 7 266 3737 0 0 0 0 
279 0 0 7 269 3753 2256 0 0 0 
280 0 0 7 269 3753 2256 0 0 1 6 param0 0 3754  
281 0 0 7 269 3753 2256 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3718  
282 0 0 7 269 3753 2256 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3572  
283 0 0 7 269 3753 2256 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3572  1 y 1 3572  
284 0 0 6 270 3723 0 0 0 2 4 this 3 3754  9 attr_name 1 3726  
285 0 0 6 271 3578 0 0 0 3 4 this 3 3753  9 attr_name 1 3726  6 assign 1 3723  
286 0 0 6 272 3754 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
287 0 0 6 273 3754 0 0 34 /**
 * Returns a unit X point.
 */ 0 
288 0 0 6 274 3754 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
289 0 0 7 275 3753 2256 0 0 1 4 this 3 3754  
290 0 0 7 276 3717 2062 0 0 2 4 this 3 3754  5 other 1 3718  
291 0 0 7 276 3753 2256 0 0 2 4 this 3 3754  5 other 1 3745  
292 0 0 7 277 3744 2208 0 0 2 4 this 3 3754  5 other 1 3754  
293 0 0 7 277 3717 2062 0 0 2 4 this 3 3754  5 other 1 3718  
294 0 0 7 277 3753 2256 0 0 2 4 this 3 3754  5 other 1 3745  
295 0 0 7 278 3753 2256 0 0 2 4 this 3 3754  6 scalar 1 3572  
296 0 0 7 279 3753 2256 0 0 2 4 this 3 3754  6 scalar 1 3572  
297 0 0 7 280 3753 2256 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3754  
298 0 0 7 281 3753 2256 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3754  4 onto 1 3718  
299 0 0 6 282 3726 0 0 0 1 4 this 3 3754  
300 0 0 7 283 3737 0 0 0 0 
301 0 0 7 286 3756 2272 0 0 0 
302 0 0 7 286 3756 2272 0 0 1 6 param0 0 3757  
303 0 0 7 286 3756 2272 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3739  
304 0 0 7 286 3756 2272 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3575  
305 0 0 7 286 3756 2272 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3575  1 y 1 3575  
306 0 0 6 287 3723 0 0 0 2 4 this 3 3757  9 attr_name 1 3726  
307 0 0 6 288 3578 0 0 0 3 4 this 3 3756  9 attr_name 1 3726  6 assign 1 3723  
308 0 0 6 289 3757 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
309 0 0 6 290 3757 0 0 34 /**
 * Returns a unit X point.
 */ 0 
310 0 0 6 291 3757 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
311 0 0 7 292 3756 2272 0 0 1 4 this 3 3757  
312 0 0 7 293 3738 2128 0 0 2 4 this 3 3757  5 other 1 3739  
313 0 0 7 293 3756 2272 0 0 2 4 this 3 3757  5 other 1 3748  
314 0 0 7 294 3747 2226 0 0 2 4 this 3 3757  5 other 1 3757  
315 0 0 7 294 3738 2128 0 0 2 4 this 3 3757  5 other 1 3739  
316 0 0 7 294 3756 2272 0 0 2 4 this 3 3757  5 other 1 3748  
317 0 0 7 295 3756 2272 0 0 2 4 this 3 3757  6 scalar 1 3575  
318 0 0 7 296 3756 2272 0 0 2 4 this 3 3757  6 scalar 1 3575  
319 0 0 7 297 3756 2272 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3757  
320 0 0 7 298 3756 2272 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3757  4 onto 1 3739  
321 0 0 6 299 3726 0 0 0 1 4 this 3 3757  
322 0 0 7 300 3737 0 0 0 0 
323 0 0 7 303 3759 2286 0 0 0 
324 0 0 7 303 3759 2286 0 0 1 6 param0 0 3760  
325 0 0 7 303 3759 2286 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3742  
326 0 0 7 303 3759 2286 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3578  
327 0 0 7 303 3759 2286 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3578  1 y 1 3578  
328 0 0 6 304 3723 0 0 0 2 4 this 3 3760  9 attr_name 1 3726  
329 0 0 6 305 3578 0 0 0 3 4 this 3 3759  9 attr_name 1 3726  6 assign 1 3723  
330 0 0 6 306 3760 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
331 0 0 6 307 3760 0 0 34 /**
 * Returns a unit X point.
 */ 0 
332 0 0 6 308 3760 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
333 0 0 7 309 3759 2286 0 0 1 4 this 3 3760  
334 0 0 7 310 3741 2190 0 0 2 4 this 3 3760  5 other 1 3742  
335 0 0 7 310 3759 2286 0 0 2 4 this 3 3760  5 other 1 3751  
336 0 0 7 311 3750 2240 0 0 2 4 this 3 3760  5 other 1 3760  
337 0 0 7 311 3741 2190 0 0 2 4 this 3 3760  5 other 1 3742  
338 0 0 7 311 3759 2286 0 0 2 4 this 3 3760  5 other 1 3751  
339 0 0 7 312 3759 2286 0 0 2 4 this 3 3760  6 scalar 1 3578  
340 0 0 7 313 3759 2286 0 0 2 4 this 3 3760  6 scalar 1 3578  
341 0 0 6 314 3726 0 0 0 1 4 this 3 3760  
342 0 0 7 315 3737 0 0 0 0 
343 0 0 7 319 3762 2362 0 0 0 
344 0 0 7 319 3762 2362 0 10 /**
 *
 */ 2 4 copy 1 3718  1 z 1 3572  
345 0 0 7 319 3762 2362 0 0 1 6 param0 0 3763  
346 0 0 7 319 3762 2362 0 10 /**
 *
 */ 1 10 fill_value 1 3572  
347 0 0 7 319 3762 2362 0 10 /**
 *
 */ 3 1 x 1 3572  1 y 1 3572  1 z 1 3572  
348 0 0 4 320 3722 0 0 0 2 4 this 3 3762  4 size 1 3720  
349 0 0 6 323 3762 0 0 0 2 4 this 3 3762  4 copy 1 3763  
350 0 0 6 323 3762 0 0 0 2 4 this 3 3762  10 fill_value 1 3572  
351 0 0 6 324 3763 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
352 0 0 6 325 3763 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
353 0 0 6 326 3763 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
354 0 0 6 327 3763 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
355 0 0 6 328 3723 0 0 0 1 4 this 3 3763  
356 0 0 6 329 3723 0 0 0 2 4 this 3 3763  9 attr_name 1 3726  
357 0 0 6 330 3578 0 0 0 3 4 this 3 3762  9 attr_name 1 3726  6 assign 1 3723  
358 0 0 4 331 3722 0 0 10 /**
 *
 */ 3 4 this 3 3762  1 i 1 3578  10 assign_val 1 3572  
359 0 0 6 331 3572 0 0 0 2 4 this 3 3763  1 i 1 3578  
360 0 0 6 332 3578 0 0 0 0 
361 0 0 6 333 3727 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3763  
362 0 0 6 334 3572 0 0 10 /**
 *
 */ 2 4 this 3 3763  1 i 1 3578  
363 0 0 6 335 3572 0 0 10 /**
 *
 */ 1 4 this 3 3763  
364 0 0 6 336 3572 0 0 10 /**
 *
 */ 1 4 this 3 3763  
365 0 0 6 337 3572 0 0 10 /**
 *
 */ 1 4 this 3 3763  
366 0 0 4 338 3722 0 0 10 /**
 *
 */ 3 4 this 3 3762  1 i 1 3578  5 value 1 3572  
367 0 0 4 339 3722 0 0 10 /**
 *
 */ 2 4 this 3 3762  5 value 1 3572  
368 0 0 4 340 3722 0 0 10 /**
 *
 */ 2 4 this 3 3762  5 value 1 3572  
369 0 0 4 341 3722 0 0 10 /**
 *
 */ 2 4 this 3 3762  5 value 1 3572  
370 0 0 7 342 3717 2062 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3763  
371 0 0 7 343 3717 2062 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3763  
372 0 0 7 344 3717 2062 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3763  
373 0 0 4 351 3722 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3762  1 i 1 3578  5 value 1 3572  
374 0 0 4 352 3722 0 0 10 /**
 *
 */ 2 4 this 3 3762  5 value 1 3572  
375 0 0 4 353 3722 0 0 10 /**
 *
 */ 2 4 this 3 3762  5 value 1 3572  
376 0 0 4 354 3722 0 0 10 /**
 *
 */ 2 4 this 3 3762  5 value 1 3572  
377 0 0 4 355 3722 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3763  
378 0 0 6 356 3578 0 0 0 0 
379 0 0 4 357 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3762  10 fill_value 1 3572  
380 0 0 4 358 3722 0 0 10 /**
 *
 */ 4 4 this 3 3762  1 x 1 3572  1 y 1 3572  1 z 1 3572  
381 0 0 6 359 3572 0 0 10 /**
 *
 */ 2 4 this 3 3763  5 other 1 3763  
382 0 0 6 360 3572 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3763  
383 0 0 6 361 3572 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3763  
384 0 0 6 362 3727 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3762  
385 0 0 7 363 3762 2362 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3763  
386 0 0 7 364 3762 2362 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3763  4 onto 1 3763  
387 0 0 7 365 3762 2362 0 10 /**
 *
 */ 2 4 this 3 3763  5 other 1 3763  
388 0 0 6 366 3727 0 0 0 2 4 this 3 3763  5 other 1 3763  
389 0 0 6 367 3727 0 0 0 2 4 this 3 3763  5 other 1 3763  
390 0 0 6 368 3727 0 0 0 2 4 this 3 3763  5 other 1 3763  
391 0 0 7 369 3762 2362 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3763  
392 0 0 6 370 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3763  5 other 1 3763  
393 0 0 6 370 3578 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3763  5 other 1 3763  9 threshold 1 3572  
394 0 0 6 371 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3763  
395 0 0 6 371 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3763  9 threshold 1 3572  
396 0 0 6 372 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3763  4 hash 1 3720  
397 0 0 6 372 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3763  4 hash 1 3720  9 threshold 1 3572  
398 0 0 4 373 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3763  7 hashgen 1 3728  
399 0 0 4 373 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3763  7 hashgen 1 3728  9 threshold 1 3572  
400 0 0 7 374 3762 2362 0 0 1 4 this 3 3763  
401 0 0 7 375 3762 2362 0 0 2 4 this 3 3763  5 other 1 3763  
402 0 0 7 376 3762 2362 0 0 2 4 this 3 3763  5 other 1 3763  
403 0 0 7 377 3762 2362 0 0 2 4 this 3 3763  6 scalar 1 3572  
404 0 0 7 378 3762 2362 0 0 2 4 this 3 3763  6 scalar 1 3572  
405 0 0 6 379 3762 0 0 0 2 4 this 3 3762  5 other 1 3763  
406 0 0 6 380 3762 0 0 0 2 4 this 3 3762  5 other 1 3763  
407 0 0 6 381 3762 0 0 0 2 4 this 3 3762  6 scalar 1 3572  
408 0 0 6 382 3762 0 0 0 2 4 this 3 3762  6 scalar 1 3572  
409 0 0 4 383 3722 0 0 10 /**
 *
 */ 2 4 this 3 3762  5 other 1 3763  
410 0 0 7 384 3762 2362 0 0 2 4 this 3 3763  8 exponent 1 3572  
411 0 0 6 385 3723 0 0 0 2 4 this 3 3762  8 exponent 1 3572  
412 0 0 6 386 3723 0 0 0 1 4 this 3 3762  
413 0 0 6 387 3723 0 0 0 1 4 this 3 3762  
414 0 0 6 388 3723 0 0 0 1 4 this 3 3762  
415 0 0 7 389 3762 2362 0 10 /**
 *
 */ 2 4 this 3 3763  5 other 1 3763  
416 0 0 7 390 3762 2362 0 10 /**
 *
 */ 2 4 this 3 3763  5 other 1 3763  
417 0 0 4 391 3722 0 0 10 /**
 *
 */ 2 4 this 3 3762  5 other 1 3763  
418 0 0 6 392 3727 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3763  5 other 1 3763  
419 0 0 6 392 3727 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3763  5 other 1 3763  9 threshold 1 3572  
420 0 0 4 393 3722 0 0 10 /**
 *
 */ 2 4 this 3 3763  3 out 1 3730  
421 0 0 6 394 3726 0 0 0 1 4 this 3 3763  
422 0 0 4 395 3722 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3763  11 destination 1 3732  
423 0 0 4 396 3722 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3762  6 source 1 3734  
424 0 0 4 397 3722 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3763  11 destination 1 3732  
425 0 0 4 398 3722 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3762  6 source 1 3734  
426 0 0 7 399 3737 0 0 0 0 
427 0 0 7 403 3765 2438 0 0 0 
428 0 0 7 403 3765 2438 0 10 /**
 *
 */ 2 4 copy 1 3739  1 z 1 3575  
429 0 0 7 403 3765 2438 0 0 1 6 param0 0 3766  
430 0 0 7 403 3765 2438 0 10 /**
 *
 */ 1 10 fill_value 1 3575  
431 0 0 7 403 3765 2438 0 10 /**
 *
 */ 3 1 x 1 3575  1 y 1 3575  1 z 1 3575  
432 0 0 4 404 3722 0 0 0 2 4 this 3 3765  4 size 1 3720  
433 0 0 6 407 3765 0 0 0 2 4 this 3 3765  4 copy 1 3766  
434 0 0 6 407 3765 0 0 0 2 4 this 3 3765  10 fill_value 1 3575  
435 0 0 6 408 3766 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
436 0 0 6 409 3766 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
437 0 0 6 410 3766 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
438 0 0 6 411 3766 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
439 0 0 6 412 3723 0 0 0 1 4 this 3 3766  
440 0 0 6 413 3723 0 0 0 2 4 this 3 3766  9 attr_name 1 3726  
441 0 0 6 414 3578 0 0 0 3 4 this 3 3765  9 attr_name 1 3726  6 assign 1 3723  
442 0 0 4 415 3722 0 0 10 /**
 *
 */ 3 4 this 3 3765  1 i 1 3578  10 assign_val 1 3575  
443 0 0 6 415 3575 0 0 0 2 4 this 3 3766  1 i 1 3578  
444 0 0 6 416 3578 0 0 0 0 
445 0 0 6 417 3727 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3766  
446 0 0 6 418 3575 0 0 10 /**
 *
 */ 2 4 this 3 3766  1 i 1 3578  
447 0 0 6 419 3575 0 0 10 /**
 *
 */ 1 4 this 3 3766  
448 0 0 6 420 3575 0 0 10 /**
 *
 */ 1 4 this 3 3766  
449 0 0 6 421 3575 0 0 10 /**
 *
 */ 1 4 this 3 3766  
450 0 0 4 422 3722 0 0 10 /**
 *
 */ 3 4 this 3 3765  1 i 1 3578  5 value 1 3575  
451 0 0 4 423 3722 0 0 10 /**
 *
 */ 2 4 this 3 3765  5 value 1 3575  
452 0 0 4 424 3722 0 0 10 /**
 *
 */ 2 4 this 3 3765  5 value 1 3575  
453 0 0 4 425 3722 0 0 10 /**
 *
 */ 2 4 this 3 3765  5 value 1 3575  
454 0 0 7 426 3738 2128 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3766  
455 0 0 7 427 3738 2128 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3766  
456 0 0 7 428 3738 2128 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3766  
457 0 0 4 435 3722 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3765  1 i 1 3578  5 value 1 3575  
458 0 0 4 436 3722 0 0 10 /**
 *
 */ 2 4 this 3 3765  5 value 1 3575  
459 0 0 4 437 3722 0 0 10 /**
 *
 */ 2 4 this 3 3765  5 value 1 3575  
460 0 0 4 438 3722 0 0 10 /**
 *
 */ 2 4 this 3 3765  5 value 1 3575  
461 0 0 4 439 3722 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3766  
462 0 0 6 440 3578 0 0 0 0 
463 0 0 4 441 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3765  10 fill_value 1 3575  
464 0 0 4 442 3722 0 0 10 /**
 *
 */ 4 4 this 3 3765  1 x 1 3575  1 y 1 3575  1 z 1 3575  
465 0 0 6 443 3575 0 0 10 /**
 *
 */ 2 4 this 3 3766  5 other 1 3766  
466 0 0 6 444 3575 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3766  
467 0 0 6 445 3575 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3766  
468 0 0 6 446 3727 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3765  
469 0 0 7 447 3765 2438 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3766  
470 0 0 7 448 3765 2438 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3766  4 onto 1 3766  
471 0 0 7 449 3765 2438 0 10 /**
 *
 */ 2 4 this 3 3766  5 other 1 3766  
472 0 0 6 450 3727 0 0 0 2 4 this 3 3766  5 other 1 3766  
473 0 0 6 451 3727 0 0 0 2 4 this 3 3766  5 other 1 3766  
474 0 0 6 452 3727 0 0 0 2 4 this 3 3766  5 other 1 3766  
475 0 0 7 453 3765 2438 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3766  
476 0 0 6 454 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3766  5 other 1 3766  
477 0 0 6 454 3578 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3766  5 other 1 3766  9 threshold 1 3575  
478 0 0 6 455 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3766  
479 0 0 6 455 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3766  9 threshold 1 3575  
480 0 0 6 456 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3766  4 hash 1 3720  
481 0 0 6 456 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3766  4 hash 1 3720  9 threshold 1 3575  
482 0 0 4 457 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3766  7 hashgen 1 3728  
483 0 0 4 457 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3766  7 hashgen 1 3728  9 threshold 1 3575  
484 0 0 7 458 3765 2438 0 0 1 4 this 3 3766  
485 0 0 7 459 3765 2438 0 0 2 4 this 3 3766  5 other 1 3766  
486 0 0 7 460 3765 2438 0 0 2 4 this 3 3766  5 other 1 3766  
487 0 0 7 461 3765 2438 0 0 2 4 this 3 3766  6 scalar 1 3575  
488 0 0 7 462 3765 2438 0 0 2 4 this 3 3766  6 scalar 1 3575  
489 0 0 6 463 3765 0 0 0 2 4 this 3 3765  5 other 1 3766  
490 0 0 6 464 3765 0 0 0 2 4 this 3 3765  5 other 1 3766  
491 0 0 6 465 3765 0 0 0 2 4 this 3 3765  6 scalar 1 3575  
492 0 0 6 466 3765 0 0 0 2 4 this 3 3765  6 scalar 1 3575  
493 0 0 4 467 3722 0 0 10 /**
 *
 */ 2 4 this 3 3765  5 other 1 3766  
494 0 0 7 468 3765 2438 0 0 2 4 this 3 3766  8 exponent 1 3575  
495 0 0 6 469 3723 0 0 0 2 4 this 3 3765  8 exponent 1 3575  
496 0 0 6 470 3723 0 0 0 1 4 this 3 3765  
497 0 0 6 471 3723 0 0 0 1 4 this 3 3765  
498 0 0 6 472 3723 0 0 0 1 4 this 3 3765  
499 0 0 7 473 3765 2438 0 10 /**
 *
 */ 2 4 this 3 3766  5 other 1 3766  
500 0 0 7 474 3765 2438 0 10 /**
 *
 */ 2 4 this 3 3766  5 other 1 3766  
501 0 0 4 475 3722 0 0 10 /**
 *
 */ 2 4 this 3 3765  5 other 1 3766  
502 0 0 6 476 3727 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3766  5 other 1 3766  
503 0 0 6 476 3727 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3766  5 other 1 3766  9 threshold 1 3575  
504 0 0 4 477 3722 0 0 10 /**
 *
 */ 2 4 this 3 3766  3 out 1 3730  
505 0 0 6 478 3726 0 0 0 1 4 this 3 3766  
506 0 0 4 479 3722 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3766  11 destination 1 3732  
507 0 0 4 480 3722 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3765  6 source 1 3734  
508 0 0 4 481 3722 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3766  11 destination 1 3732  
509 0 0 4 482 3722 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3765  6 source 1 3734  
510 0 0 7 483 3737 0 0 0 0 
511 0 0 7 487 3768 2509 0 0 0 
512 0 0 7 487 3768 2509 0 10 /**
 *
 */ 2 4 copy 1 3742  1 z 1 3578  
513 0 0 7 487 3768 2509 0 0 1 6 param0 0 3769  
514 0 0 7 487 3768 2509 0 10 /**
 *
 */ 1 10 fill_value 1 3578  
515 0 0 7 487 3768 2509 0 10 /**
 *
 */ 3 1 x 1 3578  1 y 1 3578  1 z 1 3578  
516 0 0 4 488 3722 0 0 0 2 4 this 3 3768  4 size 1 3720  
517 0 0 6 491 3768 0 0 0 2 4 this 3 3768  4 copy 1 3769  
518 0 0 6 491 3768 0 0 0 2 4 this 3 3768  10 fill_value 1 3578  
519 0 0 6 492 3769 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
520 0 0 6 493 3769 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
521 0 0 6 494 3769 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
522 0 0 6 495 3769 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
523 0 0 6 496 3723 0 0 0 1 4 this 3 3769  
524 0 0 6 497 3723 0 0 0 2 4 this 3 3769  9 attr_name 1 3726  
525 0 0 6 498 3578 0 0 0 3 4 this 3 3768  9 attr_name 1 3726  6 assign 1 3723  
526 0 0 4 499 3722 0 0 10 /**
 *
 */ 3 4 this 3 3768  1 i 1 3578  10 assign_val 1 3578  
527 0 0 6 499 3578 0 0 0 2 4 this 3 3769  1 i 1 3578  
528 0 0 6 500 3578 0 0 0 0 
529 0 0 6 501 3727 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3769  
530 0 0 6 502 3578 0 0 10 /**
 *
 */ 2 4 this 3 3769  1 i 1 3578  
531 0 0 6 503 3578 0 0 10 /**
 *
 */ 1 4 this 3 3769  
532 0 0 6 504 3578 0 0 10 /**
 *
 */ 1 4 this 3 3769  
533 0 0 6 505 3578 0 0 10 /**
 *
 */ 1 4 this 3 3769  
534 0 0 4 506 3722 0 0 10 /**
 *
 */ 3 4 this 3 3768  1 i 1 3578  5 value 1 3578  
535 0 0 4 507 3722 0 0 10 /**
 *
 */ 2 4 this 3 3768  5 value 1 3578  
536 0 0 4 508 3722 0 0 10 /**
 *
 */ 2 4 this 3 3768  5 value 1 3578  
537 0 0 4 509 3722 0 0 10 /**
 *
 */ 2 4 this 3 3768  5 value 1 3578  
538 0 0 7 510 3741 2190 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3769  
539 0 0 7 511 3741 2190 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3769  
540 0 0 7 512 3741 2190 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3769  
541 0 0 4 519 3722 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3768  1 i 1 3578  5 value 1 3578  
542 0 0 4 520 3722 0 0 10 /**
 *
 */ 2 4 this 3 3768  5 value 1 3578  
543 0 0 4 521 3722 0 0 10 /**
 *
 */ 2 4 this 3 3768  5 value 1 3578  
544 0 0 4 522 3722 0 0 10 /**
 *
 */ 2 4 this 3 3768  5 value 1 3578  
545 0 0 4 523 3722 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3769  
546 0 0 6 524 3578 0 0 0 0 
547 0 0 4 525 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3768  10 fill_value 1 3578  
548 0 0 4 526 3722 0 0 10 /**
 *
 */ 4 4 this 3 3768  1 x 1 3578  1 y 1 3578  1 z 1 3578  
549 0 0 6 527 3578 0 0 10 /**
 *
 */ 2 4 this 3 3769  5 other 1 3769  
550 0 0 6 528 3578 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3769  
551 0 0 7 529 3768 2509 0 10 /**
 *
 */ 2 4 this 3 3769  5 other 1 3769  
552 0 0 6 530 3727 0 0 0 2 4 this 3 3769  5 other 1 3769  
553 0 0 6 531 3727 0 0 0 2 4 this 3 3769  5 other 1 3769  
554 0 0 6 532 3727 0 0 0 2 4 this 3 3769  5 other 1 3769  
555 0 0 6 533 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3769  5 other 1 3769  
556 0 0 6 534 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3769  
557 0 0 6 535 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3769  4 hash 1 3720  
558 0 0 4 536 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3769  7 hashgen 1 3728  
559 0 0 7 537 3768 2509 0 0 1 4 this 3 3769  
560 0 0 7 538 3768 2509 0 0 2 4 this 3 3769  5 other 1 3769  
561 0 0 7 539 3768 2509 0 0 2 4 this 3 3769  5 other 1 3769  
562 0 0 7 540 3768 2509 0 0 2 4 this 3 3769  6 scalar 1 3578  
563 0 0 7 541 3768 2509 0 0 2 4 this 3 3769  6 scalar 1 3578  
564 0 0 6 542 3768 0 0 0 2 4 this 3 3768  5 other 1 3769  
565 0 0 6 543 3768 0 0 0 2 4 this 3 3768  5 other 1 3769  
566 0 0 6 544 3768 0 0 0 2 4 this 3 3768  6 scalar 1 3578  
567 0 0 6 545 3768 0 0 0 2 4 this 3 3768  6 scalar 1 3578  
568 0 0 4 546 3722 0 0 10 /**
 *
 */ 2 4 this 3 3768  5 other 1 3769  
569 0 0 7 547 3768 2509 0 0 2 4 this 3 3769  8 exponent 1 3578  
570 0 0 6 548 3723 0 0 0 2 4 this 3 3768  8 exponent 1 3578  
571 0 0 6 549 3723 0 0 0 1 4 this 3 3768  
572 0 0 6 550 3723 0 0 0 1 4 this 3 3768  
573 0 0 6 551 3723 0 0 0 1 4 this 3 3768  
574 0 0 7 552 3768 2509 0 10 /**
 *
 */ 2 4 this 3 3769  5 other 1 3769  
575 0 0 7 553 3768 2509 0 10 /**
 *
 */ 2 4 this 3 3769  5 other 1 3769  
576 0 0 4 554 3722 0 0 10 /**
 *
 */ 2 4 this 3 3768  5 other 1 3769  
577 0 0 6 555 3727 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3769  5 other 1 3769  
578 0 0 6 555 3727 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3769  5 other 1 3769  9 threshold 1 3578  
579 0 0 4 556 3722 0 0 10 /**
 *
 */ 2 4 this 3 3769  3 out 1 3730  
580 0 0 6 557 3726 0 0 0 1 4 this 3 3769  
581 0 0 4 558 3722 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3769  11 destination 1 3732  
582 0 0 4 559 3722 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3768  6 source 1 3734  
583 0 0 4 560 3722 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3769  11 destination 1 3732  
584 0 0 4 561 3722 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3768  6 source 1 3734  
585 0 0 7 562 3737 0 0 0 0 
586 0 0 7 570 3771 2547 0 0 0 
587 0 0 7 570 3771 2547 0 10 /**
 *
 */ 2 4 copy 1 3718  1 z 1 3572  
588 0 0 7 570 3771 2547 0 10 /**
 *
 */ 1 4 copy 1 3763  
589 0 0 7 570 3771 2547 0 0 1 6 param0 0 3772  
590 0 0 7 570 3771 2547 0 10 /**
 *
 */ 1 10 fill_value 1 3572  
591 0 0 7 570 3771 2547 0 10 /**
 *
 */ 3 1 x 1 3572  1 y 1 3572  1 z 1 3572  
592 0 0 6 571 3723 0 0 0 2 4 this 3 3772  9 attr_name 1 3726  
593 0 0 6 572 3578 0 0 0 3 4 this 3 3771  9 attr_name 1 3726  6 assign 1 3723  
594 0 0 6 573 3772 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
595 0 0 6 574 3772 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
596 0 0 6 575 3772 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
597 0 0 6 576 3772 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
598 0 0 7 577 3744 2208 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3772  
599 0 0 7 578 3744 2208 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3772  
600 0 0 7 579 3744 2208 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3772  
601 0 0 7 583 3771 2547 0 0 1 4 this 3 3772  
602 0 0 7 584 3762 2362 0 0 2 4 this 3 3772  5 other 1 3763  
603 0 0 7 584 3771 2547 0 0 2 4 this 3 3772  5 other 1 3772  
604 0 0 7 585 3762 2362 0 0 2 4 this 3 3772  5 other 1 3763  
605 0 0 7 585 3771 2547 0 0 2 4 this 3 3772  5 other 1 3772  
606 0 0 7 586 3771 2547 0 10 /**
 *
 */ 2 4 this 3 3772  5 other 1 3763  
607 0 0 7 587 3771 2547 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3772  
608 0 0 7 588 3771 2547 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3772  4 onto 1 3763  
609 0 0 6 589 3572 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3772  5 other 1 3772  
610 0 0 6 590 3572 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3772  5 other 1 3772  
611 0 0 6 591 3572 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3772  5 other 1 3772  3 ref 1 3772  
612 0 0 6 592 3572 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3772  5 other 1 3772  3 ref 1 3772  
613 0 0 6 593 3572 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3772  5 other 1 3772  
614 0 0 6 594 3572 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3772  5 other 1 3772  
615 0 0 7 595 3771 2547 0 0 2 4 this 3 3772  6 scalar 1 3572  
616 0 0 7 596 3771 2547 0 0 2 4 this 3 3772  6 scalar 1 3572  
617 0 0 7 597 3771 2547 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3591  
618 0 0 7 598 3771 2547 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3591  
619 0 0 7 599 3771 2547 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3591  
620 0 0 7 600 3771 2547 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3591  
621 0 0 7 601 3771 2547 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3591  
622 0 0 7 602 3771 2547 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3591  
623 0 0 7 603 3771 2547 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3572  3 fwd 1 3572  2 up 1 3572  2 cs 1 3591  
624 0 0 6 604 3726 0 0 0 1 4 this 3 3772  
625 0 0 7 605 3737 0 0 0 0 
626 0 0 7 608 3774 2581 0 0 0 
627 0 0 7 608 3774 2581 0 10 /**
 *
 */ 2 4 copy 1 3739  1 z 1 3575  
628 0 0 7 608 3774 2581 0 10 /**
 *
 */ 1 4 copy 1 3766  
629 0 0 7 608 3774 2581 0 0 1 6 param0 0 3775  
630 0 0 7 608 3774 2581 0 10 /**
 *
 */ 1 10 fill_value 1 3575  
631 0 0 7 608 3774 2581 0 10 /**
 *
 */ 3 1 x 1 3575  1 y 1 3575  1 z 1 3575  
632 0 0 6 609 3723 0 0 0 2 4 this 3 3775  9 attr_name 1 3726  
633 0 0 6 610 3578 0 0 0 3 4 this 3 3774  9 attr_name 1 3726  6 assign 1 3723  
634 0 0 6 611 3775 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
635 0 0 6 612 3775 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
636 0 0 6 613 3775 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
637 0 0 6 614 3775 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
638 0 0 7 615 3747 2226 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3775  
639 0 0 7 616 3747 2226 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3775  
640 0 0 7 617 3747 2226 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3775  
641 0 0 7 621 3774 2581 0 0 1 4 this 3 3775  
642 0 0 7 622 3765 2438 0 0 2 4 this 3 3775  5 other 1 3766  
643 0 0 7 622 3774 2581 0 0 2 4 this 3 3775  5 other 1 3775  
644 0 0 7 623 3765 2438 0 0 2 4 this 3 3775  5 other 1 3766  
645 0 0 7 623 3774 2581 0 0 2 4 this 3 3775  5 other 1 3775  
646 0 0 7 624 3774 2581 0 10 /**
 *
 */ 2 4 this 3 3775  5 other 1 3766  
647 0 0 7 625 3774 2581 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3775  
648 0 0 7 626 3774 2581 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3775  4 onto 1 3766  
649 0 0 6 627 3575 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3775  5 other 1 3775  
650 0 0 6 628 3575 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3775  5 other 1 3775  
651 0 0 6 629 3575 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3775  5 other 1 3775  3 ref 1 3775  
652 0 0 6 630 3575 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3775  5 other 1 3775  3 ref 1 3775  
653 0 0 6 631 3575 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3775  5 other 1 3775  
654 0 0 6 632 3575 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3775  5 other 1 3775  
655 0 0 7 633 3774 2581 0 0 2 4 this 3 3775  6 scalar 1 3575  
656 0 0 7 634 3774 2581 0 0 2 4 this 3 3775  6 scalar 1 3575  
657 0 0 7 635 3774 2581 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3591  
658 0 0 7 636 3774 2581 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3591  
659 0 0 7 637 3774 2581 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3591  
660 0 0 7 638 3774 2581 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3591  
661 0 0 7 639 3774 2581 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3591  
662 0 0 7 640 3774 2581 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3591  
663 0 0 7 641 3774 2581 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3575  3 fwd 1 3575  2 up 1 3575  2 cs 1 3591  
664 0 0 6 642 3726 0 0 0 1 4 this 3 3775  
665 0 0 7 643 3737 0 0 0 0 
666 0 0 7 646 3777 2607 0 0 0 
667 0 0 7 646 3777 2607 0 10 /**
 *
 */ 2 4 copy 1 3742  1 z 1 3578  
668 0 0 7 646 3777 2607 0 10 /**
 *
 */ 1 4 copy 1 3769  
669 0 0 7 646 3777 2607 0 0 1 6 param0 0 3778  
670 0 0 7 646 3777 2607 0 10 /**
 *
 */ 1 10 fill_value 1 3578  
671 0 0 7 646 3777 2607 0 10 /**
 *
 */ 3 1 x 1 3578  1 y 1 3578  1 z 1 3578  
672 0 0 6 647 3723 0 0 0 2 4 this 3 3778  9 attr_name 1 3726  
673 0 0 6 648 3578 0 0 0 3 4 this 3 3777  9 attr_name 1 3726  6 assign 1 3723  
674 0 0 6 649 3778 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
675 0 0 6 650 3778 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
676 0 0 6 651 3778 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
677 0 0 6 652 3778 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
678 0 0 7 653 3750 2240 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3778  
679 0 0 7 654 3750 2240 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3778  
680 0 0 7 655 3750 2240 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3778  
681 0 0 7 659 3777 2607 0 0 1 4 this 3 3778  
682 0 0 7 660 3768 2509 0 0 2 4 this 3 3778  5 other 1 3769  
683 0 0 7 660 3777 2607 0 0 2 4 this 3 3778  5 other 1 3778  
684 0 0 7 661 3768 2509 0 0 2 4 this 3 3778  5 other 1 3769  
685 0 0 7 661 3777 2607 0 0 2 4 this 3 3778  5 other 1 3778  
686 0 0 7 662 3777 2607 0 10 /**
 *
 */ 2 4 this 3 3778  5 other 1 3769  
687 0 0 7 663 3777 2607 0 0 2 4 this 3 3778  6 scalar 1 3578  
688 0 0 7 664 3777 2607 0 0 2 4 this 3 3778  6 scalar 1 3578  
689 0 0 7 665 3777 2607 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3591  
690 0 0 7 666 3777 2607 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3591  
691 0 0 7 667 3777 2607 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3591  
692 0 0 7 668 3777 2607 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3591  
693 0 0 7 669 3777 2607 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3591  
694 0 0 7 670 3777 2607 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3591  
695 0 0 7 671 3777 2607 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3578  3 fwd 1 3578  2 up 1 3578  2 cs 1 3591  
696 0 0 6 672 3726 0 0 0 1 4 this 3 3778  
697 0 0 7 673 3737 0 0 0 0 
698 0 0 7 676 3780 2630 0 0 0 
699 0 0 7 676 3780 2630 0 0 1 6 param0 0 3781  
700 0 0 7 676 3780 2630 0 10 /**
 *
 */ 2 4 copy 1 3718  1 z 1 3572  
701 0 0 7 676 3780 2630 0 10 /**
 *
 */ 1 4 copy 1 3763  
702 0 0 7 676 3780 2630 0 10 /**
 *
 */ 1 10 fill_value 1 3572  
703 0 0 7 676 3780 2630 0 10 /**
 *
 */ 3 1 x 1 3572  1 y 1 3572  1 z 1 3572  
704 0 0 6 677 3723 0 0 0 2 4 this 3 3781  9 attr_name 1 3726  
705 0 0 6 678 3578 0 0 0 3 4 this 3 3780  9 attr_name 1 3726  6 assign 1 3723  
706 0 0 6 679 3781 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
707 0 0 6 680 3781 0 0 34 /**
 * Returns a unit X point.
 */ 0 
708 0 0 6 681 3781 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
709 0 0 6 682 3781 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
710 0 0 7 683 3753 2256 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3781  
711 0 0 7 684 3753 2256 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3781  
712 0 0 7 685 3753 2256 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3781  
713 0 0 7 689 3780 2630 0 0 1 4 this 3 3781  
714 0 0 7 690 3762 2362 0 0 2 4 this 3 3781  5 other 1 3763  
715 0 0 7 690 3780 2630 0 0 2 4 this 3 3781  5 other 1 3772  
716 0 0 7 691 3771 2547 0 0 2 4 this 3 3781  5 other 1 3781  
717 0 0 7 691 3762 2362 0 0 2 4 this 3 3781  5 other 1 3763  
718 0 0 7 691 3780 2630 0 0 2 4 this 3 3781  5 other 1 3772  
719 0 0 7 692 3780 2630 0 10 /**
 *
 */ 2 4 this 3 3781  5 other 1 3763  
720 0 0 7 693 3780 2630 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3781  
721 0 0 7 694 3780 2630 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3781  4 onto 1 3763  
722 0 0 7 695 3780 2630 0 0 2 4 this 3 3781  6 scalar 1 3572  
723 0 0 7 696 3780 2630 0 0 2 4 this 3 3781  6 scalar 1 3572  
724 0 0 6 697 3781 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3591  
725 0 0 7 698 3780 2630 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3572  3 fwd 1 3572  2 up 1 3572  2 cs 1 3591  
726 0 0 6 699 3726 0 0 0 1 4 this 3 3781  
727 0 0 7 700 3737 0 0 0 0 
728 0 0 7 703 3783 2653 0 0 0 
729 0 0 7 703 3783 2653 0 0 1 6 param0 0 3784  
730 0 0 7 703 3783 2653 0 10 /**
 *
 */ 2 4 copy 1 3739  1 z 1 3575  
731 0 0 7 703 3783 2653 0 10 /**
 *
 */ 1 4 copy 1 3766  
732 0 0 7 703 3783 2653 0 10 /**
 *
 */ 1 10 fill_value 1 3575  
733 0 0 7 703 3783 2653 0 10 /**
 *
 */ 3 1 x 1 3575  1 y 1 3575  1 z 1 3575  
734 0 0 6 704 3723 0 0 0 2 4 this 3 3784  9 attr_name 1 3726  
735 0 0 6 705 3578 0 0 0 3 4 this 3 3783  9 attr_name 1 3726  6 assign 1 3723  
736 0 0 6 706 3784 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
737 0 0 6 707 3784 0 0 34 /**
 * Returns a unit X point.
 */ 0 
738 0 0 6 708 3784 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
739 0 0 6 709 3784 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
740 0 0 7 710 3756 2272 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3784  
741 0 0 7 711 3756 2272 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3784  
742 0 0 7 712 3756 2272 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3784  
743 0 0 7 716 3783 2653 0 0 1 4 this 3 3784  
744 0 0 7 717 3765 2438 0 0 2 4 this 3 3784  5 other 1 3766  
745 0 0 7 717 3783 2653 0 0 2 4 this 3 3784  5 other 1 3775  
746 0 0 7 718 3774 2581 0 0 2 4 this 3 3784  5 other 1 3784  
747 0 0 7 718 3765 2438 0 0 2 4 this 3 3784  5 other 1 3766  
748 0 0 7 718 3783 2653 0 0 2 4 this 3 3784  5 other 1 3775  
749 0 0 7 719 3783 2653 0 10 /**
 *
 */ 2 4 this 3 3784  5 other 1 3766  
750 0 0 7 720 3783 2653 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3784  
751 0 0 7 721 3783 2653 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3784  4 onto 1 3766  
752 0 0 7 722 3783 2653 0 0 2 4 this 3 3784  6 scalar 1 3575  
753 0 0 7 723 3783 2653 0 0 2 4 this 3 3784  6 scalar 1 3575  
754 0 0 6 724 3784 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3591  
755 0 0 7 725 3783 2653 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3575  3 fwd 1 3575  2 up 1 3575  2 cs 1 3591  
756 0 0 6 726 3726 0 0 0 1 4 this 3 3784  
757 0 0 7 727 3737 0 0 0 0 
758 0 0 7 730 3786 2674 0 0 0 
759 0 0 7 730 3786 2674 0 0 1 6 param0 0 3787  
760 0 0 7 730 3786 2674 0 10 /**
 *
 */ 2 4 copy 1 3742  1 z 1 3578  
761 0 0 7 730 3786 2674 0 10 /**
 *
 */ 1 4 copy 1 3769  
762 0 0 7 730 3786 2674 0 10 /**
 *
 */ 1 10 fill_value 1 3578  
763 0 0 7 730 3786 2674 0 10 /**
 *
 */ 3 1 x 1 3578  1 y 1 3578  1 z 1 3578  
764 0 0 6 731 3723 0 0 0 2 4 this 3 3787  9 attr_name 1 3726  
765 0 0 6 732 3578 0 0 0 3 4 this 3 3786  9 attr_name 1 3726  6 assign 1 3723  
766 0 0 6 733 3787 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
767 0 0 6 734 3787 0 0 34 /**
 * Returns a unit X point.
 */ 0 
768 0 0 6 735 3787 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
769 0 0 6 736 3787 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
770 0 0 7 737 3759 2286 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3787  
771 0 0 7 738 3759 2286 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3787  
772 0 0 7 739 3759 2286 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3787  
773 0 0 7 743 3786 2674 0 0 1 4 this 3 3787  
774 0 0 7 744 3768 2509 0 0 2 4 this 3 3787  5 other 1 3769  
775 0 0 7 744 3786 2674 0 0 2 4 this 3 3787  5 other 1 3778  
776 0 0 7 745 3777 2607 0 0 2 4 this 3 3787  5 other 1 3787  
777 0 0 7 745 3768 2509 0 0 2 4 this 3 3787  5 other 1 3769  
778 0 0 7 745 3786 2674 0 0 2 4 this 3 3787  5 other 1 3778  
779 0 0 7 746 3786 2674 0 10 /**
 *
 */ 2 4 this 3 3787  5 other 1 3769  
780 0 0 7 747 3786 2674 0 0 2 4 this 3 3787  6 scalar 1 3578  
781 0 0 7 748 3786 2674 0 0 2 4 this 3 3787  6 scalar 1 3578  
782 0 0 6 749 3787 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3591  
783 0 0 7 750 3786 2674 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3578  3 fwd 1 3578  2 up 1 3578  2 cs 1 3591  
784 0 0 6 751 3726 0 0 0 1 4 this 3 3787  
785 0 0 7 752 3737 0 0 0 0 
786 0 0 7 756 3789 2751 0 0 0 
787 0 0 7 756 3789 2751 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3781  
788 0 0 7 756 3789 2751 0 10 /**
 *
 */ 2 4 copy 1 3763  1 w 1 3572  
789 0 0 7 756 3789 2751 0 0 1 6 param0 0 3790  
790 0 0 7 756 3789 2751 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3772  
791 0 0 7 756 3789 2751 0 10 /**
 *
 */ 1 4 copy 1 3792  
792 0 0 7 756 3789 2751 0 10 /**
 *
 */ 1 10 fill_value 1 3572  
793 0 0 7 756 3789 2751 0 10 /**
 *
 */ 4 1 x 1 3572  1 y 1 3572  1 z 1 3572  1 w 1 3572  
794 0 0 4 757 3722 0 0 0 2 4 this 3 3789  4 size 1 3720  
795 0 0 6 760 3789 0 0 0 2 4 this 3 3789  4 copy 1 3790  
796 0 0 6 760 3789 0 0 0 2 4 this 3 3789  10 fill_value 1 3572  
797 0 0 6 761 3790 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
798 0 0 6 762 3790 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
799 0 0 6 763 3790 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
800 0 0 6 764 3790 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
801 0 0 6 765 3790 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
802 0 0 6 766 3723 0 0 0 1 4 this 3 3790  
803 0 0 6 767 3723 0 0 0 2 4 this 3 3790  9 attr_name 1 3726  
804 0 0 6 768 3578 0 0 0 3 4 this 3 3789  9 attr_name 1 3726  6 assign 1 3723  
805 0 0 4 769 3722 0 0 10 /**
 *
 */ 3 4 this 3 3789  1 i 1 3578  10 assign_val 1 3572  
806 0 0 6 769 3572 0 0 0 2 4 this 3 3790  1 i 1 3578  
807 0 0 6 770 3578 0 0 0 0 
808 0 0 6 771 3727 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3790  
809 0 0 6 772 3572 0 0 10 /**
 *
 */ 2 4 this 3 3790  1 i 1 3578  
810 0 0 4 773 3722 0 0 10 /**
 *
 */ 3 4 this 3 3789  1 i 1 3578  5 value 1 3572  
811 0 0 6 774 3572 0 0 10 /**
 *
 */ 1 4 this 3 3790  
812 0 0 6 775 3572 0 0 10 /**
 *
 */ 1 4 this 3 3790  
813 0 0 6 776 3572 0 0 10 /**
 *
 */ 1 4 this 3 3790  
814 0 0 6 777 3572 0 0 10 /**
 *
 */ 1 4 this 3 3790  
815 0 0 7 778 3762 2362 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3790  
816 0 0 7 779 3717 2062 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3790  
817 0 0 4 780 3722 0 0 10 /**
 *
 */ 2 4 this 3 3789  5 value 1 3572  
818 0 0 4 781 3722 0 0 10 /**
 *
 */ 2 4 this 3 3789  5 value 1 3572  
819 0 0 4 782 3722 0 0 10 /**
 *
 */ 2 4 this 3 3789  5 value 1 3572  
820 0 0 4 783 3722 0 0 10 /**
 *
 */ 2 4 this 3 3789  5 value 1 3572  
821 0 0 4 789 3722 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3789  1 i 1 3578  5 value 1 3572  
822 0 0 4 790 3722 0 0 10 /**
 *
 */ 2 4 this 3 3789  5 value 1 3572  
823 0 0 4 791 3722 0 0 10 /**
 *
 */ 2 4 this 3 3789  5 value 1 3572  
824 0 0 4 792 3722 0 0 10 /**
 *
 */ 2 4 this 3 3789  5 value 1 3572  
825 0 0 4 793 3722 0 0 10 /**
 *
 */ 2 4 this 3 3789  5 value 1 3572  
826 0 0 4 794 3722 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3790  
827 0 0 6 795 3578 0 0 0 0 
828 0 0 4 797 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3789  10 fill_value 1 3572  
829 0 0 4 798 3722 0 0 10 /**
 *
 */ 5 4 this 3 3789  1 x 1 3572  1 y 1 3572  1 z 1 3572  1 w 1 3572  
830 0 0 6 799 3572 0 0 10 /**
 *
 */ 2 4 this 3 3790  5 other 1 3790  
831 0 0 6 800 3572 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3790  
832 0 0 6 801 3572 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3790  
833 0 0 6 802 3727 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3789  
834 0 0 7 803 3789 2751 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3790  
835 0 0 7 804 3789 2751 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3790  4 onto 1 3790  
836 0 0 6 805 3727 0 0 0 2 4 this 3 3790  5 other 1 3790  
837 0 0 6 806 3727 0 0 0 2 4 this 3 3790  5 other 1 3790  
838 0 0 6 807 3727 0 0 0 2 4 this 3 3790  5 other 1 3790  
839 0 0 6 808 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3790  5 other 1 3790  
840 0 0 6 808 3578 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3790  5 other 1 3790  9 threshold 1 3572  
841 0 0 6 809 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3790  
842 0 0 6 809 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3790  9 threshold 1 3572  
843 0 0 6 810 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3790  4 hash 1 3720  
844 0 0 6 810 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3790  4 hash 1 3720  9 threshold 1 3572  
845 0 0 4 811 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3790  7 hashgen 1 3728  
846 0 0 4 811 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3790  7 hashgen 1 3728  9 threshold 1 3572  
847 0 0 7 812 3789 2751 0 0 1 4 this 3 3790  
848 0 0 7 813 3789 2751 0 0 2 4 this 3 3790  5 other 1 3790  
849 0 0 7 814 3789 2751 0 0 2 4 this 3 3790  5 other 1 3790  
850 0 0 7 815 3789 2751 0 0 2 4 this 3 3790  6 scalar 1 3572  
851 0 0 7 816 3789 2751 0 0 2 4 this 3 3790  6 scalar 1 3572  
852 0 0 6 817 3789 0 0 0 2 4 this 3 3789  5 other 1 3790  
853 0 0 6 818 3789 0 0 0 2 4 this 3 3789  5 other 1 3790  
854 0 0 6 819 3789 0 0 0 2 4 this 3 3789  6 scalar 1 3572  
855 0 0 6 820 3789 0 0 0 2 4 this 3 3789  6 scalar 1 3572  
856 0 0 4 821 3722 0 0 10 /**
 *
 */ 2 4 this 3 3789  5 other 1 3790  
857 0 0 7 822 3789 2751 0 0 2 4 this 3 3790  8 exponent 1 3572  
858 0 0 6 823 3723 0 0 0 2 4 this 3 3789  8 exponent 1 3572  
859 0 0 6 824 3723 0 0 0 1 4 this 3 3789  
860 0 0 6 825 3723 0 0 0 1 4 this 3 3789  
861 0 0 6 826 3723 0 0 0 1 4 this 3 3789  
862 0 0 7 827 3789 2751 0 10 /**
 *
 */ 2 4 this 3 3790  5 other 1 3790  
863 0 0 7 828 3789 2751 0 10 /**
 *
 */ 2 4 this 3 3790  5 other 1 3790  
864 0 0 6 829 3727 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3790  5 other 1 3790  
865 0 0 6 829 3727 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3790  5 other 1 3790  9 threshold 1 3572  
866 0 0 4 830 3722 0 0 10 /**
 *
 */ 2 4 this 3 3790  3 out 1 3730  
867 0 0 6 831 3726 0 0 0 1 4 this 3 3790  
868 0 0 4 832 3722 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3790  11 destination 1 3732  
869 0 0 4 833 3722 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3789  6 source 1 3734  
870 0 0 4 834 3722 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3790  11 destination 1 3732  
871 0 0 4 835 3722 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3789  6 source 1 3734  
872 0 0 7 836 3737 0 0 0 0 
873 0 0 7 840 3794 2762 0 0 0 
874 0 0 7 840 3794 2762 0 10 /**
 *
 */ 1 4 copy 1 3790  
875 0 0 7 840 3794 2762 0 0 1 6 param0 0 3792  
876 0 0 7 840 3794 2762 0 10 /**
 *
 */ 1 10 fill_value 1 3572  
877 0 0 7 840 3794 2762 0 10 /**
 *
 */ 4 1 x 1 3572  1 y 1 3572  1 z 1 3572  1 w 1 3572  
878 0 0 4 841 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3794  10 fill_value 1 3572  
879 0 0 4 842 3722 0 0 10 /**
 *
 */ 5 4 this 3 3794  1 x 1 3572  1 y 1 3572  1 z 1 3572  1 w 1 3572  
880 0 0 4 843 3722 0 0 10 /**
 *
 */ 3 4 this 3 3794  1 i 1 3578  10 assign_val 1 3572  
881 0 0 6 843 3572 0 0 0 2 4 this 3 3792  1 i 1 3578  
882 0 0 6 844 3578 0 0 0 0 
883 0 0 4 845 3722 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3792  
884 0 0 6 846 3578 0 0 0 0 
885 0 0 6 847 3727 0 0 0 2 4 this 3 3792  5 other 1 3792  
886 0 0 6 848 3727 0 0 0 2 4 this 3 3792  5 other 1 3792  
887 0 0 7 849 3737 0 0 0 0 
888 0 0 7 853 3795 2839 0 0 0 
889 0 0 7 853 3795 2839 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3784  
890 0 0 7 853 3795 2839 0 10 /**
 *
 */ 2 4 copy 1 3766  1 w 1 3575  
891 0 0 7 853 3795 2839 0 0 1 6 param0 0 3796  
892 0 0 7 853 3795 2839 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3775  
893 0 0 7 853 3795 2839 0 10 /**
 *
 */ 1 4 copy 1 3798  
894 0 0 7 853 3795 2839 0 10 /**
 *
 */ 1 10 fill_value 1 3575  
895 0 0 7 853 3795 2839 0 10 /**
 *
 */ 4 1 x 1 3575  1 y 1 3575  1 z 1 3575  1 w 1 3575  
896 0 0 4 854 3722 0 0 0 2 4 this 3 3795  4 size 1 3720  
897 0 0 6 857 3795 0 0 0 2 4 this 3 3795  4 copy 1 3796  
898 0 0 6 857 3795 0 0 0 2 4 this 3 3795  10 fill_value 1 3575  
899 0 0 6 858 3796 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
900 0 0 6 859 3796 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
901 0 0 6 860 3796 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
902 0 0 6 861 3796 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
903 0 0 6 862 3796 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
904 0 0 6 863 3723 0 0 0 1 4 this 3 3796  
905 0 0 6 864 3723 0 0 0 2 4 this 3 3796  9 attr_name 1 3726  
906 0 0 6 865 3578 0 0 0 3 4 this 3 3795  9 attr_name 1 3726  6 assign 1 3723  
907 0 0 4 866 3722 0 0 10 /**
 *
 */ 3 4 this 3 3795  1 i 1 3578  10 assign_val 1 3575  
908 0 0 6 866 3575 0 0 0 2 4 this 3 3796  1 i 1 3578  
909 0 0 6 867 3578 0 0 0 0 
910 0 0 6 868 3727 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3796  
911 0 0 6 869 3575 0 0 10 /**
 *
 */ 2 4 this 3 3796  1 i 1 3578  
912 0 0 4 870 3722 0 0 10 /**
 *
 */ 3 4 this 3 3795  1 i 1 3578  5 value 1 3575  
913 0 0 6 871 3575 0 0 10 /**
 *
 */ 1 4 this 3 3796  
914 0 0 6 872 3575 0 0 10 /**
 *
 */ 1 4 this 3 3796  
915 0 0 6 873 3575 0 0 10 /**
 *
 */ 1 4 this 3 3796  
916 0 0 6 874 3575 0 0 10 /**
 *
 */ 1 4 this 3 3796  
917 0 0 7 875 3765 2438 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3796  
918 0 0 7 876 3738 2128 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3796  
919 0 0 4 877 3722 0 0 10 /**
 *
 */ 2 4 this 3 3795  5 value 1 3575  
920 0 0 4 878 3722 0 0 10 /**
 *
 */ 2 4 this 3 3795  5 value 1 3575  
921 0 0 4 879 3722 0 0 10 /**
 *
 */ 2 4 this 3 3795  5 value 1 3575  
922 0 0 4 880 3722 0 0 10 /**
 *
 */ 2 4 this 3 3795  5 value 1 3575  
923 0 0 4 886 3722 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3795  1 i 1 3578  5 value 1 3575  
924 0 0 4 887 3722 0 0 10 /**
 *
 */ 2 4 this 3 3795  5 value 1 3575  
925 0 0 4 888 3722 0 0 10 /**
 *
 */ 2 4 this 3 3795  5 value 1 3575  
926 0 0 4 889 3722 0 0 10 /**
 *
 */ 2 4 this 3 3795  5 value 1 3575  
927 0 0 4 890 3722 0 0 10 /**
 *
 */ 2 4 this 3 3795  5 value 1 3575  
928 0 0 4 891 3722 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3796  
929 0 0 6 892 3578 0 0 0 0 
930 0 0 4 894 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3795  10 fill_value 1 3575  
931 0 0 4 895 3722 0 0 10 /**
 *
 */ 5 4 this 3 3795  1 x 1 3575  1 y 1 3575  1 z 1 3575  1 w 1 3575  
932 0 0 6 896 3575 0 0 10 /**
 *
 */ 2 4 this 3 3796  5 other 1 3796  
933 0 0 6 897 3575 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3796  
934 0 0 6 898 3575 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3796  
935 0 0 6 899 3727 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3795  
936 0 0 7 900 3795 2839 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3796  
937 0 0 7 901 3795 2839 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3796  4 onto 1 3796  
938 0 0 6 902 3727 0 0 0 2 4 this 3 3796  5 other 1 3796  
939 0 0 6 903 3727 0 0 0 2 4 this 3 3796  5 other 1 3796  
940 0 0 6 904 3727 0 0 0 2 4 this 3 3796  5 other 1 3796  
941 0 0 6 905 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3796  5 other 1 3796  
942 0 0 6 905 3578 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3796  5 other 1 3796  9 threshold 1 3575  
943 0 0 6 906 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3796  
944 0 0 6 906 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3796  9 threshold 1 3575  
945 0 0 6 907 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3796  4 hash 1 3720  
946 0 0 6 907 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3796  4 hash 1 3720  9 threshold 1 3575  
947 0 0 4 908 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3796  7 hashgen 1 3728  
948 0 0 4 908 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3796  7 hashgen 1 3728  9 threshold 1 3575  
949 0 0 7 909 3795 2839 0 0 1 4 this 3 3796  
950 0 0 7 910 3795 2839 0 0 2 4 this 3 3796  5 other 1 3796  
951 0 0 7 911 3795 2839 0 0 2 4 this 3 3796  5 other 1 3796  
952 0 0 7 912 3795 2839 0 0 2 4 this 3 3796  6 scalar 1 3575  
953 0 0 7 913 3795 2839 0 0 2 4 this 3 3796  6 scalar 1 3575  
954 0 0 6 914 3795 0 0 0 2 4 this 3 3795  5 other 1 3796  
955 0 0 6 915 3795 0 0 0 2 4 this 3 3795  5 other 1 3796  
956 0 0 6 916 3795 0 0 0 2 4 this 3 3795  6 scalar 1 3575  
957 0 0 6 917 3795 0 0 0 2 4 this 3 3795  6 scalar 1 3575  
958 0 0 4 918 3722 0 0 10 /**
 *
 */ 2 4 this 3 3795  5 other 1 3796  
959 0 0 7 919 3795 2839 0 0 2 4 this 3 3796  8 exponent 1 3575  
960 0 0 6 920 3723 0 0 0 2 4 this 3 3795  8 exponent 1 3575  
961 0 0 6 921 3723 0 0 0 1 4 this 3 3795  
962 0 0 6 922 3723 0 0 0 1 4 this 3 3795  
963 0 0 6 923 3723 0 0 0 1 4 this 3 3795  
964 0 0 7 924 3795 2839 0 10 /**
 *
 */ 2 4 this 3 3796  5 other 1 3796  
965 0 0 7 925 3795 2839 0 10 /**
 *
 */ 2 4 this 3 3796  5 other 1 3796  
966 0 0 6 926 3727 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3796  5 other 1 3796  
967 0 0 6 926 3727 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3796  5 other 1 3796  9 threshold 1 3575  
968 0 0 4 927 3722 0 0 10 /**
 *
 */ 2 4 this 3 3796  3 out 1 3730  
969 0 0 6 928 3726 0 0 0 1 4 this 3 3796  
970 0 0 4 929 3722 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3796  11 destination 1 3732  
971 0 0 4 930 3722 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3795  6 source 1 3734  
972 0 0 4 931 3722 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3796  11 destination 1 3732  
973 0 0 4 932 3722 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3795  6 source 1 3734  
974 0 0 7 933 3737 0 0 0 0 
975 0 0 7 937 3800 2850 0 0 0 
976 0 0 7 937 3800 2850 0 10 /**
 *
 */ 1 4 copy 1 3796  
977 0 0 7 937 3800 2850 0 0 1 6 param0 0 3798  
978 0 0 7 937 3800 2850 0 10 /**
 *
 */ 1 10 fill_value 1 3575  
979 0 0 7 937 3800 2850 0 10 /**
 *
 */ 4 1 x 1 3575  1 y 1 3575  1 z 1 3575  1 w 1 3575  
980 0 0 4 938 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3800  10 fill_value 1 3575  
981 0 0 4 939 3722 0 0 10 /**
 *
 */ 5 4 this 3 3800  1 x 1 3575  1 y 1 3575  1 z 1 3575  1 w 1 3575  
982 0 0 4 940 3722 0 0 10 /**
 *
 */ 3 4 this 3 3800  1 i 1 3578  10 assign_val 1 3575  
983 0 0 6 940 3575 0 0 0 2 4 this 3 3798  1 i 1 3578  
984 0 0 6 941 3578 0 0 0 0 
985 0 0 4 942 3722 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3798  
986 0 0 6 943 3578 0 0 0 0 
987 0 0 6 944 3727 0 0 0 2 4 this 3 3798  5 other 1 3798  
988 0 0 6 945 3727 0 0 0 2 4 this 3 3798  5 other 1 3798  
989 0 0 7 946 3737 0 0 0 0 
990 0 0 7 950 3801 2923 0 0 0 
991 0 0 7 950 3801 2923 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3787  
992 0 0 7 950 3801 2923 0 10 /**
 *
 */ 2 4 copy 1 3769  1 w 1 3578  
993 0 0 7 950 3801 2923 0 0 1 6 param0 0 3802  
994 0 0 7 950 3801 2923 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3778  
995 0 0 7 950 3801 2923 0 10 /**
 *
 */ 1 4 copy 1 3804  
996 0 0 7 950 3801 2923 0 10 /**
 *
 */ 1 10 fill_value 1 3578  
997 0 0 7 950 3801 2923 0 10 /**
 *
 */ 4 1 x 1 3578  1 y 1 3578  1 z 1 3578  1 w 1 3578  
998 0 0 4 951 3722 0 0 0 2 4 this 3 3801  4 size 1 3720  
999 0 0 6 954 3801 0 0 0 2 4 this 3 3801  4 copy 1 3802  
1000 0 0 6 954 3801 0 0 0 2 4 this 3 3801  10 fill_value 1 3578  
1001 0 0 6 955 3802 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1002 0 0 6 956 3802 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1003 0 0 6 957 3802 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1004 0 0 6 958 3802 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1005 0 0 6 959 3802 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1006 0 0 6 960 3723 0 0 0 1 4 this 3 3802  
1007 0 0 6 961 3723 0 0 0 2 4 this 3 3802  9 attr_name 1 3726  
1008 0 0 6 962 3578 0 0 0 3 4 this 3 3801  9 attr_name 1 3726  6 assign 1 3723  
1009 0 0 4 963 3722 0 0 10 /**
 *
 */ 3 4 this 3 3801  1 i 1 3578  10 assign_val 1 3578  
1010 0 0 6 963 3578 0 0 0 2 4 this 3 3802  1 i 1 3578  
1011 0 0 6 964 3578 0 0 0 0 
1012 0 0 6 965 3727 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3802  
1013 0 0 6 966 3578 0 0 10 /**
 *
 */ 2 4 this 3 3802  1 i 1 3578  
1014 0 0 4 967 3722 0 0 10 /**
 *
 */ 3 4 this 3 3801  1 i 1 3578  5 value 1 3578  
1015 0 0 6 968 3578 0 0 10 /**
 *
 */ 1 4 this 3 3802  
1016 0 0 6 969 3578 0 0 10 /**
 *
 */ 1 4 this 3 3802  
1017 0 0 6 970 3578 0 0 10 /**
 *
 */ 1 4 this 3 3802  
1018 0 0 6 971 3578 0 0 10 /**
 *
 */ 1 4 this 3 3802  
1019 0 0 7 972 3768 2509 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3802  
1020 0 0 7 973 3741 2190 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3802  
1021 0 0 4 974 3722 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3578  
1022 0 0 4 975 3722 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3578  
1023 0 0 4 976 3722 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3578  
1024 0 0 4 977 3722 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3578  
1025 0 0 4 983 3722 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3801  1 i 1 3578  5 value 1 3578  
1026 0 0 4 984 3722 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3578  
1027 0 0 4 985 3722 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3578  
1028 0 0 4 986 3722 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3578  
1029 0 0 4 987 3722 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3578  
1030 0 0 4 988 3722 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3802  
1031 0 0 6 989 3578 0 0 0 0 
1032 0 0 4 991 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3801  10 fill_value 1 3578  
1033 0 0 4 992 3722 0 0 10 /**
 *
 */ 5 4 this 3 3801  1 x 1 3578  1 y 1 3578  1 z 1 3578  1 w 1 3578  
1034 0 0 6 993 3578 0 0 10 /**
 *
 */ 2 4 this 3 3802  5 other 1 3802  
1035 0 0 6 994 3578 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3802  
1036 0 0 6 995 3727 0 0 0 2 4 this 3 3802  5 other 1 3802  
1037 0 0 6 996 3727 0 0 0 2 4 this 3 3802  5 other 1 3802  
1038 0 0 6 997 3727 0 0 0 2 4 this 3 3802  5 other 1 3802  
1039 0 0 6 998 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3802  5 other 1 3802  
1040 0 0 6 999 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3802  
1041 0 0 6 1000 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3802  4 hash 1 3720  
1042 0 0 4 1001 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3802  7 hashgen 1 3728  
1043 0 0 7 1002 3801 2923 0 0 1 4 this 3 3802  
1044 0 0 7 1003 3801 2923 0 0 2 4 this 3 3802  5 other 1 3802  
1045 0 0 7 1004 3801 2923 0 0 2 4 this 3 3802  5 other 1 3802  
1046 0 0 7 1005 3801 2923 0 0 2 4 this 3 3802  6 scalar 1 3578  
1047 0 0 7 1006 3801 2923 0 0 2 4 this 3 3802  6 scalar 1 3578  
1048 0 0 6 1007 3801 0 0 0 2 4 this 3 3801  5 other 1 3802  
1049 0 0 6 1008 3801 0 0 0 2 4 this 3 3801  5 other 1 3802  
1050 0 0 6 1009 3801 0 0 0 2 4 this 3 3801  6 scalar 1 3578  
1051 0 0 6 1010 3801 0 0 0 2 4 this 3 3801  6 scalar 1 3578  
1052 0 0 4 1011 3722 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 other 1 3802  
1053 0 0 7 1012 3801 2923 0 0 2 4 this 3 3802  8 exponent 1 3578  
1054 0 0 6 1013 3723 0 0 0 2 4 this 3 3801  8 exponent 1 3578  
1055 0 0 6 1014 3723 0 0 0 1 4 this 3 3801  
1056 0 0 6 1015 3723 0 0 0 1 4 this 3 3801  
1057 0 0 6 1016 3723 0 0 0 1 4 this 3 3801  
1058 0 0 7 1017 3801 2923 0 10 /**
 *
 */ 2 4 this 3 3802  5 other 1 3802  
1059 0 0 7 1018 3801 2923 0 10 /**
 *
 */ 2 4 this 3 3802  5 other 1 3802  
1060 0 0 6 1019 3727 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3802  5 other 1 3802  
1061 0 0 6 1019 3727 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3802  5 other 1 3802  9 threshold 1 3578  
1062 0 0 4 1020 3722 0 0 10 /**
 *
 */ 2 4 this 3 3802  3 out 1 3730  
1063 0 0 6 1021 3726 0 0 0 1 4 this 3 3802  
1064 0 0 4 1022 3722 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3802  11 destination 1 3732  
1065 0 0 4 1023 3722 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3801  6 source 1 3734  
1066 0 0 4 1024 3722 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3802  11 destination 1 3732  
1067 0 0 4 1025 3722 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3801  6 source 1 3734  
1068 0 0 7 1026 3737 0 0 0 0 
1069 0 0 7 1030 3806 2934 0 0 0 
1070 0 0 7 1030 3806 2934 0 10 /**
 *
 */ 1 4 copy 1 3802  
1071 0 0 7 1030 3806 2934 0 0 1 6 param0 0 3804  
1072 0 0 7 1030 3806 2934 0 10 /**
 *
 */ 1 10 fill_value 1 3578  
1073 0 0 7 1030 3806 2934 0 10 /**
 *
 */ 4 1 x 1 3578  1 y 1 3578  1 z 1 3578  1 w 1 3578  
1074 0 0 4 1031 3722 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3806  10 fill_value 1 3578  
1075 0 0 4 1032 3722 0 0 10 /**
 *
 */ 5 4 this 3 3806  1 x 1 3578  1 y 1 3578  1 z 1 3578  1 w 1 3578  
1076 0 0 4 1033 3722 0 0 10 /**
 *
 */ 3 4 this 3 3806  1 i 1 3578  10 assign_val 1 3578  
1077 0 0 6 1033 3578 0 0 0 2 4 this 3 3804  1 i 1 3578  
1078 0 0 6 1034 3578 0 0 0 0 
1079 0 0 4 1035 3722 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3804  
1080 0 0 6 1036 3578 0 0 0 0 
1081 0 0 6 1037 3727 0 0 0 2 4 this 3 3804  5 other 1 3804  
1082 0 0 6 1038 3727 0 0 0 2 4 this 3 3804  5 other 1 3804  
1083 0 0 7 1039 3737 0 0 0 0 
1084 0 0 7 1042 3807 2954 0 0 0 
1085 0 0 7 1042 3807 2954 0 10 /**
 *
 */ 2 4 copy 1 3763  1 w 1 3572  
1086 0 0 7 1042 3807 2954 0 10 /**
 *
 */ 1 4 copy 1 3790  
1087 0 0 7 1042 3807 2954 0 0 1 6 param0 0 3808  
1088 0 0 7 1042 3807 2954 0 10 /**
 *
 */ 1 10 fill_value 1 3572  
1089 0 0 7 1042 3807 2954 0 10 /**
 *
 */ 4 1 x 1 3572  1 y 1 3572  1 z 1 3572  1 w 1 3572  
1090 0 0 6 1043 3723 0 0 0 2 4 this 3 3808  9 attr_name 1 3726  
1091 0 0 6 1044 3578 0 0 0 3 4 this 3 3807  9 attr_name 1 3726  6 assign 1 3723  
1092 0 0 6 1045 3808 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1093 0 0 6 1046 3808 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1094 0 0 6 1047 3808 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1095 0 0 6 1048 3808 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1096 0 0 6 1049 3808 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1097 0 0 7 1050 3771 2547 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3808  
1098 0 0 7 1051 3744 2208 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3808  
1099 0 0 7 1054 3807 2954 0 0 1 4 this 3 3808  
1100 0 0 7 1055 3789 2751 0 0 2 4 this 3 3808  5 other 1 3790  
1101 0 0 7 1055 3807 2954 0 0 2 4 this 3 3808  5 other 1 3808  
1102 0 0 7 1056 3789 2751 0 0 2 4 this 3 3808  5 other 1 3790  
1103 0 0 7 1056 3807 2954 0 0 2 4 this 3 3808  5 other 1 3808  
1104 0 0 7 1057 3807 2954 0 0 2 4 this 3 3808  6 scalar 1 3572  
1105 0 0 7 1058 3807 2954 0 0 2 4 this 3 3808  6 scalar 1 3572  
1106 0 0 7 1059 3807 2954 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3808  
1107 0 0 7 1060 3807 2954 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3808  4 onto 1 3790  
1108 0 0 6 1061 3726 0 0 0 1 4 this 3 3808  
1109 0 0 7 1062 3737 0 0 0 0 
1110 0 0 7 1065 3810 2974 0 0 0 
1111 0 0 7 1065 3810 2974 0 10 /**
 *
 */ 2 4 copy 1 3766  1 w 1 3575  
1112 0 0 7 1065 3810 2974 0 10 /**
 *
 */ 1 4 copy 1 3796  
1113 0 0 7 1065 3810 2974 0 0 1 6 param0 0 3811  
1114 0 0 7 1065 3810 2974 0 10 /**
 *
 */ 1 10 fill_value 1 3575  
1115 0 0 7 1065 3810 2974 0 10 /**
 *
 */ 4 1 x 1 3575  1 y 1 3575  1 z 1 3575  1 w 1 3575  
1116 0 0 6 1066 3723 0 0 0 2 4 this 3 3811  9 attr_name 1 3726  
1117 0 0 6 1067 3578 0 0 0 3 4 this 3 3810  9 attr_name 1 3726  6 assign 1 3723  
1118 0 0 6 1068 3811 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1119 0 0 6 1069 3811 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1120 0 0 6 1070 3811 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1121 0 0 6 1071 3811 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1122 0 0 6 1072 3811 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1123 0 0 7 1073 3774 2581 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3811  
1124 0 0 7 1074 3747 2226 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3811  
1125 0 0 7 1077 3810 2974 0 0 1 4 this 3 3811  
1126 0 0 7 1078 3795 2839 0 0 2 4 this 3 3811  5 other 1 3796  
1127 0 0 7 1078 3810 2974 0 0 2 4 this 3 3811  5 other 1 3811  
1128 0 0 7 1079 3795 2839 0 0 2 4 this 3 3811  5 other 1 3796  
1129 0 0 7 1079 3810 2974 0 0 2 4 this 3 3811  5 other 1 3811  
1130 0 0 7 1080 3810 2974 0 0 2 4 this 3 3811  6 scalar 1 3575  
1131 0 0 7 1081 3810 2974 0 0 2 4 this 3 3811  6 scalar 1 3575  
1132 0 0 7 1082 3810 2974 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3811  
1133 0 0 7 1083 3810 2974 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3811  4 onto 1 3796  
1134 0 0 6 1084 3726 0 0 0 1 4 this 3 3811  
1135 0 0 7 1085 3737 0 0 0 0 
1136 0 0 7 1088 3813 2992 0 0 0 
1137 0 0 7 1088 3813 2992 0 10 /**
 *
 */ 2 4 copy 1 3769  1 w 1 3578  
1138 0 0 7 1088 3813 2992 0 10 /**
 *
 */ 1 4 copy 1 3802  
1139 0 0 7 1088 3813 2992 0 0 1 6 param0 0 3814  
1140 0 0 7 1088 3813 2992 0 10 /**
 *
 */ 1 10 fill_value 1 3578  
1141 0 0 7 1088 3813 2992 0 10 /**
 *
 */ 4 1 x 1 3578  1 y 1 3578  1 z 1 3578  1 w 1 3578  
1142 0 0 6 1089 3723 0 0 0 2 4 this 3 3814  9 attr_name 1 3726  
1143 0 0 6 1090 3578 0 0 0 3 4 this 3 3813  9 attr_name 1 3726  6 assign 1 3723  
1144 0 0 6 1091 3814 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1145 0 0 6 1092 3814 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1146 0 0 6 1093 3814 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1147 0 0 6 1094 3814 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1148 0 0 6 1095 3814 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1149 0 0 7 1096 3777 2607 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3814  
1150 0 0 7 1097 3750 2240 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3814  
1151 0 0 7 1100 3813 2992 0 0 1 4 this 3 3814  
1152 0 0 7 1101 3801 2923 0 0 2 4 this 3 3814  5 other 1 3802  
1153 0 0 7 1101 3813 2992 0 0 2 4 this 3 3814  5 other 1 3814  
1154 0 0 7 1102 3801 2923 0 0 2 4 this 3 3814  5 other 1 3802  
1155 0 0 7 1102 3813 2992 0 0 2 4 this 3 3814  5 other 1 3814  
1156 0 0 7 1103 3813 2992 0 0 2 4 this 3 3814  6 scalar 1 3578  
1157 0 0 7 1104 3813 2992 0 0 2 4 this 3 3814  6 scalar 1 3578  
1158 0 0 6 1105 3726 0 0 0 1 4 this 3 3814  
1159 0 0 7 1106 3737 0 0 0 0 
1160 0 0 7 1109 3816 3012 0 0 0 
1161 0 0 7 1109 3816 3012 0 0 1 6 param0 0 3817  
1162 0 0 7 1109 3816 3012 0 10 /**
 *
 */ 2 4 copy 1 3763  1 w 1 3572  
1163 0 0 7 1109 3816 3012 0 10 /**
 *
 */ 1 4 copy 1 3790  
1164 0 0 7 1109 3816 3012 0 10 /**
 *
 */ 1 10 fill_value 1 3572  
1165 0 0 7 1109 3816 3012 0 10 /**
 *
 */ 4 1 x 1 3572  1 y 1 3572  1 z 1 3572  1 w 1 3572  
1166 0 0 6 1110 3723 0 0 0 2 4 this 3 3817  9 attr_name 1 3726  
1167 0 0 6 1111 3578 0 0 0 3 4 this 3 3816  9 attr_name 1 3726  6 assign 1 3723  
1168 0 0 6 1112 3817 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1169 0 0 6 1113 3817 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1170 0 0 6 1114 3817 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1171 0 0 6 1115 3817 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1172 0 0 6 1116 3817 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1173 0 0 7 1117 3780 2630 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3817  
1174 0 0 7 1118 3753 2256 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3817  
1175 0 0 7 1121 3816 3012 0 0 1 4 this 3 3817  
1176 0 0 7 1122 3789 2751 0 0 2 4 this 3 3817  5 other 1 3790  
1177 0 0 7 1122 3816 3012 0 0 2 4 this 3 3817  5 other 1 3808  
1178 0 0 7 1123 3807 2954 0 0 2 4 this 3 3817  5 other 1 3817  
1179 0 0 7 1123 3789 2751 0 0 2 4 this 3 3817  5 other 1 3790  
1180 0 0 7 1123 3816 3012 0 0 2 4 this 3 3817  5 other 1 3808  
1181 0 0 7 1124 3816 3012 0 0 2 4 this 3 3817  6 scalar 1 3572  
1182 0 0 7 1125 3816 3012 0 0 2 4 this 3 3817  6 scalar 1 3572  
1183 0 0 7 1126 3816 3012 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3817  
1184 0 0 7 1127 3816 3012 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3817  4 onto 1 3790  
1185 0 0 6 1128 3726 0 0 0 1 4 this 3 3817  
1186 0 0 7 1129 3737 0 0 0 0 
1187 0 0 7 1132 3819 3032 0 0 0 
1188 0 0 7 1132 3819 3032 0 0 1 6 param0 0 3820  
1189 0 0 7 1132 3819 3032 0 10 /**
 *
 */ 2 4 copy 1 3766  1 w 1 3575  
1190 0 0 7 1132 3819 3032 0 10 /**
 *
 */ 1 4 copy 1 3796  
1191 0 0 7 1132 3819 3032 0 10 /**
 *
 */ 1 10 fill_value 1 3575  
1192 0 0 7 1132 3819 3032 0 10 /**
 *
 */ 4 1 x 1 3575  1 y 1 3575  1 z 1 3575  1 w 1 3575  
1193 0 0 6 1133 3723 0 0 0 2 4 this 3 3820  9 attr_name 1 3726  
1194 0 0 6 1134 3578 0 0 0 3 4 this 3 3819  9 attr_name 1 3726  6 assign 1 3723  
1195 0 0 6 1135 3820 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1196 0 0 6 1136 3820 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1197 0 0 6 1137 3820 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1198 0 0 6 1138 3820 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1199 0 0 6 1139 3820 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1200 0 0 7 1140 3783 2653 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3820  
1201 0 0 7 1141 3756 2272 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3820  
1202 0 0 7 1144 3819 3032 0 0 1 4 this 3 3820  
1203 0 0 7 1145 3795 2839 0 0 2 4 this 3 3820  5 other 1 3796  
1204 0 0 7 1145 3819 3032 0 0 2 4 this 3 3820  5 other 1 3811  
1205 0 0 7 1146 3810 2974 0 0 2 4 this 3 3820  5 other 1 3820  
1206 0 0 7 1146 3795 2839 0 0 2 4 this 3 3820  5 other 1 3796  
1207 0 0 7 1146 3819 3032 0 0 2 4 this 3 3820  5 other 1 3811  
1208 0 0 7 1147 3819 3032 0 0 2 4 this 3 3820  6 scalar 1 3575  
1209 0 0 7 1148 3819 3032 0 0 2 4 this 3 3820  6 scalar 1 3575  
1210 0 0 7 1149 3819 3032 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3820  
1211 0 0 7 1150 3819 3032 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3820  4 onto 1 3796  
1212 0 0 6 1151 3726 0 0 0 1 4 this 3 3820  
1213 0 0 7 1152 3737 0 0 0 0 
1214 0 0 7 1155 3822 3050 0 0 0 
1215 0 0 7 1155 3822 3050 0 0 1 6 param0 0 3823  
1216 0 0 7 1155 3822 3050 0 10 /**
 *
 */ 2 4 copy 1 3769  1 w 1 3578  
1217 0 0 7 1155 3822 3050 0 10 /**
 *
 */ 1 4 copy 1 3802  
1218 0 0 7 1155 3822 3050 0 10 /**
 *
 */ 1 10 fill_value 1 3578  
1219 0 0 7 1155 3822 3050 0 10 /**
 *
 */ 4 1 x 1 3578  1 y 1 3578  1 z 1 3578  1 w 1 3578  
1220 0 0 6 1156 3723 0 0 0 2 4 this 3 3823  9 attr_name 1 3726  
1221 0 0 6 1157 3578 0 0 0 3 4 this 3 3822  9 attr_name 1 3726  6 assign 1 3723  
1222 0 0 6 1158 3823 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1223 0 0 6 1159 3823 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1224 0 0 6 1160 3823 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1225 0 0 6 1161 3823 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1226 0 0 6 1162 3823 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1227 0 0 7 1163 3786 2674 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3823  
1228 0 0 7 1164 3759 2286 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3823  
1229 0 0 7 1167 3822 3050 0 0 1 4 this 3 3823  
1230 0 0 7 1168 3801 2923 0 0 2 4 this 3 3823  5 other 1 3802  
1231 0 0 7 1168 3822 3050 0 0 2 4 this 3 3823  5 other 1 3814  
1232 0 0 7 1169 3813 2992 0 0 2 4 this 3 3823  5 other 1 3823  
1233 0 0 7 1169 3801 2923 0 0 2 4 this 3 3823  5 other 1 3802  
1234 0 0 7 1169 3822 3050 0 0 2 4 this 3 3823  5 other 1 3814  
1235 0 0 7 1170 3822 3050 0 0 2 4 this 3 3823  6 scalar 1 3578  
1236 0 0 7 1171 3822 3050 0 0 2 4 this 3 3823  6 scalar 1 3578  
1237 0 0 6 1172 3726 0 0 0 1 4 this 3 3823  
1238 0 0 7 1173 3737 0 0 0 0 
1239 0 0 7 1189 3825 3136 0 0 0 
1240 0 0 7 1189 3825 3136 0 0 1 5 other 1 3826  
1241 0 0 7 1189 3825 3136 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3763  6 param1 0 3763  6 param2 0 3763  
1242 0 0 7 1189 3825 3136 0 10 /**
 *
 */ 9 6 param0 0 3572  6 param1 0 3572  6 param2 0 3572  6 param3 0 3572  6 param4 0 3572  6 param5 0 3572  6 param6 0 3572  6 param7 0 3572  6 param8 0 3572  
1243 0 0 6 1190 3825 0 0 0 2 4 this 3 3825  5 other 1 3826  
1244 0 0 6 1190 3825 0 0 10 /**
 *
 */ 2 4 this 3 3825  10 fill_value 1 3572  
1245 0 0 4 1191 3722 0 0 0 2 4 this 3 3825  4 size 1 3720  
1246 0 0 6 1194 3723 0 0 0 1 4 this 3 3826  
1247 0 0 4 1195 3722 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3825  10 fill_value 1 3572  
1248 0 0 4 1196 3722 0 0 10 /**
 *
 */ 10 4 this 3 3825  3 e00 1 3572  3 e01 1 3572  3 e02 1 3572  3 e10 1 3572  3 e11 1 3572  3 e12 1 3572  3 e20 1 3572  3 e21 1 3572  3 e22 1 3572  
1249 0 0 7 1197 3828 3055 0 0 2 4 this 3 3825  1 i 1 3578  
1250 0 0 7 1197 3829 3060 0 0 2 4 this 3 3826  1 i 1 3578  
1251 0 0 6 1198 3578 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1252 0 0 4 1199 3722 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3825  3 row 1 3578  1 v 1 3718  
1253 0 0 4 1199 3722 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3825  3 row 1 3578  1 v 1 3763  
1254 0 0 4 1200 3722 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3825  3 col 1 3578  1 v 1 3718  
1255 0 0 4 1200 3722 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3825  3 col 1 3578  1 v 1 3763  
1256 0 0 4 1201 3722 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3826  10 result_vec 1 3762  3 row 1 3578  
1257 0 0 7 1201 3762 2362 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3826  3 row 1 3578  
1258 0 0 7 1202 3762 2362 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3826  3 col 1 3578  
1259 0 0 7 1207 3717 2062 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3826  3 row 1 3578  
1260 0 0 7 1208 3717 2062 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3826  3 col 1 3578  
1261 0 0 4 1211 3722 0 0 10 /**
 *
 */ 3 4 this 3 3825  3 row 1 3578  3 col 1 3578  
1262 0 0 6 1211 3572 0 0 0 3 4 this 3 3826  3 row 1 3578  3 col 1 3578  
1263 0 0 6 1212 3727 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3826  
1264 0 0 6 1213 3727 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3826  
1265 0 0 6 1214 3572 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3826  3 row 1 3578  3 col 1 3578  
1266 0 0 4 1215 3722 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3825  3 row 1 3578  3 col 1 3578  5 value 1 3572  
1267 0 0 4 1216 3722 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3826  
1268 0 0 6 1217 3578 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3826  
1269 0 0 6 1218 3727 0 0 0 2 4 this 3 3826  5 other 1 3826  
1270 0 0 6 1219 3727 0 0 0 2 4 this 3 3826  5 other 1 3826  
1271 0 0 6 1220 3727 0 0 0 2 4 this 3 3826  5 other 1 3826  
1272 0 0 6 1221 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3826  5 other 1 3826  
1273 0 0 6 1221 3578 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3826  5 other 1 3826  9 threshold 1 3572  
1274 0 0 6 1222 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3826  
1275 0 0 6 1222 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3826  9 threshold 1 3572  
1276 0 0 6 1223 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3826  4 hash 1 3720  
1277 0 0 6 1223 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3826  4 hash 1 3720  9 threshold 1 3572  
1278 0 0 7 1224 3762 2362 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3826  1 v 1 3763  
1279 0 0 7 1225 3717 2062 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3826  1 v 1 3718  
1280 0 0 7 1226 3717 2062 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3826  1 v 1 3718  
1281 0 0 7 1226 3762 2362 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3826  1 v 1 3763  
1282 0 0 7 1227 3762 2362 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3826  1 v 1 3763  
1283 0 0 4 1228 3722 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3826  1 v 1 3762  
1284 0 0 4 1229 3722 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3826  1 v 1 3717  
1285 0 0 4 1230 3722 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3826  1 v 1 3717  
1286 0 0 4 1230 3722 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3826  1 v 1 3762  
1287 0 0 4 1231 3722 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3826  1 v 1 3762  
1288 0 0 4 1232 3722 0 0 25 // this = other1 * other2 3 4 this 3 3825  6 other1 1 3826  6 other2 1 3826  
1289 0 0 7 1233 3825 3136 0 0 2 4 this 3 3826  5 other 1 3826  
1290 0 0 7 1233 3825 3136 0 0 2 4 this 3 3826  6 scalar 1 3572  
1291 0 0 7 1234 3825 3136 0 0 2 4 this 3 3826  6 scalar 1 3572  
1292 0 0 6 1235 3825 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3825  5 other 1 3826  
1293 0 0 6 1236 3825 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3825  5 other 1 3826  
1294 0 0 6 1237 3825 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 other 1 3826  
1295 0 0 6 1237 3825 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3825  6 scalar 1 3572  
1296 0 0 6 1238 3825 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3825  6 scalar 1 3572  
1297 0 0 4 1239 3722 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 other 1 3826  
1298 0 0 6 1240 3572 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3826  
1299 0 0 4 1241 3722 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 other 1 3826  
1300 0 0 4 1242 3722 0 0 10 /**
 *
 */ 1 4 this 3 3825  
1301 0 0 6 1243 3727 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3825  5 other 1 3826  
1302 0 0 6 1244 3727 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3825  
1303 0 0 6 1245 3727 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3825  5 other 1 3826  
1304 0 0 6 1245 3727 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3825  5 other 1 3830  
1305 0 0 6 1246 3826 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1306 0 0 4 1247 3722 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3825  5 trans 1 3718  
1307 0 0 4 1248 3722 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3825  5 angle 1 3572  
1308 0 0 4 1248 3722 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3825  5 angle 1 3572  4 axis 1 3763  2 cs 1 3591  
1309 0 0 4 1249 3722 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3825  5 scale 1 3718  
1310 0 0 4 1249 3722 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3825  5 scale 1 3763  
1311 0 0 7 1250 3825 3136 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3718  
1312 0 0 7 1250 3825 3136 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3572  2 ty 1 3572  
1313 0 0 7 1251 3825 3136 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3572  
1314 0 0 7 1251 3825 3136 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3572  4 axis 1 3763  2 cs 1 3591  
1315 0 0 7 1252 3825 3136 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3718  
1316 0 0 7 1252 3825 3136 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3763  
1317 0 0 7 1252 3825 3136 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3572  2 sy 1 3572  
1318 0 0 7 1252 3825 3136 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3572  2 sy 1 3572  2 sz 1 3572  
1319 0 0 4 1253 3722 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3825  5 angle 1 3572  4 axis 1 3763  2 cs 1 3591  
1320 0 0 7 1254 3825 3136 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3572  4 axis 1 3763  2 cs 1 3591  
1321 0 0 4 1255 3722 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3825  5 shear 1 3763  2 cs 1 3591  
1322 0 0 7 1256 3825 3136 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3763  2 cs 1 3591  
1323 0 0 7 1256 3825 3136 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3572  4 shxz 1 3572  4 shyz 1 3572  2 cs 1 3591  
1324 0 0 4 1257 3722 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3825  5 scale 1 3763  5 shear 1 3763  2 cs 1 3591  
1325 0 0 7 1258 3825 3136 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3763  5 shear 1 3763  2 cs 1 3591  
1326 0 0 7 1258 3825 3136 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3572  2 sy 1 3572  2 sz 1 3572  4 shxy 1 3572  4 shxz 1 3572  4 shyz 1 3572  2 cs 1 3591  
1327 0 0 6 1259 3826 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3591  2 to 1 3591  
1328 0 0 6 1260 3727 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3826  5 other 1 3826  
1329 0 0 6 1260 3727 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3826  5 other 1 3826  9 threshold 1 3572  
1330 0 0 4 1261 3722 0 0 10 /**
 *
 */ 2 4 this 3 3826  3 out 1 3730  
1331 0 0 4 1262 3722 0 0 10 /**
 *
 */ 3 4 this 3 3826  3 out 1 3730  12 indent_level 1 3578  
1332 0 0 6 1263 3726 0 0 0 1 4 this 3 3826  
1333 0 0 4 1264 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3826  7 hashgen 1 3728  
1334 0 0 4 1264 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3826  7 hashgen 1 3728  9 threshold 1 3572  
1335 0 0 4 1265 3722 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3826  11 destination 1 3732  
1336 0 0 4 1266 3722 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3825  4 scan 1 3734  
1337 0 0 4 1267 3722 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3826  11 destination 1 3732  
1338 0 0 4 1268 3722 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3825  6 source 1 3734  
1339 0 0 7 1269 3737 0 0 0 0 
1340 0 0 7 1181 3828 3055 0 0 1 6 param0 0 3832  
1341 0 0 4 1178 3722 0 0 10 /**
 *
 */ 3 4 this 3 3828  1 i 1 3578  10 assign_val 1 3572  
1342 0 0 6 1178 3572 0 0 0 2 4 this 3 3832  1 i 1 3578  
1343 0 0 6 1179 3578 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1344 0 0 6 1180 3763 0 0 0 1 4 this 3 3832  
1345 0 0 7 1187 3829 3060 0 0 1 6 param0 0 3834  
1346 0 0 6 1184 3572 0 0 0 2 4 this 3 3834  1 i 1 3578  
1347 0 0 6 1185 3578 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1348 0 0 6 1186 3763 0 0 0 1 4 this 3 3834  
1349 0 0 7 1287 3836 3234 0 0 0 
1350 0 0 7 1287 3836 3234 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3826  
1351 0 0 7 1287 3836 3234 0 10 /**
 *
 */ 2 6 upper3 1 3826  5 trans 1 3763  
1352 0 0 7 1287 3836 3234 0 0 1 5 other 1 3830  
1353 0 0 7 1287 3836 3234 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3790  6 param1 0 3790  6 param2 0 3790  6 param3 0 3790  
1354 0 0 7 1287 3836 3234 0 10 /**
 *
 */ 1 5 other 1 3837  
1355 0 0 7 1287 3836 3234 0 10 /**
 *
 */ 16 6 param0 0 3572  6 param1 0 3572  6 param2 0 3572  6 param3 0 3572  6 param4 0 3572  6 param5 0 3572  6 param6 0 3572  6 param7 0 3572  6 param8 0 3572  6 param9 0 3572  7 param10 0 3572  7 param11 0 3572  7 param12 0 3572  7 param13 0 3572  7 param14 0 3572  7 param15 0 3572  
1356 0 0 6 1288 3836 0 0 0 2 4 this 3 3836  5 other 1 3830  
1357 0 0 6 1288 3836 0 0 10 /**
 *
 */ 2 4 this 3 3836  5 other 1 3837  
1358 0 0 6 1288 3836 0 0 10 /**
 *
 */ 2 4 this 3 3836  10 fill_value 1 3572  
1359 0 0 4 1289 3722 0 0 0 2 4 this 3 3836  4 size 1 3720  
1360 0 0 6 1292 3723 0 0 0 1 4 this 3 3830  
1361 0 0 4 1293 3722 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3836  10 fill_value 1 3572  
1362 0 0 4 1294 3722 0 0 10 /**
 *
 */ 17 4 this 3 3836  3 e00 1 3572  3 e01 1 3572  3 e02 1 3572  3 e03 1 3572  3 e10 1 3572  3 e11 1 3572  3 e12 1 3572  3 e13 1 3572  3 e20 1 3572  3 e21 1 3572  3 e22 1 3572  3 e23 1 3572  3 e30 1 3572  3 e31 1 3572  3 e32 1 3572  3 e33 1 3572  
1363 0 0 4 1295 3722 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3836  6 upper3 1 3826  
1364 0 0 7 1296 3825 3136 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3830  
1365 0 0 7 1297 3839 3143 0 0 2 4 this 3 3836  1 i 1 3578  
1366 0 0 7 1297 3840 3148 0 0 2 4 this 3 3830  1 i 1 3578  
1367 0 0 6 1298 3578 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1368 0 0 4 1299 3722 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3836  3 row 1 3578  1 v 1 3763  
1369 0 0 4 1299 3722 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3836  3 row 1 3578  1 v 1 3790  
1370 0 0 4 1300 3722 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3836  3 col 1 3578  1 v 1 3763  
1371 0 0 4 1300 3722 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3836  3 col 1 3578  1 v 1 3790  
1372 0 0 4 1301 3722 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3830  10 result_vec 1 3789  3 row 1 3578  
1373 0 0 7 1301 3789 2751 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3830  3 row 1 3578  
1374 0 0 7 1302 3789 2751 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3830  3 col 1 3578  
1375 0 0 4 1303 3722 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3830  10 result_vec 1 3762  3 row 1 3578  
1376 0 0 7 1303 3762 2362 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3830  3 row 1 3578  
1377 0 0 7 1309 3762 2362 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3830  3 col 1 3578  
1378 0 0 4 1310 3722 0 0 10 /**
 *
 */ 3 4 this 3 3836  3 row 1 3578  3 col 1 3578  
1379 0 0 6 1310 3572 0 0 0 3 4 this 3 3830  3 row 1 3578  3 col 1 3578  
1380 0 0 6 1311 3727 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3830  
1381 0 0 6 1312 3727 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3830  
1382 0 0 6 1313 3572 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3830  3 row 1 3578  3 col 1 3578  
1383 0 0 4 1314 3722 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3836  3 row 1 3578  3 col 1 3578  5 value 1 3572  
1384 0 0 4 1315 3722 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3830  
1385 0 0 6 1316 3578 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3830  
1386 0 0 4 1317 3722 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3836  
1387 0 0 4 1317 3722 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3830  
1388 0 0 4 1318 3722 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3836  
1389 0 0 4 1318 3722 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3830  
1390 0 0 6 1319 3727 0 0 0 2 4 this 3 3830  5 other 1 3830  
1391 0 0 6 1320 3727 0 0 0 2 4 this 3 3830  5 other 1 3830  
1392 0 0 6 1321 3727 0 0 0 2 4 this 3 3830  5 other 1 3830  
1393 0 0 6 1322 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3830  5 other 1 3830  
1394 0 0 6 1322 3578 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3830  5 other 1 3830  9 threshold 1 3572  
1395 0 0 6 1323 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3830  
1396 0 0 6 1323 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3830  9 threshold 1 3572  
1397 0 0 6 1324 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3830  4 hash 1 3720  
1398 0 0 6 1324 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3830  4 hash 1 3720  9 threshold 1 3572  
1399 0 0 7 1325 3789 2751 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3830  1 v 1 3790  
1400 0 0 7 1326 3762 2362 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3830  1 v 1 3763  
1401 0 0 7 1327 3762 2362 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3830  1 v 1 3763  
1402 0 0 7 1328 3762 2362 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3830  1 v 1 3763  
1403 0 0 7 1329 3762 2362 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3830  1 v 1 3763  
1404 0 0 4 1330 3722 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3830  1 v 1 3789  
1405 0 0 4 1331 3722 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3830  1 v 1 3762  
1406 0 0 4 1332 3722 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3830  1 v 1 3762  
1407 0 0 4 1333 3722 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3830  1 v 1 3762  
1408 0 0 4 1334 3722 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3830  1 v 1 3762  
1409 0 0 4 1335 3722 0 0 25 // this = other1 * other2 3 4 this 3 3836  6 other1 1 3830  6 other2 1 3830  
1410 0 0 7 1336 3836 3234 0 0 2 4 this 3 3830  5 other 1 3830  
1411 0 0 7 1336 3836 3234 0 0 2 4 this 3 3830  6 scalar 1 3572  
1412 0 0 7 1337 3836 3234 0 0 2 4 this 3 3830  6 scalar 1 3572  
1413 0 0 6 1338 3836 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3836  5 other 1 3830  
1414 0 0 6 1339 3836 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3836  5 other 1 3830  
1415 0 0 6 1340 3836 0 0 10 /**
 *
 */ 2 4 this 3 3836  5 other 1 3830  
1416 0 0 6 1340 3836 0 0 10 /**
 *
 */ 2 4 this 3 3836  6 scalar 1 3572  
1417 0 0 6 1341 3836 0 0 10 /**
 *
 */ 2 4 this 3 3836  6 scalar 1 3572  
1418 0 0 4 1342 3722 0 0 10 /**
 *
 */ 2 4 this 3 3836  5 other 1 3830  
1419 0 0 4 1343 3722 0 0 10 /**
 *
 */ 2 4 this 3 3836  5 other 1 3830  
1420 0 0 4 1344 3722 0 0 10 /**
 *
 */ 1 4 this 3 3836  
1421 0 0 6 1345 3727 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3836  5 other 1 3830  
1422 0 0 6 1346 3727 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3836  5 other 1 3830  
1423 0 0 6 1347 3727 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3836  
1424 0 0 4 1348 3722 0 0 48 /**
 * Computes `(*this) += other * weight`.
 */ 3 4 this 3 3836  5 other 1 3830  6 weight 1 3572  
1425 0 0 6 1349 3830 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1426 0 0 6 1350 3830 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1427 0 0 6 1351 3830 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1428 0 0 4 1352 3722 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3836  5 trans 1 3763  
1429 0 0 4 1353 3722 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3836  5 angle 1 3572  4 axis 1 3763  2 cs 1 3591  
1430 0 0 4 1354 3722 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3836  5 angle 1 3572  4 axis 1 3763  2 cs 1 3591  
1431 0 0 4 1355 3722 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3836  5 scale 1 3763  
1432 0 0 4 1356 3722 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3836  5 shear 1 3763  2 cs 1 3591  
1433 0 0 4 1357 3722 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3836  5 scale 1 3763  5 shear 1 3763  2 cs 1 3591  
1434 0 0 7 1358 3836 3234 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3763  
1435 0 0 7 1358 3836 3234 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3572  2 ty 1 3572  2 tz 1 3572  
1436 0 0 7 1359 3836 3234 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3572  4 axis 1 3763  2 cs 1 3591  
1437 0 0 7 1360 3836 3234 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3572  4 axis 1 3763  2 cs 1 3591  
1438 0 0 7 1361 3836 3234 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3763  
1439 0 0 7 1361 3836 3234 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3572  
1440 0 0 7 1361 3836 3234 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3572  2 sy 1 3572  2 sz 1 3572  
1441 0 0 7 1362 3836 3234 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3763  2 cs 1 3591  
1442 0 0 7 1362 3836 3234 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3572  4 shxz 1 3572  4 shyz 1 3572  2 cs 1 3591  
1443 0 0 7 1363 3836 3234 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3763  5 shear 1 3763  2 cs 1 3591  
1444 0 0 7 1363 3836 3234 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3572  2 sy 1 3572  2 sz 1 3572  4 shxy 1 3572  4 shxz 1 3572  4 shyz 1 3572  2 cs 1 3591  
1445 0 0 6 1364 3830 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1446 0 0 6 1365 3830 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1447 0 0 6 1366 3830 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3591  2 to 1 3591  
1448 0 0 6 1367 3727 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3830  5 other 1 3830  
1449 0 0 6 1367 3727 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3830  5 other 1 3830  9 threshold 1 3572  
1450 0 0 4 1368 3722 0 0 10 /**
 *
 */ 2 4 this 3 3830  3 out 1 3730  
1451 0 0 4 1369 3722 0 0 10 /**
 *
 */ 3 4 this 3 3830  3 out 1 3730  12 indent_level 1 3578  
1452 0 0 6 1370 3726 0 0 0 1 4 this 3 3830  
1453 0 0 4 1371 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3830  7 hashgen 1 3728  
1454 0 0 4 1371 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3830  7 hashgen 1 3728  5 scale 1 3572  
1455 0 0 4 1372 3722 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3830  11 destination 1 3732  
1456 0 0 4 1373 3722 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3836  4 scan 1 3734  
1457 0 0 4 1374 3722 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3830  11 destination 1 3732  
1458 0 0 4 1375 3722 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3836  6 source 1 3734  
1459 0 0 7 1376 3737 0 0 0 0 
1460 0 0 7 1279 3839 3143 0 0 1 6 param0 0 3841  
1461 0 0 4 1276 3722 0 0 10 /**
 *
 */ 3 4 this 3 3839  1 i 1 3578  10 assign_val 1 3572  
1462 0 0 6 1276 3572 0 0 0 2 4 this 3 3841  1 i 1 3578  
1463 0 0 6 1277 3578 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1464 0 0 6 1278 3790 0 0 0 1 4 this 3 3841  
1465 0 0 7 1285 3840 3148 0 0 1 6 param0 0 3843  
1466 0 0 6 1282 3572 0 0 0 2 4 this 3 3843  1 i 1 3578  
1467 0 0 6 1283 3578 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1468 0 0 6 1284 3790 0 0 0 1 4 this 3 3843  
1469 0 0 7 1380 3845 3244 0 0 0 
1470 0 0 7 1380 3845 3244 0 10 /**
 *
 */ 1 4 copy 1 3830  
1471 0 0 7 1380 3845 3244 0 0 1 4 copy 1 3837  
1472 0 0 7 1380 3845 3244 0 10 /**
 *
 */ 16 3 e00 1 3572  3 e01 1 3572  3 e02 1 3572  3 e03 1 3572  3 e10 1 3572  3 e11 1 3572  3 e12 1 3572  3 e13 1 3572  3 e20 1 3572  3 e21 1 3572  3 e22 1 3572  3 e23 1 3572  3 e30 1 3572  3 e31 1 3572  3 e32 1 3572  3 e33 1 3572  
1473 0 0 6 1381 3845 0 0 10 /**
 *
 */ 2 4 this 3 3845  4 copy 1 3830  
1474 0 0 6 1381 3845 0 0 0 2 4 this 3 3845  4 copy 1 3837  
1475 0 0 4 1382 3722 0 0 10 /**
 *
 */ 17 4 this 3 3845  3 e00 1 3572  3 e01 1 3572  3 e02 1 3572  3 e03 1 3572  3 e10 1 3572  3 e11 1 3572  3 e12 1 3572  3 e13 1 3572  3 e20 1 3572  3 e21 1 3572  3 e22 1 3572  3 e23 1 3572  3 e30 1 3572  3 e31 1 3572  3 e32 1 3572  3 e33 1 3572  
1476 0 0 4 1383 3722 0 0 10 /**
 *
 */ 3 4 this 3 3845  3 row 1 3578  3 col 1 3578  
1477 0 0 6 1383 3572 0 0 0 3 4 this 3 3837  3 row 1 3578  3 col 1 3578  
1478 0 0 4 1384 3722 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3837  
1479 0 0 6 1385 3578 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3837  
1480 0 0 6 1386 3727 0 0 0 2 4 this 3 3837  5 other 1 3837  
1481 0 0 6 1387 3727 0 0 0 2 4 this 3 3837  5 other 1 3837  
1482 0 0 7 1388 3737 0 0 0 0 
1483 0 0 7 1404 3846 3330 0 0 0 
1484 0 0 7 1404 3846 3330 0 0 1 5 other 1 3847  
1485 0 0 7 1404 3846 3330 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3766  6 param1 0 3766  6 param2 0 3766  
1486 0 0 7 1404 3846 3330 0 10 /**
 *
 */ 9 6 param0 0 3575  6 param1 0 3575  6 param2 0 3575  6 param3 0 3575  6 param4 0 3575  6 param5 0 3575  6 param6 0 3575  6 param7 0 3575  6 param8 0 3575  
1487 0 0 6 1405 3846 0 0 0 2 4 this 3 3846  5 other 1 3847  
1488 0 0 6 1405 3846 0 0 10 /**
 *
 */ 2 4 this 3 3846  10 fill_value 1 3575  
1489 0 0 4 1406 3722 0 0 0 2 4 this 3 3846  4 size 1 3720  
1490 0 0 6 1409 3723 0 0 0 1 4 this 3 3847  
1491 0 0 4 1410 3722 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3846  10 fill_value 1 3575  
1492 0 0 4 1411 3722 0 0 10 /**
 *
 */ 10 4 this 3 3846  3 e00 1 3575  3 e01 1 3575  3 e02 1 3575  3 e10 1 3575  3 e11 1 3575  3 e12 1 3575  3 e20 1 3575  3 e21 1 3575  3 e22 1 3575  
1493 0 0 7 1412 3849 3249 0 0 2 4 this 3 3846  1 i 1 3578  
1494 0 0 7 1412 3850 3254 0 0 2 4 this 3 3847  1 i 1 3578  
1495 0 0 6 1413 3578 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1496 0 0 4 1414 3722 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3846  3 row 1 3578  1 v 1 3739  
1497 0 0 4 1414 3722 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3846  3 row 1 3578  1 v 1 3766  
1498 0 0 4 1415 3722 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3846  3 col 1 3578  1 v 1 3739  
1499 0 0 4 1415 3722 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3846  3 col 1 3578  1 v 1 3766  
1500 0 0 4 1416 3722 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3847  10 result_vec 1 3765  3 row 1 3578  
1501 0 0 7 1416 3765 2438 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3847  3 row 1 3578  
1502 0 0 7 1417 3765 2438 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3847  3 col 1 3578  
1503 0 0 7 1422 3738 2128 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3847  3 row 1 3578  
1504 0 0 7 1423 3738 2128 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3847  3 col 1 3578  
1505 0 0 4 1426 3722 0 0 10 /**
 *
 */ 3 4 this 3 3846  3 row 1 3578  3 col 1 3578  
1506 0 0 6 1426 3575 0 0 0 3 4 this 3 3847  3 row 1 3578  3 col 1 3578  
1507 0 0 6 1427 3727 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3847  
1508 0 0 6 1428 3727 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3847  
1509 0 0 6 1429 3575 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3847  3 row 1 3578  3 col 1 3578  
1510 0 0 4 1430 3722 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3846  3 row 1 3578  3 col 1 3578  5 value 1 3575  
1511 0 0 4 1431 3722 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3847  
1512 0 0 6 1432 3578 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3847  
1513 0 0 6 1433 3727 0 0 0 2 4 this 3 3847  5 other 1 3847  
1514 0 0 6 1434 3727 0 0 0 2 4 this 3 3847  5 other 1 3847  
1515 0 0 6 1435 3727 0 0 0 2 4 this 3 3847  5 other 1 3847  
1516 0 0 6 1436 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3847  5 other 1 3847  
1517 0 0 6 1436 3578 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3847  5 other 1 3847  9 threshold 1 3575  
1518 0 0 6 1437 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3847  
1519 0 0 6 1437 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3847  9 threshold 1 3575  
1520 0 0 6 1438 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3847  4 hash 1 3720  
1521 0 0 6 1438 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3847  4 hash 1 3720  9 threshold 1 3575  
1522 0 0 7 1439 3765 2438 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3847  1 v 1 3766  
1523 0 0 7 1440 3738 2128 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3847  1 v 1 3739  
1524 0 0 7 1441 3738 2128 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3847  1 v 1 3739  
1525 0 0 7 1441 3765 2438 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3847  1 v 1 3766  
1526 0 0 7 1442 3765 2438 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3847  1 v 1 3766  
1527 0 0 4 1443 3722 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3847  1 v 1 3765  
1528 0 0 4 1444 3722 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3847  1 v 1 3738  
1529 0 0 4 1445 3722 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3847  1 v 1 3738  
1530 0 0 4 1445 3722 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3847  1 v 1 3765  
1531 0 0 4 1446 3722 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3847  1 v 1 3765  
1532 0 0 4 1447 3722 0 0 25 // this = other1 * other2 3 4 this 3 3846  6 other1 1 3847  6 other2 1 3847  
1533 0 0 7 1448 3846 3330 0 0 2 4 this 3 3847  5 other 1 3847  
1534 0 0 7 1448 3846 3330 0 0 2 4 this 3 3847  6 scalar 1 3575  
1535 0 0 7 1449 3846 3330 0 0 2 4 this 3 3847  6 scalar 1 3575  
1536 0 0 6 1450 3846 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3846  5 other 1 3847  
1537 0 0 6 1451 3846 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3846  5 other 1 3847  
1538 0 0 6 1452 3846 0 0 10 /**
 *
 */ 2 4 this 3 3846  5 other 1 3847  
1539 0 0 6 1452 3846 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3846  6 scalar 1 3575  
1540 0 0 6 1453 3846 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3846  6 scalar 1 3575  
1541 0 0 4 1454 3722 0 0 10 /**
 *
 */ 2 4 this 3 3846  5 other 1 3847  
1542 0 0 6 1455 3575 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3847  
1543 0 0 4 1456 3722 0 0 10 /**
 *
 */ 2 4 this 3 3846  5 other 1 3847  
1544 0 0 4 1457 3722 0 0 10 /**
 *
 */ 1 4 this 3 3846  
1545 0 0 6 1458 3727 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3846  5 other 1 3847  
1546 0 0 6 1459 3727 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3846  
1547 0 0 6 1460 3727 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3846  5 other 1 3847  
1548 0 0 6 1460 3727 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3846  5 other 1 3851  
1549 0 0 6 1461 3847 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1550 0 0 4 1462 3722 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3846  5 trans 1 3739  
1551 0 0 4 1463 3722 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3846  5 angle 1 3575  
1552 0 0 4 1463 3722 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3846  5 angle 1 3575  4 axis 1 3766  2 cs 1 3591  
1553 0 0 4 1464 3722 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3846  5 scale 1 3739  
1554 0 0 4 1464 3722 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3846  5 scale 1 3766  
1555 0 0 7 1465 3846 3330 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3739  
1556 0 0 7 1465 3846 3330 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3575  2 ty 1 3575  
1557 0 0 7 1466 3846 3330 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3575  
1558 0 0 7 1466 3846 3330 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3575  4 axis 1 3766  2 cs 1 3591  
1559 0 0 7 1467 3846 3330 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3739  
1560 0 0 7 1467 3846 3330 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3766  
1561 0 0 7 1467 3846 3330 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3575  2 sy 1 3575  
1562 0 0 7 1467 3846 3330 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3575  2 sy 1 3575  2 sz 1 3575  
1563 0 0 4 1468 3722 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3846  5 angle 1 3575  4 axis 1 3766  2 cs 1 3591  
1564 0 0 7 1469 3846 3330 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3575  4 axis 1 3766  2 cs 1 3591  
1565 0 0 4 1470 3722 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3846  5 shear 1 3766  2 cs 1 3591  
1566 0 0 7 1471 3846 3330 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3766  2 cs 1 3591  
1567 0 0 7 1471 3846 3330 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3575  4 shxz 1 3575  4 shyz 1 3575  2 cs 1 3591  
1568 0 0 4 1472 3722 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3846  5 scale 1 3766  5 shear 1 3766  2 cs 1 3591  
1569 0 0 7 1473 3846 3330 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3766  5 shear 1 3766  2 cs 1 3591  
1570 0 0 7 1473 3846 3330 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3575  2 sy 1 3575  2 sz 1 3575  4 shxy 1 3575  4 shxz 1 3575  4 shyz 1 3575  2 cs 1 3591  
1571 0 0 6 1474 3847 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3591  2 to 1 3591  
1572 0 0 6 1475 3727 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3847  5 other 1 3847  
1573 0 0 6 1475 3727 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3847  5 other 1 3847  9 threshold 1 3575  
1574 0 0 4 1476 3722 0 0 10 /**
 *
 */ 2 4 this 3 3847  3 out 1 3730  
1575 0 0 4 1477 3722 0 0 10 /**
 *
 */ 3 4 this 3 3847  3 out 1 3730  12 indent_level 1 3578  
1576 0 0 6 1478 3726 0 0 0 1 4 this 3 3847  
1577 0 0 4 1479 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3847  7 hashgen 1 3728  
1578 0 0 4 1479 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3847  7 hashgen 1 3728  9 threshold 1 3575  
1579 0 0 4 1480 3722 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3847  11 destination 1 3732  
1580 0 0 4 1481 3722 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3846  4 scan 1 3734  
1581 0 0 4 1482 3722 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3847  11 destination 1 3732  
1582 0 0 4 1483 3722 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3846  6 source 1 3734  
1583 0 0 7 1484 3737 0 0 0 0 
1584 0 0 7 1396 3849 3249 0 0 1 6 param0 0 3853  
1585 0 0 4 1393 3722 0 0 10 /**
 *
 */ 3 4 this 3 3849  1 i 1 3578  10 assign_val 1 3575  
1586 0 0 6 1393 3575 0 0 0 2 4 this 3 3853  1 i 1 3578  
1587 0 0 6 1394 3578 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1588 0 0 6 1395 3766 0 0 0 1 4 this 3 3853  
1589 0 0 7 1402 3850 3254 0 0 1 6 param0 0 3855  
1590 0 0 6 1399 3575 0 0 0 2 4 this 3 3855  1 i 1 3578  
1591 0 0 6 1400 3578 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1592 0 0 6 1401 3766 0 0 0 1 4 this 3 3855  
1593 0 0 7 1500 3857 3426 0 0 0 
1594 0 0 7 1500 3857 3426 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3847  
1595 0 0 7 1500 3857 3426 0 10 /**
 *
 */ 2 6 upper3 1 3847  5 trans 1 3766  
1596 0 0 7 1500 3857 3426 0 0 1 5 other 1 3851  
1597 0 0 7 1500 3857 3426 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3796  6 param1 0 3796  6 param2 0 3796  6 param3 0 3796  
1598 0 0 7 1500 3857 3426 0 10 /**
 *
 */ 1 5 other 1 3858  
1599 0 0 7 1500 3857 3426 0 10 /**
 *
 */ 16 6 param0 0 3575  6 param1 0 3575  6 param2 0 3575  6 param3 0 3575  6 param4 0 3575  6 param5 0 3575  6 param6 0 3575  6 param7 0 3575  6 param8 0 3575  6 param9 0 3575  7 param10 0 3575  7 param11 0 3575  7 param12 0 3575  7 param13 0 3575  7 param14 0 3575  7 param15 0 3575  
1600 0 0 6 1501 3857 0 0 0 2 4 this 3 3857  5 other 1 3851  
1601 0 0 6 1501 3857 0 0 10 /**
 *
 */ 2 4 this 3 3857  5 other 1 3858  
1602 0 0 6 1501 3857 0 0 10 /**
 *
 */ 2 4 this 3 3857  10 fill_value 1 3575  
1603 0 0 4 1502 3722 0 0 0 2 4 this 3 3857  4 size 1 3720  
1604 0 0 6 1505 3723 0 0 0 1 4 this 3 3851  
1605 0 0 4 1506 3722 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3857  10 fill_value 1 3575  
1606 0 0 4 1507 3722 0 0 10 /**
 *
 */ 17 4 this 3 3857  3 e00 1 3575  3 e01 1 3575  3 e02 1 3575  3 e03 1 3575  3 e10 1 3575  3 e11 1 3575  3 e12 1 3575  3 e13 1 3575  3 e20 1 3575  3 e21 1 3575  3 e22 1 3575  3 e23 1 3575  3 e30 1 3575  3 e31 1 3575  3 e32 1 3575  3 e33 1 3575  
1607 0 0 4 1508 3722 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3857  6 upper3 1 3847  
1608 0 0 7 1509 3846 3330 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3851  
1609 0 0 7 1510 3860 3335 0 0 2 4 this 3 3857  1 i 1 3578  
1610 0 0 7 1510 3861 3340 0 0 2 4 this 3 3851  1 i 1 3578  
1611 0 0 6 1511 3578 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1612 0 0 4 1512 3722 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3857  3 row 1 3578  1 v 1 3766  
1613 0 0 4 1512 3722 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3857  3 row 1 3578  1 v 1 3796  
1614 0 0 4 1513 3722 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3857  3 col 1 3578  1 v 1 3766  
1615 0 0 4 1513 3722 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3857  3 col 1 3578  1 v 1 3796  
1616 0 0 4 1514 3722 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3851  10 result_vec 1 3795  3 row 1 3578  
1617 0 0 7 1514 3795 2839 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3851  3 row 1 3578  
1618 0 0 7 1515 3795 2839 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3851  3 col 1 3578  
1619 0 0 4 1516 3722 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3851  10 result_vec 1 3765  3 row 1 3578  
1620 0 0 7 1516 3765 2438 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3851  3 row 1 3578  
1621 0 0 7 1522 3765 2438 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3851  3 col 1 3578  
1622 0 0 4 1523 3722 0 0 10 /**
 *
 */ 3 4 this 3 3857  3 row 1 3578  3 col 1 3578  
1623 0 0 6 1523 3575 0 0 0 3 4 this 3 3851  3 row 1 3578  3 col 1 3578  
1624 0 0 6 1524 3727 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3851  
1625 0 0 6 1525 3727 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3851  
1626 0 0 6 1526 3575 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3851  3 row 1 3578  3 col 1 3578  
1627 0 0 4 1527 3722 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3857  3 row 1 3578  3 col 1 3578  5 value 1 3575  
1628 0 0 4 1528 3722 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3851  
1629 0 0 6 1529 3578 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3851  
1630 0 0 4 1530 3722 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3857  
1631 0 0 4 1530 3722 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3851  
1632 0 0 4 1531 3722 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3857  
1633 0 0 4 1531 3722 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3851  
1634 0 0 6 1532 3727 0 0 0 2 4 this 3 3851  5 other 1 3851  
1635 0 0 6 1533 3727 0 0 0 2 4 this 3 3851  5 other 1 3851  
1636 0 0 6 1534 3727 0 0 0 2 4 this 3 3851  5 other 1 3851  
1637 0 0 6 1535 3578 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3851  5 other 1 3851  
1638 0 0 6 1535 3578 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3851  5 other 1 3851  9 threshold 1 3575  
1639 0 0 6 1536 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3851  
1640 0 0 6 1536 3720 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3851  9 threshold 1 3575  
1641 0 0 6 1537 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3851  4 hash 1 3720  
1642 0 0 6 1537 3720 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3851  4 hash 1 3720  9 threshold 1 3575  
1643 0 0 7 1538 3795 2839 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3851  1 v 1 3796  
1644 0 0 7 1539 3765 2438 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3851  1 v 1 3766  
1645 0 0 7 1540 3765 2438 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3851  1 v 1 3766  
1646 0 0 7 1541 3765 2438 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3851  1 v 1 3766  
1647 0 0 7 1542 3765 2438 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3851  1 v 1 3766  
1648 0 0 4 1543 3722 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3851  1 v 1 3795  
1649 0 0 4 1544 3722 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3851  1 v 1 3765  
1650 0 0 4 1545 3722 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3851  1 v 1 3765  
1651 0 0 4 1546 3722 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3851  1 v 1 3765  
1652 0 0 4 1547 3722 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3851  1 v 1 3765  
1653 0 0 4 1548 3722 0 0 25 // this = other1 * other2 3 4 this 3 3857  6 other1 1 3851  6 other2 1 3851  
1654 0 0 7 1549 3857 3426 0 0 2 4 this 3 3851  5 other 1 3851  
1655 0 0 7 1549 3857 3426 0 0 2 4 this 3 3851  6 scalar 1 3575  
1656 0 0 7 1550 3857 3426 0 0 2 4 this 3 3851  6 scalar 1 3575  
1657 0 0 6 1551 3857 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3857  5 other 1 3851  
1658 0 0 6 1552 3857 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3857  5 other 1 3851  
1659 0 0 6 1553 3857 0 0 10 /**
 *
 */ 2 4 this 3 3857  5 other 1 3851  
1660 0 0 6 1553 3857 0 0 10 /**
 *
 */ 2 4 this 3 3857  6 scalar 1 3575  
1661 0 0 6 1554 3857 0 0 10 /**
 *
 */ 2 4 this 3 3857  6 scalar 1 3575  
1662 0 0 4 1555 3722 0 0 10 /**
 *
 */ 2 4 this 3 3857  5 other 1 3851  
1663 0 0 4 1556 3722 0 0 10 /**
 *
 */ 2 4 this 3 3857  5 other 1 3851  
1664 0 0 4 1557 3722 0 0 10 /**
 *
 */ 1 4 this 3 3857  
1665 0 0 6 1558 3727 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3857  5 other 1 3851  
1666 0 0 6 1559 3727 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3857  5 other 1 3851  
1667 0 0 6 1560 3727 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3857  
1668 0 0 4 1561 3722 0 0 48 /**
 * Computes `(*this) += other * weight`.
 */ 3 4 this 3 3857  5 other 1 3851  6 weight 1 3575  
1669 0 0 6 1562 3851 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1670 0 0 6 1563 3851 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1671 0 0 6 1564 3851 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1672 0 0 4 1565 3722 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3857  5 trans 1 3766  
1673 0 0 4 1566 3722 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3857  5 angle 1 3575  4 axis 1 3766  2 cs 1 3591  
1674 0 0 4 1567 3722 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3857  5 angle 1 3575  4 axis 1 3766  2 cs 1 3591  
1675 0 0 4 1568 3722 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3857  5 scale 1 3766  
1676 0 0 4 1569 3722 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3857  5 shear 1 3766  2 cs 1 3591  
1677 0 0 4 1570 3722 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3857  5 scale 1 3766  5 shear 1 3766  2 cs 1 3591  
1678 0 0 7 1571 3857 3426 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3766  
1679 0 0 7 1571 3857 3426 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3575  2 ty 1 3575  2 tz 1 3575  
1680 0 0 7 1572 3857 3426 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3575  4 axis 1 3766  2 cs 1 3591  
1681 0 0 7 1573 3857 3426 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3575  4 axis 1 3766  2 cs 1 3591  
1682 0 0 7 1574 3857 3426 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3766  
1683 0 0 7 1574 3857 3426 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3575  
1684 0 0 7 1574 3857 3426 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3575  2 sy 1 3575  2 sz 1 3575  
1685 0 0 7 1575 3857 3426 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3766  2 cs 1 3591  
1686 0 0 7 1575 3857 3426 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3575  4 shxz 1 3575  4 shyz 1 3575  2 cs 1 3591  
1687 0 0 7 1576 3857 3426 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3766  5 shear 1 3766  2 cs 1 3591  
1688 0 0 7 1576 3857 3426 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3575  2 sy 1 3575  2 sz 1 3575  4 shxy 1 3575  4 shxz 1 3575  4 shyz 1 3575  2 cs 1 3591  
1689 0 0 6 1577 3851 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1690 0 0 6 1578 3851 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1691 0 0 6 1579 3851 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3591  2 to 1 3591  
1692 0 0 6 1580 3727 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3851  5 other 1 3851  
1693 0 0 6 1580 3727 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3851  5 other 1 3851  9 threshold 1 3575  
1694 0 0 4 1581 3722 0 0 10 /**
 *
 */ 2 4 this 3 3851  3 out 1 3730  
1695 0 0 4 1582 3722 0 0 10 /**
 *
 */ 3 4 this 3 3851  3 out 1 3730  12 indent_level 1 3578  
1696 0 0 6 1583 3726 0 0 0 1 4 this 3 3851  
1697 0 0 4 1584 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3851  7 hashgen 1 3728  
1698 0 0 4 1584 3722 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3851  7 hashgen 1 3728  5 scale 1 3575  
1699 0 0 4 1585 3722 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3851  11 destination 1 3732  
1700 0 0 4 1586 3722 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3857  4 scan 1 3734  
1701 0 0 4 1587 3722 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3851  11 destination 1 3732  
1702 0 0 4 1588 3722 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3857  6 source 1 3734  
1703 0 0 7 1589 3737 0 0 0 0 
1704 0 0 7 1492 3860 3335 0 0 1 6 param0 0 3862  
1705 0 0 4 1489 3722 0 0 10 /**
 *
 */ 3 4 this 3 3860  1 i 1 3578  10 assign_val 1 3575  
1706 0 0 6 1489 3575 0 0 0 2 4 this 3 3862  1 i 1 3578  
1707 0 0 6 1490 3578 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1708 0 0 6 1491 3796 0 0 0 1 4 this 3 3862  
1709 0 0 7 1498 3861 3340 0 0 1 6 param0 0 3864  
1710 0 0 6 1495 3575 0 0 0 2 4 this 3 3864  1 i 1 3578  
1711 0 0 6 1496 3578 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1712 0 0 6 1497 3796 0 0 0 1 4 this 3 3864  
1713 0 0 7 1593 3866 3436 0 0 0 
1714 0 0 7 1593 3866 3436 0 10 /**
 *
 */ 1 4 copy 1 3851  
1715 0 0 7 1593 3866 3436 0 0 1 4 copy 1 3858  
1716 0 0 7 1593 3866 3436 0 10 /**
 *
 */ 16 3 e00 1 3575  3 e01 1 3575  3 e02 1 3575  3 e03 1 3575  3 e10 1 3575  3 e11 1 3575  3 e12 1 3575  3 e13 1 3575  3 e20 1 3575  3 e21 1 3575  3 e22 1 3575  3 e23 1 3575  3 e30 1 3575  3 e31 1 3575  3 e32 1 3575  3 e33 1 3575  
1717 0 0 6 1594 3866 0 0 10 /**
 *
 */ 2 4 this 3 3866  4 copy 1 3851  
1718 0 0 6 1594 3866 0 0 0 2 4 this 3 3866  4 copy 1 3858  
1719 0 0 4 1595 3722 0 0 10 /**
 *
 */ 17 4 this 3 3866  3 e00 1 3575  3 e01 1 3575  3 e02 1 3575  3 e03 1 3575  3 e10 1 3575  3 e11 1 3575  3 e12 1 3575  3 e13 1 3575  3 e20 1 3575  3 e21 1 3575  3 e22 1 3575  3 e23 1 3575  3 e30 1 3575  3 e31 1 3575  3 e32 1 3575  3 e33 1 3575  
1720 0 0 4 1596 3722 0 0 10 /**
 *
 */ 3 4 this 3 3866  3 row 1 3578  3 col 1 3578  
1721 0 0 6 1596 3575 0 0 0 3 4 this 3 3858  3 row 1 3578  3 col 1 3578  
1722 0 0 4 1597 3722 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3858  
1723 0 0 6 1598 3578 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3858  
1724 0 0 6 1599 3727 0 0 0 2 4 this 3 3858  5 other 1 3858  
1725 0 0 6 1600 3727 0 0 0 2 4 this 3 3858  5 other 1 3858  
1726 0 0 7 1601 3737 0 0 0 0 
1727 0 0 7 1612 3867 3493 0 10 /**
 *
 */ 0 
1728 0 0 7 1612 3867 3493 0 0 1 6 param0 0 3868  
1729 0 0 7 1612 3867 3493 0 10 /**
 *
 */ 1 4 copy 1 3790  
1730 0 0 7 1612 3867 3493 0 10 /**
 *
 */ 2 1 r 1 3572  4 copy 1 3763  
1731 0 0 7 1612 3867 3493 0 10 /**
 *
 */ 4 1 r 1 3572  1 i 1 3572  1 j 1 3572  1 k 1 3572  
1732 0 0 7 1613 3867 3493 0 10 /**
 *
 */ 1 1 v 1 3772  
1733 0 0 7 1614 3867 3493 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3868  
1734 0 0 7 1615 3762 2362 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3868  1 v 1 3763  
1735 0 0 7 1615 3789 2751 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3868  1 v 1 3790  
1736 0 0 7 1616 3867 3493 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3868  3 rhs 1 3868  
1737 0 0 7 1617 3867 3493 0 0 1 4 this 3 3868  
1738 0 0 7 1618 3867 3493 0 0 2 4 this 3 3868  5 other 1 3868  
1739 0 0 7 1619 3867 3493 0 0 2 4 this 3 3868  5 other 1 3868  
1740 0 0 6 1620 3572 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3868  5 other 1 3868  
1741 0 0 6 1621 3572 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3868  5 other 1 3868  
1742 0 0 7 1622 3825 3136 0 0 2 4 this 3 3867  6 param0 0 3826  
1743 0 0 7 1622 3836 3234 0 0 2 4 this 3 3867  6 param0 0 3830  
1744 0 0 7 1622 3867 3493 0 0 2 4 this 3 3868  6 param0 0 3868  
1745 0 0 7 1622 3867 3493 0 0 2 4 this 3 3868  6 scalar 1 3572  
1746 0 0 7 1623 3867 3493 0 0 2 4 this 3 3868  6 scalar 1 3572  
1747 0 0 6 1624 3867 0 0 10 /**
 *
 */ 2 4 this 3 3867  6 param0 0 3868  
1748 0 0 7 1625 3867 3493 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3868  6 param0 0 3572  
1749 0 0 6 1626 3727 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3868  5 other 1 3868  
1750 0 0 6 1626 3727 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3868  5 other 1 3868  9 threshold 1 3572  
1751 0 0 6 1627 3727 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3868  5 other 1 3868  
1752 0 0 6 1628 3727 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3868  5 other 1 3868  9 threshold 1 3572  
1753 0 0 4 1629 3722 0 0 10 /**
 *
 */ 2 4 this 3 3868  6 param0 0 3730  
1754 0 0 4 1630 3722 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3868  1 m 1 3825  
1755 0 0 4 1630 3722 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3868  1 m 1 3836  
1756 0 0 4 1631 3722 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3867  1 m 1 3826  
1757 0 0 4 1631 3722 0 0 10 /**
 *
 */ 2 4 this 3 3867  1 m 1 3830  
1758 0 0 4 1632 3722 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3867  3 hpr 1 3763  2 cs 1 3591  
1759 0 0 7 1633 3762 2362 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3868  2 cs 1 3591  
1760 0 0 7 1634 3771 2547 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3868  
1761 0 0 7 1635 3771 2547 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3868  
1762 0 0 6 1636 3572 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3868  
1763 0 0 6 1637 3572 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3868  
1764 0 0 4 1638 3722 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3867  9 angle_rad 1 3572  4 axis 1 3772  
1765 0 0 4 1639 3722 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3867  9 angle_deg 1 3572  4 axis 1 3772  
1766 0 0 7 1640 3771 2547 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3868  2 cs 1 3591  
1767 0 0 7 1641 3771 2547 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3868  2 cs 1 3591  
1768 0 0 7 1642 3771 2547 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3868  2 cs 1 3591  
1769 0 0 6 1643 3572 0 0 10 /**
 *
 */ 1 4 this 3 3868  
1770 0 0 6 1644 3572 0 0 10 /**
 *
 */ 1 4 this 3 3868  
1771 0 0 6 1645 3572 0 0 10 /**
 *
 */ 1 4 this 3 3868  
1772 0 0 6 1646 3572 0 0 10 /**
 *
 */ 1 4 this 3 3868  
1773 0 0 4 1647 3722 0 0 10 /**
 *
 */ 2 4 this 3 3867  1 r 1 3572  
1774 0 0 4 1648 3722 0 0 10 /**
 *
 */ 2 4 this 3 3867  1 i 1 3572  
1775 0 0 4 1649 3722 0 0 10 /**
 *
 */ 2 4 this 3 3867  1 j 1 3572  
1776 0 0 4 1650 3722 0 0 10 /**
 *
 */ 2 4 this 3 3867  1 k 1 3572  
1777 0 0 6 1651 3727 0 0 10 /**
 *
 */ 1 4 this 3 3867  
1778 0 0 6 1652 3727 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3867  5 other 1 3868  
1779 0 0 6 1653 3727 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3867  
1780 0 0 6 1654 3727 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3867  5 other 1 3868  
1781 0 0 6 1655 3727 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3867  
1782 0 0 6 1656 3727 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3868  
1783 0 0 6 1657 3727 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3868  9 tolerance 1 3572  
1784 0 0 6 1658 3868 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1785 0 0 7 1659 3737 0 0 0 0 
1786 0 0 7 1662 3870 3542 0 10 /**
 *
 */ 0 
1787 0 0 7 1662 3870 3542 0 0 1 6 param0 0 3871  
1788 0 0 7 1662 3870 3542 0 10 /**
 *
 */ 1 4 copy 1 3796  
1789 0 0 7 1662 3870 3542 0 10 /**
 *
 */ 2 1 r 1 3575  4 copy 1 3766  
1790 0 0 7 1662 3870 3542 0 10 /**
 *
 */ 4 1 r 1 3575  1 i 1 3575  1 j 1 3575  1 k 1 3575  
1791 0 0 7 1663 3870 3542 0 10 /**
 *
 */ 1 1 v 1 3775  
1792 0 0 7 1664 3870 3542 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3871  
1793 0 0 7 1665 3765 2438 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3871  1 v 1 3766  
1794 0 0 7 1665 3795 2839 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3871  1 v 1 3796  
1795 0 0 7 1666 3870 3542 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3871  3 rhs 1 3871  
1796 0 0 7 1667 3870 3542 0 0 1 4 this 3 3871  
1797 0 0 7 1668 3870 3542 0 0 2 4 this 3 3871  5 other 1 3871  
1798 0 0 7 1669 3870 3542 0 0 2 4 this 3 3871  5 other 1 3871  
1799 0 0 6 1670 3575 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3871  5 other 1 3871  
1800 0 0 6 1671 3575 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3871  5 other 1 3871  
1801 0 0 7 1672 3846 3330 0 0 2 4 this 3 3870  6 param0 0 3847  
1802 0 0 7 1672 3857 3426 0 0 2 4 this 3 3870  6 param0 0 3851  
1803 0 0 7 1672 3870 3542 0 0 2 4 this 3 3871  6 param0 0 3871  
1804 0 0 7 1672 3870 3542 0 0 2 4 this 3 3871  6 scalar 1 3575  
1805 0 0 7 1673 3870 3542 0 0 2 4 this 3 3871  6 scalar 1 3575  
1806 0 0 6 1674 3870 0 0 10 /**
 *
 */ 2 4 this 3 3870  6 param0 0 3871  
1807 0 0 7 1675 3870 3542 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3871  6 param0 0 3575  
1808 0 0 6 1676 3727 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3871  5 other 1 3871  
1809 0 0 6 1676 3727 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3871  5 other 1 3871  9 threshold 1 3575  
1810 0 0 6 1677 3727 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3871  5 other 1 3871  
1811 0 0 6 1678 3727 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3871  5 other 1 3871  9 threshold 1 3575  
1812 0 0 4 1679 3722 0 0 10 /**
 *
 */ 2 4 this 3 3871  6 param0 0 3730  
1813 0 0 4 1680 3722 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3871  1 m 1 3846  
1814 0 0 4 1680 3722 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3871  1 m 1 3857  
1815 0 0 4 1681 3722 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3870  1 m 1 3847  
1816 0 0 4 1681 3722 0 0 10 /**
 *
 */ 2 4 this 3 3870  1 m 1 3851  
1817 0 0 4 1682 3722 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3870  3 hpr 1 3766  2 cs 1 3591  
1818 0 0 7 1683 3765 2438 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3871  2 cs 1 3591  
1819 0 0 7 1684 3774 2581 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3871  
1820 0 0 7 1685 3774 2581 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3871  
1821 0 0 6 1686 3575 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3871  
1822 0 0 6 1687 3575 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3871  
1823 0 0 4 1688 3722 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3870  9 angle_rad 1 3575  4 axis 1 3775  
1824 0 0 4 1689 3722 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3870  9 angle_deg 1 3575  4 axis 1 3775  
1825 0 0 7 1690 3774 2581 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3871  2 cs 1 3591  
1826 0 0 7 1691 3774 2581 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3871  2 cs 1 3591  
1827 0 0 7 1692 3774 2581 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3871  2 cs 1 3591  
1828 0 0 6 1693 3575 0 0 10 /**
 *
 */ 1 4 this 3 3871  
1829 0 0 6 1694 3575 0 0 10 /**
 *
 */ 1 4 this 3 3871  
1830 0 0 6 1695 3575 0 0 10 /**
 *
 */ 1 4 this 3 3871  
1831 0 0 6 1696 3575 0 0 10 /**
 *
 */ 1 4 this 3 3871  
1832 0 0 4 1697 3722 0 0 10 /**
 *
 */ 2 4 this 3 3870  1 r 1 3575  
1833 0 0 4 1698 3722 0 0 10 /**
 *
 */ 2 4 this 3 3870  1 i 1 3575  
1834 0 0 4 1699 3722 0 0 10 /**
 *
 */ 2 4 this 3 3870  1 j 1 3575  
1835 0 0 4 1700 3722 0 0 10 /**
 *
 */ 2 4 this 3 3870  1 k 1 3575  
1836 0 0 6 1701 3727 0 0 10 /**
 *
 */ 1 4 this 3 3870  
1837 0 0 6 1702 3727 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3870  5 other 1 3871  
1838 0 0 6 1703 3727 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3870  
1839 0 0 6 1704 3727 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3870  5 other 1 3871  
1840 0 0 6 1705 3727 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3870  
1841 0 0 6 1706 3727 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3871  
1842 0 0 6 1707 3727 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3871  9 tolerance 1 3575  
1843 0 0 6 1708 3871 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1844 0 0 7 1709 3737 0 0 0 0 
1845 0 0 7 1712 3873 3547 0 10 /**
 *
 */ 0 
1846 0 0 7 1712 3873 3547 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3826  
1847 0 0 7 1712 3873 3547 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3830  
1848 0 0 7 1712 3873 3547 0 10 /**
 *
 */ 1 1 c 1 3868  
1849 0 0 7 1712 3873 3547 0 0 1 6 param0 0 3874  
1850 0 0 7 1712 3873 3547 0 10 /**
 *
 */ 1 4 copy 1 3790  
1851 0 0 7 1712 3873 3547 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3772  5 angle 1 3572  
1852 0 0 7 1712 3873 3547 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3572  1 p 1 3572  1 r 1 3572  
1853 0 0 7 1712 3873 3547 0 10 /**
 *
 */ 4 1 r 1 3572  1 i 1 3572  1 j 1 3572  1 k 1 3572  
1854 0 0 7 1713 3867 3493 0 0 2 4 this 3 3874  5 other 1 3868  
1855 0 0 7 1713 3873 3547 0 0 2 4 this 3 3874  5 other 1 3874  
1856 0 0 7 1713 3873 3547 0 0 2 4 this 3 3874  6 scalar 1 3572  
1857 0 0 7 1714 3873 3547 0 0 2 4 this 3 3874  6 scalar 1 3572  
1858 0 0 7 1715 3737 0 0 0 0 
1859 0 0 7 1718 3876 3552 0 10 /**
 *
 */ 0 
1860 0 0 7 1718 3876 3552 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3847  
1861 0 0 7 1718 3876 3552 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3851  
1862 0 0 7 1718 3876 3552 0 10 /**
 *
 */ 1 1 c 1 3871  
1863 0 0 7 1718 3876 3552 0 0 1 6 param0 0 3877  
1864 0 0 7 1718 3876 3552 0 10 /**
 *
 */ 1 4 copy 1 3796  
1865 0 0 7 1718 3876 3552 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3775  5 angle 1 3575  
1866 0 0 7 1718 3876 3552 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3575  1 p 1 3575  1 r 1 3575  
1867 0 0 7 1718 3876 3552 0 10 /**
 *
 */ 4 1 r 1 3575  1 i 1 3575  1 j 1 3575  1 k 1 3575  
1868 0 0 7 1719 3870 3542 0 0 2 4 this 3 3877  5 other 1 3871  
1869 0 0 7 1719 3876 3552 0 0 2 4 this 3 3877  5 other 1 3877  
1870 0 0 7 1719 3876 3552 0 0 2 4 this 3 3877  6 scalar 1 3575  
1871 0 0 7 1720 3876 3552 0 0 2 4 this 3 3877  6 scalar 1 3575  
1872 0 0 7 1721 3737 0 0 0 0 
1873 0 0 7 1724 3879 3556 0 10 /**
 *
 */ 0 
1874 0 0 7 1724 3879 3556 0 18 /**
 * matrix3
 */ 1 1 m 1 3826  
1875 0 0 7 1724 3879 3556 0 18 /**
 * matrix4
 */ 1 1 m 1 3830  
1876 0 0 7 1724 3879 3556 0 0 1 6 param0 0 3880  
1877 0 0 7 1724 3879 3556 0 10 /**
 *
 */ 1 1 c 1 3868  
1878 0 0 7 1724 3879 3556 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3772  5 twist 1 3572  
1879 0 0 7 1724 3879 3556 0 10 /**
 *
 */ 4 1 r 1 3572  1 i 1 3572  1 j 1 3572  1 k 1 3572  
1880 0 0 7 1725 3879 3556 0 0 2 4 this 3 3880  5 other 1 3868  
1881 0 0 7 1725 3879 3556 0 0 2 4 this 3 3880  5 other 1 3874  
1882 0 0 7 1726 3737 0 0 0 0 
1883 0 0 7 1729 3882 3560 0 10 /**
 *
 */ 0 
1884 0 0 7 1729 3882 3560 0 18 /**
 * matrix3
 */ 1 1 m 1 3847  
1885 0 0 7 1729 3882 3560 0 18 /**
 * matrix4
 */ 1 1 m 1 3851  
1886 0 0 7 1729 3882 3560 0 0 1 6 param0 0 3883  
1887 0 0 7 1729 3882 3560 0 10 /**
 *
 */ 1 1 c 1 3871  
1888 0 0 7 1729 3882 3560 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3775  5 twist 1 3575  
1889 0 0 7 1729 3882 3560 0 10 /**
 *
 */ 4 1 r 1 3575  1 i 1 3575  1 j 1 3575  1 k 1 3575  
1890 0 0 7 1730 3882 3560 0 0 2 4 this 3 3883  5 other 1 3871  
1891 0 0 7 1730 3882 3560 0 0 2 4 this 3 3883  5 other 1 3877  
1892 0 0 7 1731 3737 0 0 0 0 
1893 0 0 7 1805 3887 3568 0 0 1 6 param0 0 3885  
1894 0 0 7 1805 3887 3568 0 10 /**
 *
 */ 1 4 name 1 3726  
1895 0 0 7 1805 3887 3568 0 10 /**
 *
 */ 4 4 name 1 3726  13 default_value 1 3888  11 description 1 3726  5 flags 1 3578  
1896 0 0 7 1805 3887 3568 0 10 /**
 *
 */ 4 4 name 1 3726  13 default_value 1 3726  11 description 1 3726  5 flags 1 3578  
1897 0 0 6 1806 3887 0 0 0 2 4 this 3 3887  5 value 1 3888  
1898 0 0 6 1808 3890 0 0 0 2 4 this 3 3885  1 n 1 3578  
1899 0 0 4 1809 3722 0 0 48 /**
 * Reassigns the variable's local value.
 */ 2 4 this 3 3887  5 value 1 3888  
1900 0 0 6 1810 3888 0 0 40 /**
 * Returns the variable's value.
 */ 1 4 this 3 3885  
1901 0 0 7 1811 3891 0 0 48 /**
 * Returns the variable's default value.
 */ 1 4 this 3 3885  
1902 0 0 6 1807 3888 0 0 0 1 4 this 3 3885  
1903 0 0 6 4 3575 0 0 0 1 1 f 1 3575  
1904 0 0 6 4 3572 0 0 0 1 1 f 1 3572  
1905 0 0 6 5 3575 0 0 0 1 1 f 1 3575  
1906 0 0 6 5 3572 0 0 0 1 1 f 1 3572  
1907 0 0 6 565 3591 0 0 0 0 
1908 0 0 6 566 3591 0 0 0 1 3 str 1 3726  
1909 0 0 6 567 3726 0 0 0 1 2 cs 1 3591  
1910 0 0 6 568 3727 0 0 0 1 2 cs 1 3591  
1911 0 0 7 1271 3846 3330 0 0 1 1 a 1 3847  
1912 0 0 7 1271 3825 3136 0 0 1 1 a 1 3826  
1913 0 0 7 1271 3857 3426 0 0 1 1 a 1 3851  
1914 0 0 7 1271 3836 3234 0 0 1 1 a 1 3830  
1915 0 0 7 1272 3846 3330 0 0 1 1 a 1 3847  
1916 0 0 7 1272 3825 3136 0 0 1 1 a 1 3826  
1917 0 0 7 1272 3857 3426 0 0 1 1 a 1 3851  
1918 0 0 7 1272 3836 3234 0 0 1 1 a 1 3830  
1919 0 0 7 1272 3870 3542 0 0 1 1 a 1 3871  
1920 0 0 7 1272 3867 3493 0 0 1 1 a 1 3868  
1921 0 0 7 1603 3846 3330 0 0 2 1 m 1 3847  1 q 1 3871  
1922 0 0 7 1603 3825 3136 0 0 2 1 m 1 3826  1 q 1 3868  
1923 0 0 7 1603 3857 3426 0 0 2 1 m 1 3851  1 q 1 3871  
1924 0 0 7 1603 3836 3234 0 0 2 1 m 1 3830  1 q 1 3868  
1925 0 0 7 1603 3756 2272 0 0 2 1 v 1 3757  1 m 1 3847  
1926 0 0 7 1603 3753 2256 0 0 2 1 v 1 3754  1 m 1 3826  
1927 0 0 7 1603 3783 2653 0 0 2 1 v 1 3784  1 m 1 3847  
1928 0 0 7 1603 3783 2653 0 0 2 1 v 1 3784  1 m 1 3851  
1929 0 0 7 1603 3780 2630 0 0 2 1 v 1 3781  1 m 1 3826  
1930 0 0 7 1603 3780 2630 0 0 2 1 v 1 3781  1 m 1 3830  
1931 0 0 7 1603 3819 3032 0 0 2 1 v 1 3820  1 m 1 3851  
1932 0 0 7 1603 3816 3012 0 0 2 1 v 1 3817  1 m 1 3830  
1933 0 0 7 1603 3765 2438 0 0 2 1 v 1 3766  1 m 1 3847  
1934 0 0 7 1603 3762 2362 0 0 2 1 v 1 3763  1 m 1 3826  
1935 0 0 7 1603 3795 2839 0 0 2 1 v 1 3796  1 m 1 3851  
1936 0 0 7 1603 3789 2751 0 0 2 1 v 1 3790  1 m 1 3830  
1937 0 0 7 1603 3747 2226 0 0 2 1 v 1 3748  1 m 1 3847  
1938 0 0 7 1603 3744 2208 0 0 2 1 v 1 3745  1 m 1 3826  
1939 0 0 7 1603 3774 2581 0 0 2 1 v 1 3775  1 m 1 3847  
1940 0 0 7 1603 3774 2581 0 0 2 1 v 1 3775  1 m 1 3851  
1941 0 0 7 1603 3771 2547 0 0 2 1 v 1 3772  1 m 1 3826  
1942 0 0 7 1603 3771 2547 0 0 2 1 v 1 3772  1 m 1 3830  
1943 0 0 7 1603 3810 2974 0 0 2 1 v 1 3811  1 m 1 3851  
1944 0 0 7 1603 3807 2954 0 0 2 1 v 1 3808  1 m 1 3830  
1945 0 0 4 1604 3722 0 0 0 2 1 v 1 3756  1 m 1 3847  
1946 0 0 4 1604 3722 0 0 0 2 1 v 1 3753  1 m 1 3826  
1947 0 0 4 1604 3722 0 0 0 2 1 v 1 3783  1 m 1 3847  
1948 0 0 4 1604 3722 0 0 0 2 1 v 1 3783  1 m 1 3851  
1949 0 0 4 1604 3722 0 0 0 2 1 v 1 3780  1 m 1 3826  
1950 0 0 4 1604 3722 0 0 0 2 1 v 1 3780  1 m 1 3830  
1951 0 0 4 1604 3722 0 0 0 2 1 v 1 3765  1 m 1 3847  
1952 0 0 4 1604 3722 0 0 0 2 1 v 1 3762  1 m 1 3826  
1953 0 0 4 1604 3722 0 0 0 2 1 v 1 3795  1 m 1 3851  
1954 0 0 4 1604 3722 0 0 0 2 1 v 1 3789  1 m 1 3830  
1955 0 0 4 1604 3722 0 0 0 2 1 v 1 3747  1 m 1 3847  
1956 0 0 4 1604 3722 0 0 0 2 1 v 1 3744  1 m 1 3826  
1957 0 0 4 1604 3722 0 0 0 2 1 v 1 3774  1 m 1 3847  
1958 0 0 4 1604 3722 0 0 0 2 1 v 1 3774  1 m 1 3851  
1959 0 0 4 1604 3722 0 0 0 2 1 v 1 3771  1 m 1 3826  
1960 0 0 4 1604 3722 0 0 0 2 1 v 1 3771  1 m 1 3830  
1961 0 0 4 1605 3722 0 0 0 2 4 dest 1 3732  5 value 1 3847  
1962 0 0 4 1605 3722 0 0 0 2 4 dest 1 3732  5 value 1 3826  
1963 0 0 4 1605 3722 0 0 0 2 4 dest 1 3732  5 value 1 3851  
1964 0 0 4 1605 3722 0 0 0 2 4 dest 1 3732  5 value 1 3830  
1965 0 0 4 1606 3722 0 0 0 2 6 result 1 3846  6 source 1 3734  
1966 0 0 4 1606 3722 0 0 0 2 6 result 1 3825  6 source 1 3734  
1967 0 0 4 1606 3722 0 0 0 2 6 result 1 3857  6 source 1 3734  
1968 0 0 4 1606 3722 0 0 0 2 6 result 1 3836  6 source 1 3734  
1969 0 0 4 1607 3722 0 0 0 4 3 mat 1 3846  5 scale 1 3766  3 hpr 1 3766  2 cs 1 3591  
1970 0 0 4 1607 3722 0 0 0 5 3 mat 1 3846  5 scale 1 3766  5 shear 1 3766  3 hpr 1 3766  2 cs 1 3591  
1971 0 0 4 1607 3722 0 0 0 4 3 mat 1 3825  5 scale 1 3763  3 hpr 1 3763  2 cs 1 3591  
1972 0 0 4 1607 3722 0 0 0 5 3 mat 1 3825  5 scale 1 3763  5 shear 1 3763  3 hpr 1 3763  2 cs 1 3591  
1973 0 0 4 1607 3722 0 0 0 5 3 mat 1 3857  5 scale 1 3766  3 hpr 1 3766  9 translate 1 3766  2 cs 1 3591  
1974 0 0 4 1607 3722 0 0 0 6 3 mat 1 3857  5 scale 1 3766  5 shear 1 3766  3 hpr 1 3766  9 translate 1 3766  2 cs 1 3591  
1975 0 0 4 1607 3722 0 0 0 3 3 mat 1 3857  10 components 1 3892  2 cs 1 3591  
1976 0 0 4 1607 3722 0 0 0 5 3 mat 1 3836  5 scale 1 3763  3 hpr 1 3763  9 translate 1 3763  2 cs 1 3591  
1977 0 0 4 1607 3722 0 0 0 6 3 mat 1 3836  5 scale 1 3763  5 shear 1 3763  3 hpr 1 3763  9 translate 1 3763  2 cs 1 3591  
1978 0 0 4 1607 3722 0 0 0 3 3 mat 1 3836  10 components 1 3894  2 cs 1 3591  
1979 0 0 6 1608 3727 0 0 0 4 3 mat 1 3847  5 scale 1 3765  3 hpr 1 3765  2 cs 1 3591  
1980 0 0 6 1608 3727 0 0 0 5 3 mat 1 3847  5 scale 1 3765  5 shear 1 3765  3 hpr 1 3765  2 cs 1 3591  
1981 0 0 6 1608 3727 0 0 0 4 3 mat 1 3826  5 scale 1 3762  3 hpr 1 3762  2 cs 1 3591  
1982 0 0 6 1608 3727 0 0 0 5 3 mat 1 3826  5 scale 1 3762  5 shear 1 3762  3 hpr 1 3762  2 cs 1 3591  
1983 0 0 6 1608 3727 0 0 0 5 3 mat 1 3851  5 scale 1 3765  3 hpr 1 3765  9 translate 1 3765  2 cs 1 3591  
1984 0 0 6 1608 3727 0 0 0 6 3 mat 1 3851  5 scale 1 3765  5 shear 1 3765  3 hpr 1 3765  9 translate 1 3765  2 cs 1 3591  
1985 0 0 6 1608 3727 0 0 0 3 3 mat 1 3851  10 components 1 3896  2 CS 1 3591  
1986 0 0 6 1608 3727 0 0 0 5 3 mat 1 3830  5 scale 1 3762  3 hpr 1 3762  9 translate 1 3762  2 cs 1 3591  
1987 0 0 6 1608 3727 0 0 0 6 3 mat 1 3830  5 scale 1 3762  5 shear 1 3762  3 hpr 1 3762  9 translate 1 3762  2 cs 1 3591  
1988 0 0 6 1608 3727 0 0 0 3 3 mat 1 3830  10 components 1 3897  2 CS 1 3591  
1989 0 0 6 1609 3727 0 0 0 5 3 mat 1 3847  5 scale 1 3765  5 shear 1 3765  3 hpr 1 3765  2 cs 1 3591  
1990 0 0 6 1609 3727 0 0 0 5 3 mat 1 3826  5 scale 1 3762  5 shear 1 3762  3 hpr 1 3762  2 cs 1 3591  
1991 0 0 7 1610 3765 2438 0 0 1 7 old_hpr 1 3766  
1992 0 0 7 1610 3762 2362 0 0 1 7 old_hpr 1 3763  
329
3569 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 1993 1994 0 0 0 0 0 0 0 0

3570 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 1997 2062 2 3898 3899 64 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 0 0 0 0 1 3571 75
/**
 * This is the base class for all two-component vectors and points.
 */

3571 0 0 794624 12 LVecBase2f:: 0 3570 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0
2 6 is_int 18 LVecBase2f::is_int 0
0 0 0

3572 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3573 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 2063 2128 2 3900 3901 64 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 0 0 0 0 1 3574 75
/**
 * This is the base class for all two-component vectors and points.
 */

3574 0 0 794624 12 LVecBase2d:: 0 3573 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0
2 6 is_int 18 LVecBase2d::is_int 0
0 0 0

3575 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3576 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2129 2190 2 3902 3903 60 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 0 0 0 0 1 3577 75
/**
 * This is the base class for all two-component vectors and points.
 */

3577 0 0 794624 12 LVecBase2i:: 0 3576 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0
2 6 is_int 18 LVecBase2i::is_int 0
1 0 0

3578 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3579 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2191 2208 0 16 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 0 0 1 0 3570 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3580 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2209 2226 0 16 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 0 0 1 0 3573 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3581 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2227 2240 0 12 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 0 0 1 0 3576 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3582 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2241 2256 0 14 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 0 0 1 0 3570 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3583 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2257 2272 0 14 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 0 0 1 0 3573 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3584 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2273 2286 0 12 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 0 0 1 0 3576 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3585 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2287 2362 6 3904 3905 3906 3907 3908 3909 74 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 0 0 0 0 1 3586 77
/**
 * This is the base class for all three-component vectors and points.
 */

3586 0 0 794624 12 LVecBase3f:: 0 3585 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0
3 6 is_int 18 LVecBase3f::is_int 0
0 0 0

3587 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2363 2438 6 3910 3911 3912 3913 3914 3915 74 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 0 0 0 0 1 3588 77
/**
 * This is the base class for all three-component vectors and points.
 */

3588 0 0 794624 12 LVecBase3d:: 0 3587 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0
3 6 is_int 18 LVecBase3d::is_int 0
0 0 0

3589 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2439 2509 6 3916 3917 3918 3919 3920 3921 69 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 0 0 0 0 1 3590 77
/**
 * This is the base class for all three-component vectors and points.
 */

3590 0 0 794624 12 LVecBase3i:: 0 3589 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0
3 6 is_int 18 LVecBase3i::is_int 0
1 0 0

3591 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 21
// Z-Up, Right-handed
1 12 CS_yup_right 12 CS_yup_right 21
// Y-Up, Right-handed
2 11 CS_zup_left 11 CS_zup_left 20
// Z-Up, Left-handed
3 11 CS_yup_left 11 CS_yup_left 20
// Y-Up, Left-handed
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

3592 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2514 2547 3 3922 3923 3924 32 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 0 0 1 0 3585 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3593 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2548 2581 3 3925 3926 3927 32 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 0 0 1 0 3587 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3594 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2582 2607 3 3928 3929 3930 24 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 0 0 1 0 3589 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3595 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2608 2630 3 3931 3932 3933 21 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 0 0 1 0 3585 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3596 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2631 2653 3 3934 3935 3936 21 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 0 0 1 0 3587 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3597 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2654 2674 3 3937 3938 3939 19 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 0 0 1 0 3589 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3598 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2675 2751 5 3940 3941 3942 3943 3944 75 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 0 0 0 0 1 3599 77
/**
 * This is the base class for all three-component vectors and points.
 */

3599 0 0 794624 12 LVecBase4f:: 0 3598 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0
4 6 is_int 18 LVecBase4f::is_int 0
0 0 0

3600 19 UnalignedLVecBase4f 0 141313 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 0 1 2752 2762 0 9 2753 2754 2755 2756 2757 2758 2759 2760 2761 0 0 0 0 1 3601 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3601 0 0 794624 21 UnalignedLVecBase4f:: 0 3600 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4f::num_components 0
4 6 is_int 27 UnalignedLVecBase4f::is_int 0
0 0 0

3602 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2763 2839 5 3945 3946 3947 3948 3949 75 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 0 0 0 0 1 3603 77
/**
 * This is the base class for all three-component vectors and points.
 */

3603 0 0 794624 12 LVecBase4d:: 0 3602 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0
4 6 is_int 18 LVecBase4d::is_int 0
0 0 0

3604 19 UnalignedLVecBase4d 0 141313 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 0 1 2840 2850 0 9 2841 2842 2843 2844 2845 2846 2847 2848 2849 0 0 0 0 1 3605 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3605 0 0 794624 21 UnalignedLVecBase4d:: 0 3604 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4d::num_components 0
4 6 is_int 27 UnalignedLVecBase4d::is_int 0
0 0 0

3606 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2851 2923 5 3950 3951 3952 3953 3954 71 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 0 0 0 0 1 3607 77
/**
 * This is the base class for all three-component vectors and points.
 */

3607 0 0 794624 12 LVecBase4i:: 0 3606 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0
4 6 is_int 18 LVecBase4i::is_int 0
1 0 0

3608 19 UnalignedLVecBase4i 0 141313 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 0 1 2924 2934 0 9 2925 2926 2927 2928 2929 2930 2931 2932 2933 0 0 0 0 1 3609 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3609 0 0 794624 21 UnalignedLVecBase4i:: 0 3608 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4i::num_components 0
4 6 is_int 27 UnalignedLVecBase4i::is_int 0
1 0 0

3610 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 2935 2954 2 3955 3956 18 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 0 0 1 0 3598 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3611 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 2955 2974 2 3957 3958 18 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 0 0 1 0 3602 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3612 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 2975 2992 2 3959 3960 16 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 0 0 1 0 3606 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3613 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 2993 3012 2 3961 3962 18 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 0 0 1 0 3598 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3614 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 3013 3032 2 3963 3964 18 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 0 0 1 0 3602 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3615 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 3033 3050 2 3965 3966 16 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 0 0 1 0 3606 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3616 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 3061 3136 2 3967 3968 74 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 4 3975 3976 3977 3978 0 0 0 3 3617 3618 3619 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3617 0 0 794624 11 LMatrix3f:: 0 3616 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0
9 6 is_int 17 LMatrix3f::is_int 0
0 0 0

3618 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3616 0 0 1 3054 3055 0 2 3051 3052 0 1 3053 0 0 0 66
// These helper classes are used to support two-level operator [].

3619 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3616 0 0 1 3059 3060 0 2 3056 3057 0 1 3058 0 0 0 0

3620 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3149 3234 2 3969 3970 84 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3 3979 3980 3981 0 0 0 3 3621 3622 3623 45
/**
 * This is a 4-by-4 transform matrix.
 */

3621 0 0 794624 11 LMatrix4f:: 0 3620 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0
16 6 is_int 17 LMatrix4f::is_int 0
0 0 0

3622 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3620 0 0 1 3142 3143 0 2 3139 3140 0 1 3141 0 0 0 66
// These helper classes are used to support two-level operator [].

3623 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3620 0 0 1 3147 3148 0 2 3144 3145 0 1 3146 0 0 0 0

3624 18 UnalignedLMatrix4f 0 141313 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 0 1 3235 3244 0 8 3236 3237 3238 3239 3240 3241 3242 3243 0 0 0 0 1 3625 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3625 0 0 794624 20 UnalignedLMatrix4f:: 0 3624 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4f::num_components 0
16 0 0

3626 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3255 3330 2 3971 3972 74 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 4 3982 3983 3984 3985 0 0 0 3 3627 3628 3629 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3627 0 0 794624 11 LMatrix3d:: 0 3626 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0
9 6 is_int 17 LMatrix3d::is_int 0
0 0 0

3628 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3626 0 0 1 3248 3249 0 2 3245 3246 0 1 3247 0 0 0 66
// These helper classes are used to support two-level operator [].

3629 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3626 0 0 1 3253 3254 0 2 3250 3251 0 1 3252 0 0 0 0

3630 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3341 3426 2 3973 3974 84 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3 3986 3987 3988 0 0 0 3 3631 3632 3633 45
/**
 * This is a 4-by-4 transform matrix.
 */

3631 0 0 794624 11 LMatrix4d:: 0 3630 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0
16 6 is_int 17 LMatrix4d::is_int 0
0 0 0

3632 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3630 0 0 1 3334 3335 0 2 3331 3332 0 1 3333 0 0 0 66
// These helper classes are used to support two-level operator [].

3633 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3630 0 0 1 3339 3340 0 2 3336 3337 0 1 3338 0 0 0 0

3634 18 UnalignedLMatrix4d 0 141313 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 0 1 3427 3436 0 8 3428 3429 3430 3431 3432 3433 3434 3435 0 0 0 0 1 3635 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3635 0 0 794624 20 UnalignedLMatrix4d:: 0 3634 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4d::num_components 0
16 0 0

3636 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3445 3493 0 47 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 0 0 1 0 3598 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3637 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3494 3542 0 47 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 0 0 1 0 3602 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3638 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3543 3547 0 3 3544 3545 3546 0 0 1 0 3636 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3639 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3548 3552 0 3 3549 3550 3551 0 0 1 0 3637 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3640 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3553 3556 0 2 3554 3555 0 0 1 0 3636 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3641 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3557 3560 0 2 3558 3559 0 0 1 0 3637 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3642 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3595 0 0 0 0 0 0 0 0 0 0

3643 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3592 0 0 0 0 0 0 0 0 0 0

3644 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3582 0 0 0 0 0 0 0 0 0 0

3645 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3595 0 0 0 0 0 0 0 0 0 0

3646 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3598 0 0 0 0 0 0 0 0 0 0

3647 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3585 0 0 0 0 0 0 0 0 0 0

3648 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3596 0 0 0 0 0 0 0 0 0 0

3649 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3593 0 0 0 0 0 0 0 0 0 0

3650 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3583 0 0 0 0 0 0 0 0 0 0

3651 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3596 0 0 0 0 0 0 0 0 0 0

3652 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3602 0 0 0 0 0 0 0 0 0 0

3653 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3587 0 0 0 0 0 0 0 0 0 0

3654 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3620 0 0 0 0 0 0 0 0 0 0

3655 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3616 0 0 0 0 0 0 0 0 0 0

3656 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3598 0 0 0 0 0 0 0 0 0 0

3657 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3610 0 0 0 0 0 0 0 0 0 0

3658 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3613 0 0 0 0 0 0 0 0 0 0

3659 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3585 0 0 0 0 0 0 0 0 0 0

3660 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3592 0 0 0 0 0 0 0 0 0 0

3661 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3595 0 0 0 0 0 0 0 0 0 0

3662 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3570 0 0 0 0 0 0 0 0 0 0

3663 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3579 0 0 0 0 0 0 0 0 0 0

3664 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3582 0 0 0 0 0 0 0 0 0 0

3665 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3636 0 0 0 0 0 0 0 0 0 0

3666 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3630 0 0 0 0 0 0 0 0 0 0

3667 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3626 0 0 0 0 0 0 0 0 0 0

3668 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3602 0 0 0 0 0 0 0 0 0 0

3669 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3611 0 0 0 0 0 0 0 0 0 0

3670 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3614 0 0 0 0 0 0 0 0 0 0

3671 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3587 0 0 0 0 0 0 0 0 0 0

3672 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3593 0 0 0 0 0 0 0 0 0 0

3673 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3596 0 0 0 0 0 0 0 0 0 0

3674 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3573 0 0 0 0 0 0 0 0 0 0

3675 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3580 0 0 0 0 0 0 0 0 0 0

3676 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3583 0 0 0 0 0 0 0 0 0 0

3677 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3637 0 0 0 0 0 0 0 0 0 0

3678 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3570 0 0 0 0 0 0 0 0 0 0

3679 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3582 0 0 0 0 0 0 0 0 0 0

3680 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3579 0 0 0 0 0 0 0 0 0 0

3681 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3585 0 0 0 0 0 0 0 0 0 0

3682 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3595 0 0 0 0 0 0 0 0 0 0

3683 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3592 0 0 0 0 0 0 0 0 0 0

3684 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3598 0 0 0 0 0 0 0 0 0 0

3685 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3613 0 0 0 0 0 0 0 0 0 0

3686 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3610 0 0 0 0 0 0 0 0 0 0

3687 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3636 0 0 0 0 0 0 0 0 0 0

3688 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3638 0 0 0 0 0 0 0 0 0 0

3689 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3640 0 0 0 0 0 0 0 0 0 0

3690 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3616 0 0 0 0 0 0 0 0 0 0

3691 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3620 0 0 0 0 0 0 0 0 0 0

3692 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3642 0 0 0 0 0 0 0 0 0 0

3693 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3643 0 0 0 0 0 0 0 0 0 0

3694 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3644 0 0 0 0 0 0 0 0 0 0

3695 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3645 0 0 0 0 0 0 0 0 0 0

3696 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3646 0 0 0 0 0 0 0 0 0 0

3697 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3647 0 0 0 0 0 0 0 0 0 0

3698 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3600 0 0 0 0 0 0 0 0 0 0

3699 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3624 0 0 0 0 0 0 0 0 0 0

3700 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3620 0 0 0 0 0 0 0 0 0 0

3701 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3616 0 0 0 0 0 0 0 0 0 0

3702 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3598 0 0 0 0 0 0 0 0 0 0

3703 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3610 0 0 0 0 0 0 0 0 0 0

3704 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3613 0 0 0 0 0 0 0 0 0 0

3705 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3585 0 0 0 0 0 0 0 0 0 0

3706 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3592 0 0 0 0 0 0 0 0 0 0

3707 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3595 0 0 0 0 0 0 0 0 0 0

3708 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3570 0 0 0 0 0 0 0 0 0 0

3709 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3579 0 0 0 0 0 0 0 0 0 0

3710 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3582 0 0 0 0 0 0 0 0 0 0

3711 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3636 0 0 0 0 0 0 0 0 0 0

3712 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3561 3568 0 5 3562 3564 3565 3566 3567 0 1 3563 1 0 3713 0 0 0 0 538
/**
 * This is a convenience class to specialize ConfigVariable as a set of
 * floating-point types representing a color value.
 *
 * It interprets the color differently depending on how many words were
 * specified: if only one, it is interpreted as a shade of gray with alpha 1.
 * If two values were specified, a grayscale and alpha pair.  If three, a set
 * of R, G, B values with alpha 1, and if four, a complete RGBA color.
 *
 * This isn't defined in dtool because it relies on the LColor class, which is
 * defined in linmath.
 */

3713 14 ConfigVariable 0 2048 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415
/**
 * This is a generic, untyped ConfigVariable.  It is also the base class for
 * the typed ConfigVariables, and contains all of the code common to
 * ConfigVariables of all types (except ConfigVariableList, which is a bit of
 * a special case).
 *
 * Mostly, this class serves as a thin wrapper around ConfigVariableCore
 * and/or ConfigDeclaration, more or less duplicating the interface presented
 * there.
 */

3714 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3569 0 0 0 0 0 0 0 0 0 0

3715 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3716 0 0 0 0 0 0 0 0 0 0

3716 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3569 0 0 0 0 0 0 0 0 0 0

3717 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3570 0 0 0 0 0 0 0 0 0 0

3718 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3719 0 0 0 0 0 0 0 0 0 0

3719 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3570 0 0 0 0 0 0 0 0 0 0

3720 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3721 0 0 0 0 0 0 0 0 0 0

3721 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

3722 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3723 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3724 0 0 0 0 0 0 0 0 0 0

3724 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3725 0 0 0 0 0 0 0 0 0 0

3725 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3726 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3727 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3728 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3729 0 0 0 0 0 0 0 0 0 0

3729 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This is a specific kind of HashGenerator that simply adds up all of the
 * ints.  Nothing fancy, and pretty quick.
 */

3730 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 3731 0 0 0 0 0 0 0 0 0 0

3731 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3732 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3733 0 0 0 0 0 0 0 0 0 0

3733 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

3734 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3735 0 0 0 0 0 0 0 0 0 0

3735 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

3736 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3737 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3736 0 0 0 0 0 0 0 0 0 0

3738 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3573 0 0 0 0 0 0 0 0 0 0

3739 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3740 0 0 0 0 0 0 0 0 0 0

3740 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3573 0 0 0 0 0 0 0 0 0 0

3741 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3576 0 0 0 0 0 0 0 0 0 0

3742 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3743 0 0 0 0 0 0 0 0 0 0

3743 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3576 0 0 0 0 0 0 0 0 0 0

3744 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3579 0 0 0 0 0 0 0 0 0 0

3745 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3746 0 0 0 0 0 0 0 0 0 0

3746 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3579 0 0 0 0 0 0 0 0 0 0

3747 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3580 0 0 0 0 0 0 0 0 0 0

3748 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3749 0 0 0 0 0 0 0 0 0 0

3749 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3580 0 0 0 0 0 0 0 0 0 0

3750 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3581 0 0 0 0 0 0 0 0 0 0

3751 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3752 0 0 0 0 0 0 0 0 0 0

3752 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3581 0 0 0 0 0 0 0 0 0 0

3753 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3582 0 0 0 0 0 0 0 0 0 0

3754 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3755 0 0 0 0 0 0 0 0 0 0

3755 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3582 0 0 0 0 0 0 0 0 0 0

3756 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3583 0 0 0 0 0 0 0 0 0 0

3757 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3758 0 0 0 0 0 0 0 0 0 0

3758 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3583 0 0 0 0 0 0 0 0 0 0

3759 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3584 0 0 0 0 0 0 0 0 0 0

3760 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3761 0 0 0 0 0 0 0 0 0 0

3761 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3584 0 0 0 0 0 0 0 0 0 0

3762 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3585 0 0 0 0 0 0 0 0 0 0

3763 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3764 0 0 0 0 0 0 0 0 0 0

3764 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3585 0 0 0 0 0 0 0 0 0 0

3765 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3587 0 0 0 0 0 0 0 0 0 0

3766 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3767 0 0 0 0 0 0 0 0 0 0

3767 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3587 0 0 0 0 0 0 0 0 0 0

3768 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3589 0 0 0 0 0 0 0 0 0 0

3769 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3770 0 0 0 0 0 0 0 0 0 0

3770 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3589 0 0 0 0 0 0 0 0 0 0

3771 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3592 0 0 0 0 0 0 0 0 0 0

3772 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3773 0 0 0 0 0 0 0 0 0 0

3773 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3592 0 0 0 0 0 0 0 0 0 0

3774 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3593 0 0 0 0 0 0 0 0 0 0

3775 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3776 0 0 0 0 0 0 0 0 0 0

3776 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3593 0 0 0 0 0 0 0 0 0 0

3777 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3594 0 0 0 0 0 0 0 0 0 0

3778 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3779 0 0 0 0 0 0 0 0 0 0

3779 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3594 0 0 0 0 0 0 0 0 0 0

3780 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3595 0 0 0 0 0 0 0 0 0 0

3781 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3782 0 0 0 0 0 0 0 0 0 0

3782 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3595 0 0 0 0 0 0 0 0 0 0

3783 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3596 0 0 0 0 0 0 0 0 0 0

3784 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3785 0 0 0 0 0 0 0 0 0 0

3785 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3596 0 0 0 0 0 0 0 0 0 0

3786 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3597 0 0 0 0 0 0 0 0 0 0

3787 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3788 0 0 0 0 0 0 0 0 0 0

3788 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3597 0 0 0 0 0 0 0 0 0 0

3789 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3598 0 0 0 0 0 0 0 0 0 0

3790 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3791 0 0 0 0 0 0 0 0 0 0

3791 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3598 0 0 0 0 0 0 0 0 0 0

3792 27 UnalignedLVecBase4f const * 0 8576 27 UnalignedLVecBase4f const * 27 UnalignedLVecBase4f const * 0 0 3793 0 0 0 0 0 0 0 0 0 0

3793 25 UnalignedLVecBase4f const 0 8832 25 UnalignedLVecBase4f const 25 UnalignedLVecBase4f const 0 0 3600 0 0 0 0 0 0 0 0 0 0

3794 21 UnalignedLVecBase4f * 0 8576 21 UnalignedLVecBase4f * 21 UnalignedLVecBase4f * 0 0 3600 0 0 0 0 0 0 0 0 0 0

3795 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3602 0 0 0 0 0 0 0 0 0 0

3796 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3797 0 0 0 0 0 0 0 0 0 0

3797 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3602 0 0 0 0 0 0 0 0 0 0

3798 27 UnalignedLVecBase4d const * 0 8576 27 UnalignedLVecBase4d const * 27 UnalignedLVecBase4d const * 0 0 3799 0 0 0 0 0 0 0 0 0 0

3799 25 UnalignedLVecBase4d const 0 8832 25 UnalignedLVecBase4d const 25 UnalignedLVecBase4d const 0 0 3604 0 0 0 0 0 0 0 0 0 0

3800 21 UnalignedLVecBase4d * 0 8576 21 UnalignedLVecBase4d * 21 UnalignedLVecBase4d * 0 0 3604 0 0 0 0 0 0 0 0 0 0

3801 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3606 0 0 0 0 0 0 0 0 0 0

3802 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3803 0 0 0 0 0 0 0 0 0 0

3803 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3606 0 0 0 0 0 0 0 0 0 0

3804 27 UnalignedLVecBase4i const * 0 8576 27 UnalignedLVecBase4i const * 27 UnalignedLVecBase4i const * 0 0 3805 0 0 0 0 0 0 0 0 0 0

3805 25 UnalignedLVecBase4i const 0 8832 25 UnalignedLVecBase4i const 25 UnalignedLVecBase4i const 0 0 3608 0 0 0 0 0 0 0 0 0 0

3806 21 UnalignedLVecBase4i * 0 8576 21 UnalignedLVecBase4i * 21 UnalignedLVecBase4i * 0 0 3608 0 0 0 0 0 0 0 0 0 0

3807 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3610 0 0 0 0 0 0 0 0 0 0

3808 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3809 0 0 0 0 0 0 0 0 0 0

3809 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3610 0 0 0 0 0 0 0 0 0 0

3810 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3611 0 0 0 0 0 0 0 0 0 0

3811 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3812 0 0 0 0 0 0 0 0 0 0

3812 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3611 0 0 0 0 0 0 0 0 0 0

3813 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3612 0 0 0 0 0 0 0 0 0 0

3814 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3815 0 0 0 0 0 0 0 0 0 0

3815 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3612 0 0 0 0 0 0 0 0 0 0

3816 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3613 0 0 0 0 0 0 0 0 0 0

3817 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3818 0 0 0 0 0 0 0 0 0 0

3818 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3613 0 0 0 0 0 0 0 0 0 0

3819 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3614 0 0 0 0 0 0 0 0 0 0

3820 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3821 0 0 0 0 0 0 0 0 0 0

3821 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3614 0 0 0 0 0 0 0 0 0 0

3822 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3615 0 0 0 0 0 0 0 0 0 0

3823 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3824 0 0 0 0 0 0 0 0 0 0

3824 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3615 0 0 0 0 0 0 0 0 0 0

3825 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3616 0 0 0 0 0 0 0 0 0 0

3826 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3827 0 0 0 0 0 0 0 0 0 0

3827 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3616 0 0 0 0 0 0 0 0 0 0

3828 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3618 0 0 0 0 0 0 0 0 0 0

3829 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3619 0 0 0 0 0 0 0 0 0 0

3830 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3831 0 0 0 0 0 0 0 0 0 0

3831 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3620 0 0 0 0 0 0 0 0 0 0

3832 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3833 0 0 0 0 0 0 0 0 0 0

3833 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3618 0 0 0 0 0 0 0 0 0 0

3834 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3835 0 0 0 0 0 0 0 0 0 0

3835 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3619 0 0 0 0 0 0 0 0 0 0

3836 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3620 0 0 0 0 0 0 0 0 0 0

3837 26 UnalignedLMatrix4f const * 0 8576 26 UnalignedLMatrix4f const * 26 UnalignedLMatrix4f const * 0 0 3838 0 0 0 0 0 0 0 0 0 0

3838 24 UnalignedLMatrix4f const 0 8832 24 UnalignedLMatrix4f const 24 UnalignedLMatrix4f const 0 0 3624 0 0 0 0 0 0 0 0 0 0

3839 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3622 0 0 0 0 0 0 0 0 0 0

3840 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3623 0 0 0 0 0 0 0 0 0 0

3841 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3842 0 0 0 0 0 0 0 0 0 0

3842 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3622 0 0 0 0 0 0 0 0 0 0

3843 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3844 0 0 0 0 0 0 0 0 0 0

3844 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3623 0 0 0 0 0 0 0 0 0 0

3845 20 UnalignedLMatrix4f * 0 8576 20 UnalignedLMatrix4f * 20 UnalignedLMatrix4f * 0 0 3624 0 0 0 0 0 0 0 0 0 0

3846 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3626 0 0 0 0 0 0 0 0 0 0

3847 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3848 0 0 0 0 0 0 0 0 0 0

3848 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3626 0 0 0 0 0 0 0 0 0 0

3849 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3628 0 0 0 0 0 0 0 0 0 0

3850 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3629 0 0 0 0 0 0 0 0 0 0

3851 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3852 0 0 0 0 0 0 0 0 0 0

3852 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3630 0 0 0 0 0 0 0 0 0 0

3853 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 3854 0 0 0 0 0 0 0 0 0 0

3854 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3628 0 0 0 0 0 0 0 0 0 0

3855 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 3856 0 0 0 0 0 0 0 0 0 0

3856 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3629 0 0 0 0 0 0 0 0 0 0

3857 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3630 0 0 0 0 0 0 0 0 0 0

3858 26 UnalignedLMatrix4d const * 0 8576 26 UnalignedLMatrix4d const * 26 UnalignedLMatrix4d const * 0 0 3859 0 0 0 0 0 0 0 0 0 0

3859 24 UnalignedLMatrix4d const 0 8832 24 UnalignedLMatrix4d const 24 UnalignedLMatrix4d const 0 0 3634 0 0 0 0 0 0 0 0 0 0

3860 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3632 0 0 0 0 0 0 0 0 0 0

3861 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3633 0 0 0 0 0 0 0 0 0 0

3862 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 3863 0 0 0 0 0 0 0 0 0 0

3863 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3632 0 0 0 0 0 0 0 0 0 0

3864 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 3865 0 0 0 0 0 0 0 0 0 0

3865 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3633 0 0 0 0 0 0 0 0 0 0

3866 20 UnalignedLMatrix4d * 0 8576 20 UnalignedLMatrix4d * 20 UnalignedLMatrix4d * 0 0 3634 0 0 0 0 0 0 0 0 0 0

3867 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3636 0 0 0 0 0 0 0 0 0 0

3868 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3869 0 0 0 0 0 0 0 0 0 0

3869 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3636 0 0 0 0 0 0 0 0 0 0

3870 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3637 0 0 0 0 0 0 0 0 0 0

3871 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 3872 0 0 0 0 0 0 0 0 0 0

3872 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3637 0 0 0 0 0 0 0 0 0 0

3873 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3638 0 0 0 0 0 0 0 0 0 0

3874 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 3875 0 0 0 0 0 0 0 0 0 0

3875 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3638 0 0 0 0 0 0 0 0 0 0

3876 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3639 0 0 0 0 0 0 0 0 0 0

3877 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 3878 0 0 0 0 0 0 0 0 0 0

3878 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3639 0 0 0 0 0 0 0 0 0 0

3879 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3640 0 0 0 0 0 0 0 0 0 0

3880 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 3881 0 0 0 0 0 0 0 0 0 0

3881 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3640 0 0 0 0 0 0 0 0 0 0

3882 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3641 0 0 0 0 0 0 0 0 0 0

3883 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 3884 0 0 0 0 0 0 0 0 0 0

3884 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3641 0 0 0 0 0 0 0 0 0 0

3885 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 3886 0 0 0 0 0 0 0 0 0 0

3886 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3712 0 0 0 0 0 0 0 0 0 0

3887 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3712 0 0 0 0 0 0 0 0 0 0

3888 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3889 0 0 0 0 0 0 0 0 0 0

3889 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3696 0 0 0 0 0 0 0 0 0 0

3890 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3572 0 0 0 0 0 0 0 0 0 0

3891 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3696 0 0 0 0 0 0 0 0 0 0

3892 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 3893 12 0 0 0 0 0 0 0 0 0 0

3893 12 double const 0 8832 12 double const 12 double const 0 0 3575 0 0 0 0 0 0 0 0 0 0

3894 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 3895 12 0 0 0 0 0 0 0 0 0 0

3895 11 float const 0 8832 11 float const 11 float const 0 0 3572 0 0 0 0 0 0 0 0 0 0

3896 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3575 12 0 0 0 0 0 0 0 0 0 0

3897 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3572 12 0 0 0 0 0 0 0 0 0 0

0
77
3898 1 x 0 6 3572 2013 2015 0 0 0 0 0 0 13 LVecBase2f::x 0

3899 1 y 0 6 3572 2014 2016 0 0 0 0 0 0 13 LVecBase2f::y 0

3900 1 x 0 6 3575 2079 2081 0 0 0 0 0 0 13 LVecBase2d::x 0

3901 1 y 0 6 3575 2080 2082 0 0 0 0 0 0 13 LVecBase2d::y 0

3902 1 x 0 6 3578 2145 2147 0 0 0 0 0 0 13 LVecBase2i::x 0

3903 1 y 0 6 3578 2146 2148 0 0 0 0 0 0 13 LVecBase2i::y 0

3904 1 x 0 6 3572 2303 2307 0 0 0 0 0 0 13 LVecBase3f::x 0

3905 1 y 0 6 3572 2304 2308 0 0 0 0 0 0 13 LVecBase3f::y 0

3906 1 z 0 6 3572 2305 2309 0 0 0 0 0 0 13 LVecBase3f::z 0

3907 2 xy 0 2 3570 2310 0 0 0 0 0 0 0 14 LVecBase3f::xy 0

3908 2 xz 0 2 3570 2311 0 0 0 0 0 0 0 14 LVecBase3f::xz 0

3909 2 yz 0 2 3570 2312 0 0 0 0 0 0 0 14 LVecBase3f::yz 0

3910 1 x 0 6 3575 2379 2383 0 0 0 0 0 0 13 LVecBase3d::x 0

3911 1 y 0 6 3575 2380 2384 0 0 0 0 0 0 13 LVecBase3d::y 0

3912 1 z 0 6 3575 2381 2385 0 0 0 0 0 0 13 LVecBase3d::z 0

3913 2 xy 0 2 3573 2386 0 0 0 0 0 0 0 14 LVecBase3d::xy 0

3914 2 xz 0 2 3573 2387 0 0 0 0 0 0 0 14 LVecBase3d::xz 0

3915 2 yz 0 2 3573 2388 0 0 0 0 0 0 0 14 LVecBase3d::yz 0

3916 1 x 0 6 3578 2455 2459 0 0 0 0 0 0 13 LVecBase3i::x 0

3917 1 y 0 6 3578 2456 2460 0 0 0 0 0 0 13 LVecBase3i::y 0

3918 1 z 0 6 3578 2457 2461 0 0 0 0 0 0 13 LVecBase3i::z 0

3919 2 xy 0 2 3576 2462 0 0 0 0 0 0 0 14 LVecBase3i::xy 0

3920 2 xz 0 2 3576 2463 0 0 0 0 0 0 0 14 LVecBase3i::xz 0

3921 2 yz 0 2 3576 2464 0 0 0 0 0 0 0 14 LVecBase3i::yz 0

3922 2 xy 0 2 3579 2521 0 0 0 0 0 0 0 13 LVector3f::xy 0

3923 2 xz 0 2 3579 2522 0 0 0 0 0 0 0 13 LVector3f::xz 0

3924 2 yz 0 2 3579 2523 0 0 0 0 0 0 0 13 LVector3f::yz 0

3925 2 xy 0 2 3580 2555 0 0 0 0 0 0 0 13 LVector3d::xy 0

3926 2 xz 0 2 3580 2556 0 0 0 0 0 0 0 13 LVector3d::xz 0

3927 2 yz 0 2 3580 2557 0 0 0 0 0 0 0 13 LVector3d::yz 0

3928 2 xy 0 2 3581 2589 0 0 0 0 0 0 0 13 LVector3i::xy 0

3929 2 xz 0 2 3581 2590 0 0 0 0 0 0 0 13 LVector3i::xz 0

3930 2 yz 0 2 3581 2591 0 0 0 0 0 0 0 13 LVector3i::yz 0

3931 2 xy 0 2 3582 2615 0 0 0 0 0 0 0 12 LPoint3f::xy 0

3932 2 xz 0 2 3582 2616 0 0 0 0 0 0 0 12 LPoint3f::xz 0

3933 2 yz 0 2 3582 2617 0 0 0 0 0 0 0 12 LPoint3f::yz 0

3934 2 xy 0 2 3583 2638 0 0 0 0 0 0 0 12 LPoint3d::xy 0

3935 2 xz 0 2 3583 2639 0 0 0 0 0 0 0 12 LPoint3d::xz 0

3936 2 yz 0 2 3583 2640 0 0 0 0 0 0 0 12 LPoint3d::yz 0

3937 2 xy 0 2 3584 2661 0 0 0 0 0 0 0 12 LPoint3i::xy 0

3938 2 xz 0 2 3584 2662 0 0 0 0 0 0 0 12 LPoint3i::xz 0

3939 2 yz 0 2 3584 2663 0 0 0 0 0 0 0 12 LPoint3i::yz 0

3940 1 x 0 6 3572 2693 2699 0 0 0 0 0 0 13 LVecBase4f::x 0

3941 1 y 0 6 3572 2694 2700 0 0 0 0 0 0 13 LVecBase4f::y 0

3942 1 z 0 6 3572 2695 2701 0 0 0 0 0 0 13 LVecBase4f::z 0

3943 3 xyz 0 2 3585 2697 0 0 0 0 0 0 0 15 LVecBase4f::xyz 0

3944 2 xy 0 2 3570 2698 0 0 0 0 0 0 0 14 LVecBase4f::xy 0

3945 1 x 0 6 3575 2781 2787 0 0 0 0 0 0 13 LVecBase4d::x 0

3946 1 y 0 6 3575 2782 2788 0 0 0 0 0 0 13 LVecBase4d::y 0

3947 1 z 0 6 3575 2783 2789 0 0 0 0 0 0 13 LVecBase4d::z 0

3948 3 xyz 0 2 3587 2785 0 0 0 0 0 0 0 15 LVecBase4d::xyz 0

3949 2 xy 0 2 3573 2786 0 0 0 0 0 0 0 14 LVecBase4d::xy 0

3950 1 x 0 6 3578 2869 2875 0 0 0 0 0 0 13 LVecBase4i::x 0

3951 1 y 0 6 3578 2870 2876 0 0 0 0 0 0 13 LVecBase4i::y 0

3952 1 z 0 6 3578 2871 2877 0 0 0 0 0 0 13 LVecBase4i::z 0

3953 3 xyz 0 2 3589 2873 0 0 0 0 0 0 0 15 LVecBase4i::xyz 0

3954 2 xy 0 2 3576 2874 0 0 0 0 0 0 0 14 LVecBase4i::xy 0

3955 3 xyz 0 2 3592 2943 0 0 0 0 0 0 0 14 LVector4f::xyz 0

3956 2 xy 0 2 3579 2944 0 0 0 0 0 0 0 13 LVector4f::xy 0

3957 3 xyz 0 2 3593 2963 0 0 0 0 0 0 0 14 LVector4d::xyz 0

3958 2 xy 0 2 3580 2964 0 0 0 0 0 0 0 13 LVector4d::xy 0

3959 3 xyz 0 2 3594 2983 0 0 0 0 0 0 0 14 LVector4i::xyz 0

3960 2 xy 0 2 3581 2984 0 0 0 0 0 0 0 13 LVector4i::xy 0

3961 3 xyz 0 2 3595 3001 0 0 0 0 0 0 0 13 LPoint4f::xyz 0

3962 2 xy 0 2 3582 3002 0 0 0 0 0 0 0 12 LPoint4f::xy 0

3963 3 xyz 0 2 3596 3021 0 0 0 0 0 0 0 13 LPoint4d::xyz 0

3964 2 xy 0 2 3583 3022 0 0 0 0 0 0 0 12 LPoint4d::xy 0

3965 3 xyz 0 2 3597 3041 0 0 0 0 0 0 0 13 LPoint4i::xyz 0

3966 2 xy 0 2 3584 3042 0 0 0 0 0 0 0 12 LPoint4i::xy 0

3967 4 rows 0 66 3585 3073 0 0 0 0 3070 0 0 15 LMatrix3f::rows 0

3968 4 cols 0 66 3585 3074 0 0 0 0 3070 0 0 15 LMatrix3f::cols 0

3969 4 rows 0 66 3598 3163 0 0 0 0 3160 0 0 15 LMatrix4f::rows 0

3970 4 cols 0 66 3598 3164 0 0 0 0 3160 0 0 15 LMatrix4f::cols 0

3971 4 rows 0 66 3587 3267 0 0 0 0 3264 0 0 15 LMatrix3d::rows 0

3972 4 cols 0 66 3587 3268 0 0 0 0 3264 0 0 15 LMatrix3d::cols 0

3973 4 rows 0 66 3602 3355 0 0 0 0 3352 0 0 15 LMatrix4d::rows 0

3974 4 cols 0 66 3602 3356 0 0 0 0 3352 0 0 15 LMatrix4d::cols 0

14
3975 8 get_rows 0 3070 3073 19 LMatrix3f::get_rows 0

3976 8 get_cols 0 3070 3074 19 LMatrix3f::get_cols 0

3977 9 get_col2s 0 3070 3076 20 LMatrix3f::get_col2s 0

3978 9 get_row2s 0 3070 3075 20 LMatrix3f::get_row2s 0

3979 8 get_rows 0 3160 3163 19 LMatrix4f::get_rows 0

3980 8 get_cols 0 3160 3164 19 LMatrix4f::get_cols 0

3981 9 get_row3s 0 3160 3165 20 LMatrix4f::get_row3s 0

3982 8 get_rows 0 3264 3267 19 LMatrix3d::get_rows 0

3983 8 get_cols 0 3264 3268 19 LMatrix3d::get_cols 0

3984 9 get_col2s 0 3264 3270 20 LMatrix3d::get_col2s 0

3985 9 get_row2s 0 3264 3269 20 LMatrix3d::get_row2s 0

3986 8 get_rows 0 3352 3355 19 LMatrix4d::get_rows 0

3987 8 get_cols 0 3352 3356 19 LMatrix4d::get_cols 0

3988 9 get_row3s 0 3352 3357 20 LMatrix4d::get_row3s 0

